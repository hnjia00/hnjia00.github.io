<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络——JAVA实现web服务器]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94JAVA%E5%AE%9E%E7%8E%B0web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[趁着这几天刚开学，时间还比较宽裕，决定来整理一下自己的实验报告，先从计网开始。 实验目的 处理一个 http 请求 接收并解析 http 请求 从服务器文件系统中获得被请求的文件 创建一个包括被请求的文件的 http 响应信息 直接发送该信息到客户端 实验环境 系统：Mac OS X 10.13.1 语言：JAVA 浏览器：Google Chrome 实验步骤前期准备为了完成本次试验的要求，我编写了两个java代码文件，分别命名为：“HttpRequest.java”和“WebServer.java”。除此之外，我还编写了两个带跳转的测试网页“index.html”和“next.html”以及其各自包含的图片“first.jpg”和“next.jpg” HttpRequest.java的主要功能为：获取http请求中的套接字的输入流和输出流，即完成“对从服务器端发回的数据流”和“将要发送到服务器端的数据流”的处理和输出。 WebServer.java的主要功能为：创建线程，连续创建套接字以及处理http请求。 文件清单如下： 测试阶段我们使用jdk的javac指令对java代码进行编译，然后启动服务器的默认端口8080（代码中预设），然后在Google Chrome浏览器中对各种情况进行测试和检测输出，具体步骤如下。 首先我们启动终端，进入Java代码所在的文件夹下，然后利用javac命令编译main方法所在的Java文件“WebServer.java”，启动服务器，具体如下： 由于代码中设置的启动端口为8080，如下：所以我们在浏览器中需要输入网址“localhost:8080/index.html”以达到访问该网页的目的，具体如下： 在成功访问该网页之后，我们来观察一下终端的输出情况，发现其请求网页index.html请求成功如下：其请求网页包含的图片first.jpg请求成功如下： 然后点击跳转链接，跳转至next.html，访问下一个网页，同样的，网页跳转成功如下： 在成功打开网页之后，我们来观察一下终端的输出情况。同样的，请求网页“next.html”和“next.jpg”成功，输出如下结果： 当然，除了能成功访问的网页外，我们还需要测试一下错误路径的文件访问结果，于是在浏览器中输入一个错误的网址如“localhost:8080/404.html”，结果如下，提示文件不存在：终端反馈输出对404.html这个不存在的文件的访问结果： 代码附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/***********HttpRequest***************/import java.io.* ;import java.net.* ;import java.util.* ;final class HttpRequest implements Runnable &#123; final static String CRLF = "\r\n"; Socket socket; //构造请求类 public HttpRequest(Socket socket) throws Exception &#123; this.socket = socket; &#125; //启动线程 public void run() &#123; try &#123; processRequest(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; private void processRequest() throws Exception &#123; //获取套接字的输入流，即从服务器端发回的数据流 InputStream is = socket.getInputStream(); //获取套接字的输出流，返回的输出流就是将要发送到服务器端的数据流 DataOutputStream os = new DataOutputStream(socket.getOutputStream()); //缓冲字符输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); // 获取http的request信息 String requestLine = br.readLine(); // 从请求行中提取文件信息 StringTokenizer tokens = new StringTokenizer(requestLine); // 由于token将请求行分解为了单词，我们在这里跳过第一个单词，即“GET” tokens.nextToken(); // GET之后即为文件名 String fileName = tokens.nextToken(); // 为了将文件转化到当前目录下，我们在其之前加一个“.” fileName = "." + fileName ; // 打开文件 FileInputStream fis = null ; boolean fileExists = true ; //判断文件是否查询到 try &#123; fis = new FileInputStream(fileName); &#125; catch (FileNotFoundException e) &#123; fileExists = false ; &#125; //测试输出 System.out.println("\n*************Request**************\n"); System.out.println(requestLine); String headerLine = null; while ((headerLine = br.readLine()).length() != 0) &#123; System.out.println(headerLine); &#125; // 构造response信息 String statusLine = null; String contentTypeLine = null; String entityBody = null; if (fileExists) &#123; //执行成功的话返回“200 OK” statusLine = "HTTP/1.0 200 OK" + CRLF; contentTypeLine = "Content-Type: "+contentType(fileName) + CRLF; &#125; else &#123; //执行失败，文件未找到的时候返回“404 File Not Found” statusLine = "HTTP/1.0 404 File Not Found" + CRLF; contentTypeLine = "Content-Type: text/html" + CRLF; entityBody = "&lt;HTML&gt;" + "&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;" + "&lt;P&gt;File name:&lt;/P&gt;"+fileName+ "&lt;BODY&gt;Not Found&lt;/BODY&gt;&lt;/HTML&gt;"; &#125; // 将上述返回值依次输出 os.writeBytes(statusLine); os.writeBytes(contentTypeLine); os.writeBytes(CRLF); System.out.println("\n*************Response**************\n"); System.out.println(statusLine); //调用文件类型输出方法 if (fileExists) &#123; sendBytes(fis, os); fis.close(); &#125; else &#123; os.writeBytes(entityBody) ; &#125; // 结束关闭 os.close(); br.close(); socket.close(); &#125; private static void sendBytes(FileInputStream fis, OutputStream os) throws Exception &#123; //构造一个1K缓冲区，承接套接字的内容 byte[] buffer = new byte[1024]; int bytes = 0; //将请求的文件复制到套接字的输出流中。 while ((bytes = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, bytes); &#125; &#125; private static String contentType(String fileName) &#123; if(fileName.endsWith(".htm") || fileName.endsWith(".html")) &#123; return "text/html"; &#125; else return "other Content-type" ; &#125;&#125; 12345678910111213141516171819202122232425/***********WebServer***************/import java.io.* ;import java.net.* ;import java.util.* ;public final class WebServer &#123; public static void main(String argv[]) throws Exception &#123; int port=8080; // 建立一个套接字 ServerSocket socket = new ServerSocket(port); while (true) &#123; // 监听一个tcp连接的request. Socket connection = socket.accept(); // 处理HTTP请求消息。 HttpRequest request = new HttpRequest(connection); // 建立一个线程处理请求 Thread thread = new Thread(request); thread.start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次聚会]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%81%9A%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天正月十五，也不能说是闲来无事，毕竟还有那么多前路未卜的事情在等着自己，但是总归还是想写一些清闲的东西。 离开学还有五天，还在家能待三天。 今天去马骁家里聚会了，难得小聚一次，吃够了羊肉也喝够了粗，打够了麻将也赢够了钱。 大家都在为自己的前途开始迷茫了，没有明确的路子可走的人大概就是我们这一批大三的学生吧。 学生生涯还剩一年半，留给自己预备的选择也是众说纷纭。 考研怎么考能考得上哪，保研怎么找老师怎么不亏，出国又该怎么闹。 没有人知道该怎么办，就像有人说zgs的cpp课好一样，每个人都只有自己的路，你没有义务去让所有人都跟着自己的路走。 我也没有能力去辨别谁才是自己的模版。 毕竟这世界上，只有一个独一无二的贾浩男。 大家都好久没踢球了，曾经的前锋马骁也吃撑了一百九的中后卫，曾经的后卫现在也早就离开了操场。 被繁杂的课程，学业和人生压的不知所措。 但是有趣的是，我们每个人仿佛还走在自己自认为正确的道路上，自我感觉良好。 我总是难以定夺自己到底应该，或是值得去做什么。 我喜欢观望，观望才能给我很好的选择正确的机会。 但是观望，观望谁呢，谁有值得观望呢？ 无从所知。 我喜欢在街头看着各种各样的人的走走停停，去看他们的生活。 就像我最喜欢的实用文摘的板块，是社会百态。 在一个社会里，每个人都有着自己独一无二的生活。 品味这些生活，也真是一个有趣的过程。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——评论篇]]></title>
    <url>%2F2019%2F02%2F16%2FHexo%E2%80%94%E2%80%94%E8%AF%84%E8%AE%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天给琳琳看了下内测博客的初版，大体上还比较不错。 为了满足琳琳的需求，方便交流，我决定今天给博客添加评论功能。 网上的博客有很多，还是比较乱七八糟的，所以配好之后自己再总结一下，方便后人乘凉。 来必力在跟帖的插件中我选择了来必力：https://www.livere.com 有这几个原因： 界面UI美观 评论管理方便 支持多个社交账号 不过也有一点不方便，来必力隶属于韩国，在注册使用的时候需要科学上网，在网页加载的时候速度较慢。 下面来讲一下具体布置 注册登陆注册需要科学上网，不然是打不开注册登陆界面的，或者打开很慢？这里不做赘述。 安装选择city版安装就能满足我们的需求，直接安装即可。 安装完之后会以代码形式给出，或者也可以手动进入个人管理界面的 代码管理 查看。 对于NexT主题而言，这里我们主要关注 data-uid 的值。 配置得到用于安装插件的data-uid之后，下一步进入NexT的配置文件 _config.yml 设置data-uid的值。 在_config.yml中找到 livere_uid 的属性字样。 将livere_uid设置为刚刚得到的data-uid的值即可。 部署在上述过程完成之后，部署到博客即可。12$ hexo g$ hexo d 演示完成后的效果如下，支持点赞和折叠评论，支持QQ、微信、微博等多种社交账号： 分析上面的配置过程还是比较容易的，但是如果细看一下我还是有一个疑问的，为什么没有用到来必力提供的安装代码呢，为什么只靠一个data-uid就完成了评论功能？ 在查看了NexT下的相关文件后，我得出了结论。 在 themes/next/layout/_partials 文件夹下，有一个 comments.swig 文件。 在里面可以看到支持多个评论插件的安装脚本，比如Facebook，多说等。 NexT用来加载来必力的安装脚本可以在第45～48行看到，加载脚本为：1234&#123;% elseif theme.livere_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; 这段脚本可以用来必力提供的安装代码替换,作用相同：123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="******"&gt;&lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script');&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 在来必力端可以看到具体的评论情况，包括数据分析和评论管理，功能还是非常强大的。 好了，今天的评论的配置就写这么多。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——bug篇]]></title>
    <url>%2F2019%2F02%2F15%2FHexo%E2%80%94%E2%80%94bug%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天写博客的时候，一套hexo操作行云流水，奈何一个hexo g报错报了几百行，在终端里的错误让人害怕的发抖，先上图为敬。 显然这些带有具体文件路径和出错位置的error很难直接百度到解决方法，在百度了很久之后，我找到一个貌似跟我的bug相关的关键词： YAMLException 这是一个在yaml文件中的报错。 于是怀着一个科班出身的计算机人的心态，我决定自己读报错改bug。 首先找到加载出错的原因： ERROR Theme config load failed. 这大概是主题配置文件加载失败了？？？ 其次是出错的文件： ERROR Process failed: _config.yml 果然是主题配置文件出错了！ 继续找一下出错原因： 12345678910111213141516171819202122232425YAMLException: bad indentation of a mapping entry at line 823, column 3: counter: true ^ at generateError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:165:10) at throwError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:171:9) at readBlockMapping (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1080:7) at composeNode (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1332:12) at readDocument (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1492:3) at loadDocuments (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1548:5) at Object.load (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1569:19) at Hexo.yamlHelper (/Users/jiahaonan/blog/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15) at Hexo.tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Hexo.&lt;anonymous&gt; (/Users/jiahaonan/blog/node_modules/bluebird/js/release/method.js:15:34) at Promise.then.text (/Users/jiahaonan/blog/node_modules/hexo/lib/hexo/render.js:61:21) at tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:694:18) at _drainQueueStep (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:138:12) at _drainQueue (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) 妈耶，一开始看到这些bug我已经准备放弃了，因为这些bug并没有影响我提交博客的相关操作。 但是每次 hexo g 后总跟着几百行报错我看起来很难受啊。 还是继续冷静的分析一下吧。 找到YAMLException的提示位置，第823行。 所以，原来是我多打了一个空格！ 好了，冷静地把空格删掉。 重来一遍hexo g，完美运行～ 这个案例告诉我们，修改文件的时候不要把空格不当回事儿，不然都是bug劝退。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——公式篇]]></title>
    <url>%2F2019%2F02%2F14%2FMarkdown%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[写完语法和配置之后，当然还得补充一项最常用的 公式 的写法了。 在写word的时候一直是无脑公式编辑器，看见琳琳用的 latex 的时候总是一脸崇拜，时至今日也得学习一下latex的公式表达，它也是markdown所支持的公式写法。 由于公式的书写要求和规范太多了，我这里就不做生产者了，老老实实做个搬运工。 贴两篇比较好的博客，方便学习～ https://www.jianshu.com/p/a0aa94ef8ab2https://www.cnblogs.com/q735613050/p/7253073.html]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——配置篇]]></title>
    <url>%2F2019%2F02%2F13%2FMarkdown%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[上一篇讲了Markdown的语法，接下来说一下Markdown的插件。 Markdown的编辑器有很多，知乎一下就可以看到不少开源友好的编辑器，为了更好的整合我电脑上现有的软件（为了省内存），我决定在sublime text上写Markdown。 我电脑的配置如下： Mac OS X 10.13.1Sublime Text Version 3.1.1 虽然sublime text3自身携带许多语言的高亮，但是还没有达到我想要的Markdown的编写环境，自带的Markdown不好看也不好用，所以需要拿一些插件来满足一下需求。 需要安装的插件： Package Control:插件安装管理MarkdownEditing:显示Markdown的语法和高亮 可选的插件： OmniMarkupPreviewer:浏览器/html快捷预览和导出MarkdownLivePreview:sublime text界面实时预览 Package ControlPackage Control是Sublime Text不可或缺的一个插件，许多插件的安装和管理都要用到它。两个月之前我在配置NASM的语法和高亮插件时安装配置了Package Control，才第一次接触到Sublime Text的除了写字板之外的功能，所以这里要强烈安利Package Control这一插件，让我有了对不止于Sublime Text写字板的用户体验。 安装插件 打开Sublime Text的控制台 快捷键：control + ` 手动：View -&gt; Show Console 在控制台输入下面的第一行python代码回车即可。不过里面的 http://packagecontrol.io/ 应该是被墙了，这个年头程序员没个VPN还怪麻烦的。我在一些博客里找到了镜像网站，如果第一段代码无法安装，可以尝试一下第二种方法（未测） 1import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 1import urllib.request,os,hashlib; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://dn-52cik.qbox.me/' + pf.replace(' ', '%20')).read(); open(os.path.join( ipp, pf), 'wb' ).write(by) 使用安装成功之后，可以在 Sublime Text -&gt; Preference 里看到 Package Control 这一选项，也可以通过组合键 command + shift + p 在搜索框里搜索 Package Control 。 在package control里，最主要使用的是 install package 功能，在install package界面，可以根据个人需求安装所需要的插件。 需要注意的是，最近不使用vpn是无法使用install package功能的，会出现如下提示： 在科学上网之后，可以来到install package的界面。注意已经安装过的插件在搜索里不会在出现，所以这里我的搜索里看不到MarkdownEditing的。 MarkdownEditing这一插件是在sublime text上写markdown的必须的插件，其包含了markdown的语法补全和高亮，效果如下： 除此之外，MarkdownEditing还提供了两个快捷代码段分别用于插入图片和链接： mdl + tab键：插入链接 [](link) mdi + tab键：插入图片 ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 下面来谈两款可选的插件 OmniMarkupPreviewer如果说MarkdownEditing满足了编辑markdown的需求，那么接下来就该谈一下预览需求了。OmniMarkupPreviewer 提供了html端的预览，其具有如下的快捷功能： command + option + o ：浏览器预览 command + option + x ：导出html control + option + c ：复制html代码 其浏览器端预览效果如下,我个人比较喜欢这种预览方式： MarkdownLivePreview当然，如果不喜欢在浏览器和编辑界面频繁切换，sublime text中也有一款在软件端满足实时预览功能的插件： MarkdownLivePreview同样是通过install package来下载安装，效果如下：不过比较可惜的是，由于是在sublime text端进行实时更新，在编辑文字时会有明显的卡顿，所以不是很推荐这一款插件的预览功能。 到此，在sublime text端编写和预览markdown的插件和环境就基本搞定了！ 部分参考自：https://www.jianshu.com/p/335b7d1be39e]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——语法篇]]></title>
    <url>%2F2019%2F02%2F11%2FMarkdown%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近一时兴起，想搭一个自己的blog玩一玩。 在子泰学长的引领下，我也选择了hexo这一开发框架，至于hexo在Mac上的配置的这些过程在此先省略不谈，我们来谈谈hexo上支持的文件 markdown 格式的语法总结。 一、标题Markdown的标题语法需要与 # 配合使用，在标题文字之前添加一到六个#即可生成一级标题到六级标题。 使用：123456#一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 演示：一级标题二级标题三级标题四级标题五级标题六级标题二、字体Markdown的可以对字体设置：粗体，斜体，斜体加粗和删除线四种。 使用：1234**粗体** (使用中 * 与 _ 的效果相同) *斜体* ***斜体加粗*** ~~删除线~~（注意这里的波浪线为半角符号） 演示：粗体斜体斜体加粗删除线 三、引用Markdown在使用引用时需要与 &gt; 配合操作，在需要应用的文字之前添加 &gt; 即可。 使用：123&gt;一级引用 &gt;&gt;二级引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;多级引用 演示： 一级引用 二级引用 多级引用 四、分割线Markdown中分割线可以用连续三个或三个以上的 - 或 * 来实现，一级标题和二级标题会自带下划线。我在sublime text3中用livepreviewer实时预览时发现，使用超过三个时预览端会出现乱码，但是在用html预览时一切正常。 使用：123---*** ------- 演示： 五、图片图片是一个比较麻烦的东西，但是sublime text3中的MarkdownEditing提供了生成图片格式的快捷键，通过使用快捷键或代码段可以直接生成。 使用：12快捷键：command+shift+k 代码段：mdi+tab键 演示：![]()![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 语法：1234567891011![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容,title可加可不加。如果要修改图片位置，可以用如下写法：&lt;div align=center/left/right&gt;![Alt text](/path/to/img.jpg &quot;Optional title&quot;)同样的，还可以用img标签来调整图片的大小，写法如下：&lt;img src=&quot;http:...&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt;这些写法与html的写法一致。 六、超链接MarkdownEditing也提供了生成超链接的快捷代码段，同样简化了实际操作。 使用：mdl+tab键 演示：[](link) 语法：12[超链接名](超链接地址 &quot;超链接title&quot;) 其中的title同样可加可不加 示例：12[百度](https://baidu.com) [微博](https://weibo.com) 演示：百度微博 七、列表Markdown中的列表分为无序列表和有序列表两种，MarkdownEditing中提供回车自动补全，列表之间可以相互嵌套。 无序列表语法：1234+、-或* + 空格 + 内容 + 无序列表 - 无序列表 * 无序列表 演示： 无序列表 无序列表 无序列表 有序列表语法：1234数字 + . + 空格 + 内容 1. 有序列表 2. 有序列表 3. 有序列表 演示： 有序列表 有序列表 有序列表 列表嵌套语法：123&apos;+&apos; + 一级标题tab + &apos;+&apos; + 二级标题tab + tab + &apos;+&apos; + 三级标题 演示： 一级列表 二级列表 三级列表 二级列表 八、表格表格的语法稍微复杂一点，不过可以把他理解为一个格式匹配的过程，也有一点在画图的意思。 语法：12345表头1 | 表头2 | 表头3 - | :-: | -: 靠左 | 居中 | 靠右 第二行用来格式匹配，默认为左对齐，:-:可以实现居中效果，-:实现右对齐 演示： 表头1 表头2 表头3 靠左 居中 靠右 九、代码Markdown中的代码可以放置在一对反引号 `` 中，注意反引号是键盘上数字 1 左边的键，并不是引号。 语法：`单行代码` ``` 多行代码 多行代码 ``` 参考自：https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
