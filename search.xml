<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[言语信息:基于DTW和MFCC的单个词语音识别]]></title>
    <url>%2F2020%2F10%2F11%2F%E8%A8%80%E8%AF%AD%E4%BF%A1%E6%81%AF-%E5%9F%BA%E4%BA%8EDTW%E5%92%8CMFCC%E7%9A%84%E5%8D%95%E4%B8%AA%E8%AF%8D%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[实验内容基于DTW算法实现单个词的语音识别 实验思路MFCC根据上课所学知识，对于单个词的语音进行识别，首先需要将输入的音频信号转化为语音特征MFCC、即梅尔频率倒谱系数(Mel Frequency Cepstrum Coefficient, MFCC)，而MFCC的生成流程如下图所示：为了识别待识别语音，我们首先应该得到一些模版特征(template MFCC)，得到template mfcc后，对于每一条输入进来的待测试音频，将其与模版挨个匹配即可，其最终的分属类别即属于最相似的模版类属。 DTWDTW，即Dynamic Time Warping、动态时间规整算法，为MFCC的匹配提供了一个最基础的方法，其应用思路是：对于表述同样内容的两端音频，由于说话人音色、语速的不同，从而造成了相同的音素在发音时占用着不同的时常，而这些音素在比较时又被务必分在同一类别之下，所以就有了将DTW应用至此的思路。DTW的过程可表示如下：所以现在我们需要定义上图中的wraped path对wraped path的定义有以下两种两者的主要区别在于：Vertical match是否被允许，即是否允许跳过当前的symbol或必须匹配当前的symbol 显然，DTW的求解过程是一个动态规划的思路，所以对于以上两种思路，DP过程可被分别表示如下： LEVENSHTEIN:$$cost_{i,j} = dist_{i,j} + min(cost_{i,j-1}, cost_{i-1,j}, cost_{i-1,j-1})\\ where \qquad cost_{0,0} = dist_{0,0}, i &gt; 0, j &gt; 0$$ DTW:$$cost_{i,j} = dist_{i,j} + min(cost_{i,j-1}, cost_{i-1,j-1}, cost_{i-2,j-1})\\ where \qquad cost_{0,0} = dist_{0,0}, i &gt; 1, j &gt; 0$$ 实验过程有了以上思路后，接下来编写程序实现上述思路： 实验环境 系统：Mac OS X 语言：python3.6.5 requirements: numpy scipy.io.wavfile: 用于wav数据读取 python_speech_features.base: 用于生成MFCC特征 matplotlib 项目结构为了保证泛用性，这里使用面向对象的思想来实现单个词语音识别，定义为Digit_Voice_Rec类： 方法 说明 __init__ 实现类的初始化以及公共变量的赋值 get_input 读取wav文件，返回rate及Amplitude get_mfcc 接收get_input的读入数据，返回对应的MFCC特征 gather_mfcc 整合将所有的数据集，返回总的MFCC列表 get_template 取出当前代表当前类别的模版MFCC DTW 基于DTW的DP实现 LEVENSHTEIN 基于LEVENSHTEIN的DP实现 run_Voice_rec 测试算法的acc及表现 运行步骤项目的运行逻辑及数据流如下图所示： 实验结果数据集本次试验的数据集来源于github上的公开资源，每个数字5条语音数据，有0～9共50条数据英文数字语音语谱图如图所示： 实验结果DTW1234567891011121314151617181920212223242526272829303132333435363738394041424344/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6predict digit: 0, true label: 0predict digit: 0, true label: 0predict digit: 0, true label: 0predict digit: 0, true label: 0predict digit: 9, true label: 1predict digit: 1, true label: 1predict digit: 1, true label: 1predict digit: 1, true label: 1predict digit: 2, true label: 2predict digit: 2, true label: 2predict digit: 2, true label: 2predict digit: 2, true label: 2predict digit: 3, true label: 3predict digit: 3, true label: 3predict digit: 3, true label: 3predict digit: 3, true label: 3predict digit: 4, true label: 4predict digit: 4, true label: 4predict digit: 4, true label: 4predict digit: 4, true label: 4predict digit: 5, true label: 5predict digit: 5, true label: 5predict digit: 5, true label: 5predict digit: 9, true label: 5predict digit: 6, true label: 6predict digit: 6, true label: 6predict digit: 6, true label: 6predict digit: 6, true label: 6predict digit: 7, true label: 7predict digit: 7, true label: 7predict digit: 7, true label: 7predict digit: 7, true label: 7predict digit: 8, true label: 8predict digit: 8, true label: 8predict digit: 8, true label: 8predict digit: 8, true label: 8predict digit: 9, true label: 9predict digit: 9, true label: 9predict digit: 9, true label: 9predict digit: 9, true label: 9Acc: 0.95Process finished with exit code 0 LEVENSHTEIN123456789101112131415161718192021222324252627282930313233343536373839404142/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6predict digit: 0, true label: 0predict digit: 0, true label: 0predict digit: 0, true label: 0predict digit: 0, true label: 0predict digit: 9, true label: 1predict digit: 1, true label: 1predict digit: 1, true label: 1predict digit: 1, true label: 1predict digit: 2, true label: 2predict digit: 2, true label: 2predict digit: 2, true label: 2predict digit: 2, true label: 2predict digit: 3, true label: 3predict digit: 3, true label: 3predict digit: 3, true label: 3predict digit: 3, true label: 3predict digit: 4, true label: 4predict digit: 4, true label: 4predict digit: 4, true label: 4predict digit: 4, true label: 4predict digit: 5, true label: 5predict digit: 5, true label: 5predict digit: 5, true label: 5predict digit: 9, true label: 5predict digit: 6, true label: 6predict digit: 6, true label: 6predict digit: 6, true label: 6predict digit: 6, true label: 6predict digit: 7, true label: 7predict digit: 7, true label: 7predict digit: 7, true label: 7predict digit: 7, true label: 7predict digit: 8, true label: 8predict digit: 8, true label: 8predict digit: 8, true label: 8predict digit: 8, true label: 8predict digit: 9, true label: 9predict digit: 9, true label: 9predict digit: 9, true label: 9predict digit: 9, true label: 9Acc: 0.95 可以看到，在此数据集下，使用LEVENSHTEIN和DTW的区别并不大。 代码附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167# -*- coding: utf-8 -*-import numpy as npimport scipy.io.wavfile as wavimport python_speech_features.base as psffrom matplotlib import pyplot as pltclass Digit_Voice_Rec: def __init__(self, digit_size=9, example_size=5, framerate=16000, channels=1, sampwidth=2, datapath='./data_en/'): ''' :param digit_size: 0～9 :param example_size: 每个数字的训练用例数 :param framerate: 采样频率 16kHz :param channels: 声道数 单声道 :param sampwidth: 采样字节 2Bytes :param datapath: 数据路径 ''' self.digit_size = digit_size self.example_size = example_size self.framerate = framerate self.channels = channels self.sampwidth = sampwidth self.datapath = datapath # 计数器 self.correct_cnt = 0 def get_input(self, filename, show=False): rate, data = wav.read(filename) if show: print(filename, "\tfs, signal:", rate, data) plt.title(filename) plt.xlabel("Time [s]") plt.ylabel("Amplitude") plt.plot(np.linspace(0.,data.shape[0]/rate, data.shape[0]), data, label=filename) plt.show() return rate, data def get_mfcc(self, rate, data): feature = psf.mfcc(signal=data, samplerate=rate, nfft=1200) delta_feature = psf.delta(feature, 1) d_delta_feature = psf.delta(feature, 2) mfcc = np.hstack((feature, delta_feature, d_delta_feature)) return mfcc def gather_mfcc(self): gather = [] for i in range(self.digit_size + 1): _ = [] for j in range(self.example_size): file_name = self.datapath + str(i) + "-" + str(j + 1) + ".wav" r, d = self.get_input(file_name) feature = self.get_mfcc(r, d) _.append(feature) gather.append(_) return gather def get_template(self, gather): template_mfcc = [] # 第0个充当模版 for mfcc in gather: template_mfcc.append(mfcc[0]) return template_mfcc def DTW(self, mfcc1, mfcc2): mfcc1 = np.array(mfcc1) mfcc2 = np.array(mfcc2) def get_distance(x1, x2): dis = 0 for i in range(x1.shape[0]): dis += abs(x1[i] - x2[i]) return dis cost = np.full((mfcc1.shape[0], mfcc2.shape[0]), np.inf) dist = np.zeros((mfcc1.shape[0], mfcc2.shape[0])) # 填充(mfcc1, mfcc2)的distance数组 for i in range(mfcc1.shape[0]): for j in range(mfcc2.shape[0]): dist[i][j] = get_distance(mfcc1[i], mfcc2[j]) # 初始化cost cost[0][0] = dist[0][0] # 初始化i=0行 for j in range(1, mfcc2.shape[0]): cost[0][j] = cost[0][j-1] + dist[0][j] # DWT: cost[i][j] = dist[i][j] + min( # cost[i][j-1], -&gt; # cost[i-1][j-1], /&gt; # cost[i-2][j-1] //&gt; # ) for i in range(2, mfcc1.shape[0]): for j in range(1, mfcc2.shape[0]): cost[i][j] = dist[i][j] + min(cost[i][j-1], cost[i-1][j-1], cost[i-2][j-1]) final_cost = cost[-1][-1] return final_cost def LEVENSHTEIN(self, mfcc1, mfcc2): mfcc1 = np.array(mfcc1) mfcc2 = np.array(mfcc2) def get_distance(x1, x2): dis = 0 for i in range(x1.shape[0]): dis += abs(x1[i] - x2[i]) return dis cost = np.zeros((mfcc1.shape[0], mfcc2.shape[0])) dist = np.zeros((mfcc1.shape[0], mfcc2.shape[0])) # 填充(mfcc1, mfcc2)的distance数组 for i in range(mfcc1.shape[0]): for j in range(mfcc2.shape[0]): dist[i][j] = get_distance(mfcc1[i], mfcc2[j]) # 初始化cost cost[0][0] = dist[0][0] # 初始化i=0行 for i in range(1, mfcc1.shape[0]): cost[i][0] = cost[i - 1][0] + dist[i][0] for j in range(1, mfcc2.shape[0]): cost[0][j] = cost[0][j - 1] + dist[0][j] # DWT: cost[i][j] = dist[i][j] + min( # cost[i][j-1], -&gt; # cost[i-1][j], |&gt; # cost[i-1][j-1] /&gt; # ) for i in range(1, mfcc1.shape[0]): for j in range(1, mfcc2.shape[0]): cost[i][j] = dist[i][j] + min(cost[i][j-1], cost[i-1][j], cost[i-1][j-1]) final_cost = cost[-1][-1] return final_cost def run_Voice_rec(self): gather_mfcc = self.gather_mfcc() template_mfcc = self.get_template(gather_mfcc) test_mfcc = [mfcc for mfcc_i in gather_mfcc for mfcc in mfcc_i[1:]] for i in range(len(test_mfcc)): # 与所有模版匹配，寻找最小的cost cost = [self.LEVENSHTEIN(template, test_mfcc[i]) for template in template_mfcc] # print(cost) pred_digit = np.argmin(np.array(cost)) true_digit = int(i/(self.example_size-1)) if pred_digit == true_digit: self.correct_cnt += 1 print("predict digit: %d, true label: %d"%(pred_digit, true_digit)) print("Acc: %.2f"%(self.correct_cnt/len(test_mfcc)))DVR = Digit_Voice_Rec()DVR.run_Voice_rec()]]></content>
      <categories>
        <category>SLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hadoop:倒排索引]]></title>
    <url>%2F2020%2F10%2F03%2FHadoop-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[倒排索引定义倒排索引(Inverted index)是一种常见的索引方法，其几乎是文档或信息检索系统中最常用的数据结构，适用于快速的全文搜索。 倒排索引可理解为：关键词——&gt;文档区分于正排索引：文档——&gt;关键词 一个倒排索引由全部文档集合中所有不重复的单词的列表构成，对每一个单词，通常有一个包含其的文档列表与之对应。 举例假设有三个候选文档，每个文档的内容如下：123D_0 = &#123;i love hadoop&#125;D_1 = &#123;i love ruc&#125;D_2 = &#123;i love ruc and love hadoop&#125; 要创建倒排索引，首先需要将每个文档中的单词拆分为单独的词(token)，并且列出每个单词归属于哪个文档，在实际使用时，还会给单词赋予权重，例如词频，即该单词在文档中的出现次数：12345&quot;and&quot;: &#123;2:1&#125;&quot;hadoop&quot;: &#123;0:1,2:1&#125;&quot;i&quot;: &#123;0:1,1:1,2:1&#125;&quot;love&quot;: &#123;0:1,1:1,2:2&#125;&quot;ruc&quot;: &#123;1:1,2:1&#125; 当键入检索内容&quot;i&quot; &quot;love&quot; &quot;hadoop&quot;时，其结果将对应{0,1,2} ∩ {0,1,2} ∩ {0,2} = {0, 2}，即文档D_0和D_2包含了该索引下的单词。 Java实现参考文献[1] Inverted index]]></content>
      <categories>
        <category>云计算</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SRG-DQN:Readme]]></title>
    <url>%2F2020%2F06%2F06%2FSRG-DQN-Readme%2F</url>
    <content type="text"><![CDATA[Variance Reduction for Deep Q-Learning using Stochastic Recursive GradientDependenciesThe following dependencies are required：1234gym==0.17.1matplotlib==3.0.3numpy==1.18.3tensorflow==1.15.0 These dependencies can be installed via pip or virtualenv:1pip install -r requirements.txt UsageOur three tasks are in three folders, for example, the MountainCar task corresponds to the SRG-DQN-mountaincar folder. In the MountainCar task, the main body of DQN is integrated into the main code dqn_main.py. In the remaining two tasks, the main body of DQN is separated into RL_brain.py. MountainCarIn the mountaincar task, you can run the model with the following command:1python3 dqn_main.py In the ‘main’ part of dqn_main.py, you can choose to run the model in step or episode mode, or you can choose to implement the SVRG (SVR-DQN) or SARAH (SRG-DQN) variance optimizer. In addition, you can use these command to run fixed anchor point and anchor distance experiments: 1python3 dqn_svrg_fixedData.py 1python3 distance_anchor_point PendulumIn the pendulum task, you can run the model with the following command:1python3 run_Pendulum.py You can choose to use SVRG (SVR-DQN) or SARAH (SRG-DQN) as the variance optimizer in the optimizer property of the DQN object in run_Pendulum.py. CartPoleIn the cartpole task, you can run the model with the following command:1python3 run_CartPole.py You can choose to use SVRG (SVR-DQN) or SARAH (SRG-DQN) as the variance optimizer in the optimizer property of the DQN object in run_CartPole.py. HyperparametersYou can find the details of the experimental settings in Sup-SRG-DQN-NIPS.pdf. ResultsWe did the average step reward experiment in the MountainCar and Pendulum tasks, and the average episode reward experiment in the CartPole task. And in order to ensure the reliability of the experiment, we conducted multiple rounds of repeated experiments under the same experimental parameters. Due to the ε-greedy strategy, the results of some experiments may not be accurately reproduced. The following table lists some experimental results based on SRG-DQN: Task Step/Episode length Final Avg-Reward MountainCar 100,000 steps 0.280 Pendulum 20,000 steps -0.328 CartPole 800 episodes 61.707]]></content>
  </entry>
  <entry>
    <title><![CDATA[保研]]></title>
    <url>%2F2020%2F05%2F24%2F%E4%BF%9D%E7%A0%94%2F</url>
    <content type="text"><![CDATA[最近又快到了保研的季节，细想起来，距离那段忙碌嘈杂的日子已经过去10个月了，由于一些缘由，直到现在我才想起来写这些回忆录，不过时隔过长，一些细节的确难以拿捏。 个人条件 学校/专业：北京交通大学/计算机科学与技术专业 前五学期成绩和排名：GPA3.85、6/219 前六学期成绩和排名：GPA3.89、2/219 六级成绩：513 科研项目：两项校级大创（一项视觉、一项数据挖掘），一项实验室项目（数据挖掘相关）。 奖项： 国家级：国家奖学金*2 省部级：全国大学生数学竞赛、物理竞赛二等奖 校 级：若干 典型的：高分多奖项、无论文科研弱型人员。 5～6月这段时期是保研的关键沉淀期，各大院校基本在此期间逐步开放网络申请，随之而来的就是各种材料的准备以及报名申请，下面主要说一下这段时期的事项： 报名申请一般来说，夏令营的申报通知会在院校官网上的研究生招生、通知公告等板块发出，尤其要注意经常关注这些模块，虽然报名周期不会很短，但还是关注越早越好。 这里cue一些院校的往年链接，加粗代表今年通知已出，请特别关注！： 清华大学计算机系/网络研究院 清华大学软件学院 北京大学信息科学研究院 中国人民大学信息学院 中国人民大学高瓴人工智能学院学院 中国科学院计算技术研究所 中国科学院自动化研究所 中国科学院软件研究所 上海交大电院 由于一些学校只允许内网访问，或已删除往年链接，这里无法列出，请自行查阅。 文书材料申请各个学校的文书材料一般大同小异，从共同点看，均需要以下材料： 夏令营官网报名表：一般为网站自动导出，大部分需要学院盖章、教务处签字或团委盖章等证明。 成绩单：一般要求带有印章的原件。 简历：简历不是硬性要求，一般不用做邮寄材料，应用在面试环节，一般需要大于等于面试官的人数，以6～10份最为常见（除了清华有30多位面试官），建议彩色打印，不超过一页为准（可正反打印）。 个人陈述：一般有模版提供，主要讲述自己的学业、竞赛和科研项目的个人情况，着重强调自己对所申请的研究方向的认知和已经取得的成果，其余文娱类不提，个人陈述有时候也能起到非常重要的作用，例如我（夏令营没进）但九推进北大主要就是因为个人陈述被老师看上了。 导师推荐信：导师推荐信一般自己先备好草稿，一些老师也会亲自给修改，一般为1～3份，部分要求手写。 四六级成绩以及个人获奖证明。 以上所有材料最好提前全部备好一次性盖章、签字、修改，避免重复找老师造成的不便。 6～7月上面的准备工作就绪之后，这里以我的时间轴为例来讲一下保研的历程。 起初我自己其实没什么特别明确要去的地方，所以就海投了很多学校，包括清北复交人南中科院和南开这么多，虽然没有明确的目的，但我本人还是倾向于留在北京发展的。 从6月下旬开始，夏令营的录取通知就不断从邮件、短信和报名系统里公布了，有点戏剧性的是，虽然我本人倾向于留在北京，但我收到的录取通知则是：清华计算机、中科院软件所、人大信院、复旦计算机、南大计算机、南开计算机，一个五五开的结果。其实我起初是把外省学校作为旅游项目去的哈哈，但这样的结果也着实不是我能控制的了。 南开大学最先的是南开。 第一次报南开时候，报的是人工智能学院，但是一周后被刷掉了，后来了解到，南开大学的人工智能是开设在机电/控制方向的，和我本身的计算机专业差别较大，被刷掉也就不足为奇了。这时候距离计算机学院的报名几乎还剩两天截止，于是就火急火燎的报了计算机，幸运的事，虽然几乎错过了正式批的审核，在补录的时候我被补录进去了。 南开的夏令营设在6月，好巧不巧的是，恰好在我操作系统期末考试那天。为了不错过这第一次‘真题考察’的机会，我操作系统提前交卷半小时赶忙去了北京西站，一点到了天津站，但是！南开的计算机在津南校区，还没有直达的地铁，于是我打了110块钱的出租（哭），赶在两点卡点到了面试现场。 南开的选拔只有面试环节，从现场来看，几乎半数都是本校的学生，因为本校的人都穿着正装。 面试环节共分为两个房间，每个房间设有3位导师，面试内容是一样的，1分钟英文自我介绍，5分钟简历面试。其实可以看出来，我第一场准备的异常不充分，几乎卡在期末考试期间，英文自我介绍也没有接到通知，于是本着临场发挥能力，硬是诌出来一段，没想到老师们还挺认可的，老师对我说没有提前准备的自我介绍才能考验出真正的英语能力。 第一个房间很顺利，老师主要针对我的两个项目做了详细的提问，包括： 数据集来源 数据集处理方式 算法的选用 实验结果 项目的目的和意义 还比较巧的是，第一个房间的主面试官是院长，正好和我们学院赵耀老师是一个项目组的，所以沾了很大的光。 第二个房间就比较苛刻了，老师一个开放式的问题：请讲述一下能证明你科研能力的项目，给我问懵了，我先尝试讲了一个创新创业竞赛的例子（拿了一等奖），后来发现并没有什么实质性的工作，于是就就着我的大创重新讲了一遍，这个时候时间已经耽误很久了，所以可以看出，没有提前系统准备项目讲述内容是一件很拉垮的事情。 最后面试结果出来后我拿了83分（应该主要得益于第一个面试房的表现），当下就通过了复试，但南开的制度特殊在：通过复试后需要自行联系导师直接跟进做项目，导师决定签约或不签约，在9月系统开放之前拿到签约的即可被录取。 因为买了下午五点半的火车票，所以没来得及签直接就回去了北京。 中国人民大学在南开回来的路上，手机还剩1%电的时候突然收到了人大夏令营的短信，讲道理收到第一个北京高校的通知我是非常兴奋的，这感觉不亚于收到贵系的通知，毕竟有了能自我能掌控的自信。 人大的日期设在7.5到7.7，印象里和北大冲突了，不过我也没通过北大网申，正好就没了这些困扰。 首先是7.4下午去报道，领到了文化衫、笔记本、纪念u盘还有一张100元的饭卡/门禁卡，人大还为有需求的同学提供了住宿，4人间上下铺。 7.5上午是实验室介绍，下午是机试和笔试环节，印象里是共占80分，重点考察算法和数据结构： 机试40分钟，两道题，考试环境是北大的poj，只能使用c和c++，java不开放。题的难度并不大，毕竟时间短。第一题是斐波那契数列（送分题），第二题是大整数的进制转换，主要背一下c++中的大整数模版就ok了。 之后是笔试，笔试共三道题，应该也是只能使用c和c++。第一题是用3种不同方法实现字符串的拷贝，第二题和第三题有点忘却了，印象里是和BFS相关的还有和操作系统相关的。 7.6是面试的日子，面试共包括群面（英文面）和单面。群面内容主要是英文自我介绍；单面有5个老师，也涉及到英文问题，我被问到的英文问题是：”请阐述struct和class的区别“，其余面试内容主要针对简历提问，重点针对本科期间的项目提问。 中科院软件所中科院我报了四个所，直接录取的仅有软件所一家，说实话比较丧气的，因为软件所并不是我的首选。 软件所的日期设在7.8～7.12。 第一天上午报道，领衣服和饭卡/门禁卡；下午在会议中心听各个实验室的介绍，还有马石庄的演讲，让人很印象深刻。在会议现场有各个实验室的二维码，自己根据自己的兴趣可以报名一个（只有挂掉后才能修改志愿）实验室进行复试。 软件所后来还有组织一起玩的环节，不过我没有去。 我选择的是天基实验室，主要是计算机视觉和计算机网络相关。值得一提的是，这个实验室是为数不多的没有机试的地方，只有笔试和面试。 笔试内容包括：微积分（秋渐近线）、线性代数（求伴随矩阵）、概率论（二重积分）、数据结构（栈和队列）和算法。需要注意，笔试成绩不决定录取结果，仅仅作为老师在面试部分的参照。 面试环节时常5～8分钟，需要做一个个人展示ppt，这也是这几天来唯一一个需要展示ppt的地方，主要内容大概和奖学金答辩类似，重点放在个人成绩和科研经历上就行，可以带稿子答辩。 前一个人进场后会提前抽一个英文题目，我抽到的是对研究生生活的安排规划。进去后首先介绍自己的英文题目，然后进行英文回答，1到2分钟即可。随后开始进行个人展示。值得一提的是，软件所的老师当着我的面拆开了我自己手写的推荐信，比较尴尬，不过也影响不大。我被问到的问题主要是项目数据和模型上的问题，还有为何选择这个实验室，对计算机网络方向的看法，有一个尴尬的问题是“你为什么第六名能拿到两次国奖”，我只能尴尬的回答“因为第五学期拉垮了，前四学期是第2来着，再者国奖也不完全取决于成绩”，注意这种问题一定要自信！ 清华计算机软件所7.12上午面试结束，结束后正好赶上清华计算机上午报道，也比较巧（没报北航是因为和清华冲突了）。 清华7.12上午报道，同样领衣服和饭券，1.30在东主楼机试。我的机试水平在我们本校也就是中等水平，在这里真正体会到了难顶是什么感觉。 需要注意，清华的夏令营只有机试，机试采用测试点机制，通过对应测试点获取相应的得分，共有3道题，4个小时时间。第一题是凯撒加密术（送分题），第二题凭印象描述的话是这样的有一颗树，根结点为1，每个节点都有一个数字代表苹果，从叶节点出发滑到根节点能获得的最多种类的苹果有多少种（中间节点有重复数字），图相关的问题；第三题有一个商人做买卖，给定各个城市的（单向）连接关系以及商品售价，商人在当前城市可以决定买入或卖出商品，但不能在同一个城市又买又卖，求最大的收益。 我在现场只拿到了150分（满分300），最终没有进入前55%，而只有前55%拥有直通9月面试的机会，没有进入55%也不意味着失去了机会，只要能自己联系到愿意推荐你的老师也同样能获得面试机会，只不过9月需要重新进行机试（占15/100分），群面和综合面占85/100分。 因为我没有过55%，所以只能头铁去找老师，这里需要实名感谢张琦学长为我提供了和网络研究院李老师的接触机会，虽然后续我由于个人原因并没有留在这里，但如果不是张学长和李老师，我的清华之旅的确从现在就要直接结束了。 复旦大学/南京大学计算机好巧不巧的是，复旦大学和清华的第一天冲突了，南京大学和清华最后一天冲突了，这样的话，我的外省旅游的想法就没得了。但是为了大清，我还是得放弃另外两所。 这里需要提一句，在明确知道不能去的情况下，一定要发邮件告知对面的招生办给取消名额，一来能为别的同学提供机会，另外也能避免让自己的学校进入所谓的“黑名单”。 中科院计算所上面说到过，中科院只收到了软件所的入营通知。但是在计算所的群里，管理老师发了一则补录报名，原文是未能通过网络申请的同学，可自行联系导师进入夏令营，我并没有提前联系老师，但抱着试一试的心态，还是填了表，戏剧性的是，后面我被通知到进入了夏令营。但和正式营员不同的是，我直接进行机试和面试环节，取消了参观介绍环节（其实这是好事儿）。 我报名的是网数实验室，以数据挖掘、nlp为主。 网数实验室的机试比较友好，考虑到人员来自不同的专业，所以机试不使用oj制度。老师现场发纸质版的题，我们在本机上进行调试（悄悄说一句，因为是本机的缘故，可以提前备好一些模版使用），c/cpp/Java均可。我印象里还记着的题有:实现平衡二叉树、实现全排列、一串数字切割为合法的IPv4格式、xml格式文件解析。最后直接交自己的代码即可，功能不全也没关系。需要注意的是，和软件所不同，计算所的机试会刷人。 机试完了的当天晚上会收到是否进入面试的通知。 第二天面试，面试环节包括25～30min，是目前为止我经历过最长的面试。计算所的面试环节非常有条理，比如数学面由哪几个老师提问，提问多长时间；算法面由谁提问，提问多长时间等等。并且压力也不小，同组六十多位面试同学2/3以上都是985，甚至还有清北。 我的面试环节：自我介绍，这里有意思的是老师并没有让背诵什么中英文介绍，反倒是直接让我陈述‘自己有没有什么bling bling的地方？’；讲述自己读硕/博意向；数学面可以参见我去年发的：计算所面试 ；算法面问了第k大的数，包括在大批数据下如何优化以及算法复杂度；项目面还是根据简历内容提问，和前几次大同小异。 当天晚上便收到了预录取通知，总而言之，最初有七八十人报，机试完了后还剩六十多人，最终通过面试的总共20人，不乏上交南大中科大的大佬，不过有意思的是北大的两个哥们被刷掉了，这也可以激励各位不管各位本科学校怎么样，在面试的现场全看个人表现。 中科院信工所信工所的通知是在南开结束后收到的，和计算所类似，是被某位老师给选入了候补营员。 由于信工所的面试在计算所之后，正巧我又在前天晚上收到了计算所的预录取通知，所以第二天我当面去了信工所一趟，婉拒了老师的邀请。 据我所知信工所的流程应该与其他几个所大同小异，还包括了心理测试。 8～9月说实话，如果我现在停止，说不定我的人生已经是另外一副轨迹了，但是坐在命运的路口，我还是希望能有更多的选择余地。 清华网络空间研究院在张琦学长的倾力帮助下，我7月底联系到了网络研究院的李老师，李老师是负责天地一体化网络方面的研究内容，为人很好也和蔼。虽然我在计算机网络方面的造诣不深，我还是选择了努力实习一段时间，看能否有所成果。 实习从8.16持续到9.2，老师也给我发了九月推免的报名通知，其实是一件很欣喜的事情。 后来的结果无法用三言两语说清，总而言之，我没有留在这里。但是我依然感恩且感谢帮助过我的学长和老师，是这段经历让我在保研的路上真正明白了我需要什么，我应该怎样定夺自己的发展。 北大信科没有经过北大的保研路程是不完整的。 在前三学期结果出来后，我的排名上升到2/219，这也为我报名北大提供了底气，于是我在此打开了北大的报名系统选择了提交。而事实证明，北大只要前三名。在九推通知发布后，我接到了计算机系统结构方向的刘老师的电话，我的一志愿其实是软件与理论，但后来了解到软理名额早已爆满，因为我个人陈述（起作用了！）“打动”了他，另一方面我的排名也的确好看，所以把我拉入了系统结构方向的面试。 说实话，这个方向并不是我喜欢的方向，但是既然来了，总得试一试。 北大的九推总共一天，上午机试下午面试。 机试使用poj平台，开放c/c++/java，潜规则做出1道以上即可，往年的题目都在-&gt;百炼&lt;-平台上有公开，堪称最优好的机试平台。 机试虽然做的一般，但还是进入了下午的面试环节。面试环节是圆桌面试，首先是2min的英文自我介绍，其次是专业面，这里的专业面并不针对于项目经历，而是就编译原理、计算机系体结构的专业知识提问，包括：CPI、IC等的意义、如果xx改变则CPI怎么变、流水和非流水系统对CPI的印象、是否看过龙书、编译的各个阶段、寄存器分配完后的流程。 一同面试的北大本部的几位同学，还有大工和北邮的。他们都很紧张，唯独我除外，大概是因为我本身并没有想留在这里的缘故，所以很放松。其实也欣慰在这里遇到的黎同学以及和她的交流，虽然只有短短两面，但是还是让那段时间颓丧的我想清楚了自己该做什么该去哪儿，和在计算所面试时候的刘同学一样。 9.289.28日上午，我最终选择了中国人民大学。 各位看到这里就干货已经结束了，如果让我给各位一个建议，那就是：导师和方向远大于学校本身，切勿本末倒置，希望你们在这个过程中收获的不仅是一个预录取通知，而是想明白这些对自己意味着什么，自己想要的是什么。:-) 写在后面有人问我为什么这样选择，也有人为我感到不解和困惑。但我觉得，能回答这个问题的不是现在的我，应该是将来的我，如果我的作为真正愧对了我选择，那么才可以说我的选择是失败的。 我选择这里的原因也很简单，我找到一个自己很喜欢的导师，徐君老师不仅自身能力过硬，也给我指明了我真正适合的研究方向，为我的本转研的道路开拓了一个好的开头。 保研是一则看起来非常平坦的道路，但只有亲自经历过的人才能体会其中的个中百味。在这之中，不免会有等不到offer、面试不通过、联系不到导师、选不好方向带来的压力，但我希望各位保研ers，不论在任何时候，都不要把这些压力带来的负面情绪带给你们亲近的人，因为他们既不能感同身受，也不能给你好的建议，只能默默接受你的负面宣泄，这三个月带给你我的，不仅是一则学校的录取通知，更是22岁的你第一次面对这个社会作出的独立选择。]]></content>
  </entry>
  <entry>
    <title><![CDATA[强化学习：on-policy下的TD：Sarsa]]></title>
    <url>%2F2019%2F11%2F28%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9Aon-policy%E4%B8%8B%E7%9A%84TD%EF%BC%9ASarsa%2F</url>
    <content type="text"><![CDATA[这一部分讲一下TD，也就是时序差分学习。 TD(0)算法在使用蒙特卡罗方法时，对价值函数的更新采用如下方法：$$V(S_t) = V(S_t) + \alpha[G_t - V(S_t)]$$也就是说，要实现状态价值/动作价值的更新必须要等到一幕结束，因为只有一幕结束后，回报Gt才可知。 时序差分学习加速了价值的更新，其直接使用下一个时刻的价值估计值以及此刻观察到的收益来对价值函数进行更新：$$V(S_t) = V(S_t) + \alpha[R_t + \gamma V(S_{t+1}) - V(S_t)]$$这种方法被称为TD(0)。 TD算法结合了MC采样方法和DP的自举法，对算法描述如下： 对每一幕循环： 初始化S对幕中的每一步循环： A = 在状态S下根据策略π作出的决策动作 执行动作A，观察到R与S’ V(S) = V(S) + α[R + γV(S’) - V(S)] S = S’ 在多数情况下，TD算法的表现均优于DP和MC算法： 相比DP：不需要环境模型，即描述收益和下一状态联合概率分布的模型。 相比MC：自然的运用了一种在线、完全地震的方法来实现。价值更新只需要等到下一个时刻即可。 接下来我们使用TD方法来解决实际的控制问题。在评估和预测的部分使用TD方法，按照惯例，需要在explore和exploit之间做出权衡，方法被划分为on-policy与off-policy两种。 Sarsa算法由来Sarsa是on-plocy下的TD。其需要学习的是动作价值函数q(s,a)而不是状态价值函数V(s)。 Sarsa对动作价值的更新方法如下：$$Q(S_t,A_t) = Q(S_t,A_t) + \alpha[R_{t+1} + \gamma Q(S_{t+1},A_{t+1}) - Q(S_t,A_t)]$$可以看到，对于一次状态更新，可以用一个五元组来表示：$(S_t,A_t,R_{t+a},S_{t+1},A_{t+1})$，这也是Sarsa算法名字的由来。 算法描述Sarsa的算法流程描述如下： 对每一幕循环： 初始化S使用从Q中得到的策略（如ε-greedy），在S处选取A对幕中的每一步循环： 执行动作A，观察到R与S’ 使用从Q中得到的策略（如ε-greedy），在S’处选取A’ Q(S,A) = Q(S,A) + α[R + γQ(S’,A’) - Q(S,A)] S = S’ A = A’ 下面通过一个实际的问题来深入理解Sarsa的实现： 有风的网格世界问题背景背景为书中的例6.5，以之前介绍过的网格世界为背景，加入了环境干扰，即风。在有风的区域内，动作的执行会收到风的干扰。 超参数超参数如下：规定了网格边界、风带来的影响、动作空间、ε-greedy的ε参数、Sarsa的固定步长、每时刻收益、起点终点坐标：123456789101112131415161718192021222324252627# world heightWORLD_HEIGHT = 7# world widthWORLD_WIDTH = 10# wind strength for each columnWIND = [0, 0, 0, 1, 1, 1, 2, 2, 1, 0]# possible actionsACTION_UP = 0ACTION_DOWN = 1ACTION_LEFT = 2ACTION_RIGHT = 3# probability for explorationEPSILON = 0.1# Sarsa step sizeALPHA = 0.5# reward for each stepREWARD = -1.0START = [3, 0]GOAL = [3, 7]ACTIONS = [ACTION_UP, ACTION_DOWN, ACTION_LEFT, ACTION_RIGHT] S-&gt;S’状态变化的实现如下，主要由动作和风力影响共同实现123456789101112def step(state, action): i, j = state if action == ACTION_UP: return [max(i - 1 - WIND[j], 0), j] elif action == ACTION_DOWN: return [max(min(i + 1 - WIND[j], WORLD_HEIGHT - 1), 0), j] elif action == ACTION_LEFT: return [max(i - WIND[j], 0), max(j - 1, 0)] elif action == ACTION_RIGHT: return [max(i - WIND[j], 0), min(j + 1, WORLD_WIDTH - 1)] else: assert False 动作价值估计根据上面给出的Sarsa算法描述，对每一幕中的动作价值估计，通过代码实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142def episode(q_value): # track the total time steps in this episode time = 0 # initialize state state = START # choose an action based on epsilon-greedy algorithm if np.random.binomial(1, EPSILON) == 1: # ε的概率去随机选取（explore） action = np.random.choice(ACTIONS) else: # 1-ε的概率根据动作价值选取（exploit）： # 返回四个动作对应的价值 values_ = q_value[state[0], state[1], :] # 从最大值的 # action_为枚举values_时对应的下标：0～3 action = np.random.choice([action_ for action_, value_ in enumerate(values_) if value_ == np.max(values_)]) # keep going until get to the goal state while state != GOAL: # 执行动作A，观察到新状态S' # reward固定，不到终止状态都为-1 next_state = step(state, action) # 根据ε-greedy选取动作A' if np.random.binomial(1, EPSILON) == 1: next_action = np.random.choice(ACTIONS) else: values_ = q_value[next_state[0], next_state[1], :] next_action = np.random.choice([action_ for action_, value_ in enumerate(values_) if value_ == np.max(values_)]) # Sarsa update # Q(S,A) = Q(S,A) + α[R + γQ(S',A') - Q(S,A)] q_value[state[0], state[1], action] += \ ALPHA * (REWARD + q_value[next_state[0], next_state[1], next_action] - q_value[state[0], state[1], action]) # S=S' state = next_state # A=A' action = next_action time += 1 return time 这里的on-policy可以理解为：在S处选取A的策略 与 在更新动作价值Q(S,A)时在S’处选取A’的策略相同（均为ε-greedy） 实验结果实验结果如下，可以看到随着时间的推移，目标达成的越来越快：Sarsa给出的最优策略为： 该实验显示出了Sarsa优于MC方法的另一面： 在MC方法中，如果发现某个策略使agent停留在同一个状态内，那么下一幕任务就永远不会开始；但Sarsa这样一步一步的学习方法则没有这个问题，因为其在当前幕运行过程中就能很快的学到当前的策略，如果不够好，然后就会切换到其他的策略。 参考文献[1] https://github.com/ShangtongZhang/reinforcement-learning-an-introduction]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强化学习：蒙特卡洛方法的无穷方差问题]]></title>
    <url>%2F2019%2F11%2F26%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%A0%E7%A9%B7%E6%96%B9%E5%B7%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[上一节介绍MC算法时，为了克服试探性出发这一强假设，rf提出了通过On-Policy和Off-Policy两种持续采样的方法。 在Off-Policy中，为了通过行动策略b观察到的多幕采样序列的平均回报来预测状态价值$v_\pi(s)$，需要根据重要度采样比来调整回报值、并对结果进行平均，根据调整平均方式的不同，又引申出了两种方法：普通重要度采样和加权重要度采样。 从数学的角度来看： 普通重要度采样： 无偏估计方差无界 加权重要度采样 有偏估计（偏差逐渐收敛到0）假设回报值有界，即使重要度采样比方差无界，方差仍然能收敛到0 下面我们从一个简单的模型入手来讨论普通重要度采样的无穷方差问题。 问题背景状态转移概率以及收益如图所示： 这里指定目标策略$\pi(向左|s)=1$，行动策略$b(向左|s)=1/2$.在目标策略下，总是采取向左的行动（因为只有向左才有收益+1）；在行动策略下，等概率执行向左向右行动。 代码实现超参数本题题量较小，涉及到的超参数也不多，超参数仅指定好想左/右的动作即可：12ACTION_BACK = 0 # leftACTION_END = 1 # right 策略模型背景中给出了行为策略和目标策略的定义，代码实现如下：1234567# behavior policy：左右各为0.5def behavior_policy(): return np.random.binomial(1, 0.5)# target policy：只向左走def target_policy(): return ACTION_BACK 一幕动作每一幕中的动作：从s开始选择向左或向右，直到到达终态结束为止。12345678910111213# one turndef play(): # track the action for importance ratio trajectory = [] while True: action = behavior_policy() trajectory.append(action) # 直接向右：结束 if action == ACTION_END: return 0, trajectory # 向左0.9概率回到自身失败，即向左0.1概率到达终态 if np.random.binomial(1, 0.9) == 0: return 1, trajectory 根据重要度采样调和回报这里讨论基于普通重要度采样的回报：12345678910rewards = []for episode in range(0, episodes): reward, trajectory = play() if trajectory[-1] == ACTION_END: rho = 0 else: rho = 1.0 / pow(0.5, len(trajectory)) rewards.append(rho * reward)rewards = np.add.accumulate(rewards)estimations = np.asarray(rewards) / np.arange(1, episodes + 1) 回到问题背景中可以看到，行动策略b是一个(n,0.5)的二项分布，在计算时仅需计算0.5的连乘即可。由于目标策略π下的动作总是向左，即一旦trajectory中出现了向右的动作（向右即进入终态结束，所以只可能出现在最后一个），那意味着分子中将会出现一项$π(a|s)=0$，随机导致整个重要度采样比归0. 实验结果结果如图所示，可以看到：在独立训练10轮，每轮100000幕的情况下，普通重要度采样能让难以收敛到1（在折扣率为1时，持续向左一定能获得收益+1） 对比实验为了与加权重要度采样对比，我对代码做了一点修改：12345678910111213141516171819for run in range(runs): rewards = [] # 记录采样比序列 rho1 = [] for episode in range(0, episodes): reward, trajectory = play() if trajectory[-1] == ACTION_END: rho = 0 else: rho = 1.0 / pow(0.5, len(trajectory)) rho1.append(rho) rewards.append(rho * reward) rewards = np.add.accumulate(rewards) # 计算加权重要度采样 rho1 = np.add.accumulate(rho1) with np.errstate(invalid='ignore'): e1 = np.where(rho1!=0, np.asarray(rewards)/rho1, 0) plt.plot(e1) 结果如图： 可以看到：加权重要度采样方法仅仅在不到100轮的情况下就稳定的收敛到了正确回报+1！ 参考文献[1] https://github.com/ShangtongZhang/reinforcement-learning-an-introduction]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强化学习：蒙特卡罗方法]]></title>
    <url>%2F2019%2F11%2F25%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这里我们开始讨论利用蒙特卡罗方法寻找最优策略。 实话说，MC算法比起前几章来说难度提升了一个档次，但其又是rf后续学习的基础，所以不可懈怠。 本篇以游戏：21点为例，分别讲述蒙特卡洛方法依托于以下三个算法的实现： 试探性出发 Monte Carlo with Exploring Starts 同轨策略 Monte Carlo Sample with On-Policy 离轨策略 Monte Carlo Sample with Off-Policy 蒙特卡罗方法要点与DP不同，MC算法仅仅需要经验（通过采样获得的数据），而不像DP需要完备的环境知识（如租车还车分布等）去遍历状态空间。 MC算法通过平均样本的回报来解决强化学习的问题，价值估计以及策略改进在整个episode结束时进行，这意味着MC算法是逐幕改进的（offline），而非在每个时刻都有改进（online）。 在rf中，“蒙特卡洛”特指对完整回报取平均的算法。 游戏介绍21点游戏，原译为blackjack。 扑克牌A，2～10、JQK分别代表[1或11，2~10、10]，Ace牌可看作1或11。 玩家和庄家开始先发两张牌，庄家明牌一张，若玩家开始两张牌之和小于12则可持续补牌。 游戏开始： 玩家根据一定策略先持续要牌，若为和为21则直接获胜，超过21则认输，适当后停牌 玩家停牌后庄家根据一定策略要牌，若为和为21则直接获胜，超过21则认输，适当后停牌 两人停牌后比较手牌和大小，大的获胜。 超参设计同样的，首先来设计问题建模所需要的超参数。 动作空间： 1234# actions: hit or standACTION_HIT = 0 # 要牌ACTION_STAND = 1 # 停牌ACTIONS = [ACTION_HIT, ACTION_STAND] 玩家策略根据题干要求：玩家在手牌和小于20时持续要牌 123456# 玩家的策略：12～19：要牌、20～21：停牌POLICY_PLAYER = np.zeros(22, dtype=np.int)for i in range(12, 20): POLICY_PLAYER[i] = ACTION_HITPOLICY_PLAYER[20] = ACTION_STANDPOLICY_PLAYER[21] = ACTION_STAND 庄家策略根据题干要求：庄家在手牌和小于17时持续要牌 123456# 庄家的策略：小于17时要牌、17～21时停牌POLICY_DEALER = np.zeros(22)for i in range(12, 17): POLICY_DEALER[i] = ACTION_HITfor i in range(17, 22): POLICY_DEALER[i] = ACTION_STAND 扑克生成随机生成扑克数值1～13 123456# 随机生成牌（1～13）-&gt;（1～10）# card的范围【1～10】def get_card(): card = np.random.randint(1, 14) card = min(card, 10) return card 扑克价值随机生成扑克数值2～11，Ace先默认为11 123# card_value的范围【2～11】def card_value(card_id): return 11 if card_id == 1 else card_id 游戏过程建模游戏共有：输、赢、和三个结果，其收益分别定义为+1、-1、0. MC算法由于不知晓环境模型，所以其核心在于求取动作价值Q而非状态价值V。 这并不是一个简单的事情，我们通过如下过程建模来求取动作价值Q： 参数设定输入值：1def play(policy_player, initial_state=None, initial_action=None): policy_player：即玩家策略，由于庄家策略是固定的POLICY_DEALER，所以可操作的策略为玩家策略。这里可以选用固定的目标策略POLICY_PLAYER，也可以自定义行动策略b来保证对状态空间的探索。 initial_state：【是否将Ace用作11，玩家手牌和，庄家明牌】三元组【usable_ace_player, player_sum, dealer_card1】。 initial_action：用作玩家的初试动作。 玩家参数： player_sum：玩家手牌和。 usable_ace_player：是否将Ace用作11。 庄家参数： dealer_card1：明牌。 dealer_card2：初始发牌的第二张。 usable_ace_dealer：是否将Ace用作11。 返回值：1return state, reward, player_trajectory state：游戏初始状态的三元组[usable_ace_player, player_sum, dealer_card1] reward：【胜、平、负】分别收益【1，0，-1】 player_trajectory：【（是否有ace，玩家手牌之和，地主明牌），行为】轨迹，用于价值估计/策略评估/改进。 发牌根据游戏规则，玩家和庄家初始发牌数为2。但玩家在两张手牌之和小于12时会继续要牌，实现代码如下：12345678910111213141516171819202122232425# 随机初始化if initial_state is None: # 在最开始，即默认有两张手牌 # 如果玩家手中的点数小于11那么必然会要牌直到超过11点 while player_sum &lt; 12: card = get_card() # card_id【1～10】 player_sum += card_value(card) #card_value【2～11】 # 超过21时，可能有两张Ace if player_sum &gt; 21: # 超过21时只有22这一种情况，因为手牌和超过11后不会继续要牌 # 即指有可能为11+x，而x最大为11 assert player_sum == 22 # 所以手牌和为22时必然有一张Ace，此时将其用作1 player_sum -= 10 else: # 要完牌后手牌之和还小于等于21，如果其是ace则认为ace被用作11 usable_ace_player |= (1 == card) # 初始化庄家牌 dealer_card1 = get_card() # 亮牌 dealer_card2 = get_card()# 给定初始化else: usable_ace_player, player_sum, dealer_card1 = initial_state dealer_card2 = get_card() 打牌玩家玩家行为如下：123456789101112131415161718192021222324252627282930313233343536373839 # player's turnwhile True: # 第一步动作由给定值初始化 if initial_action is not None: action = initial_action initial_action = None # 若没有指定动作或此时不是第一步，则动作由输入玩家策略policy_player决定 else: # 动作包括【要牌，停牌】 action = policy_player(usable_ace_player, player_sum, dealer_card1) # 追溯玩家的轨迹，服务重要采样 # 轨迹包括【（是否有ace，玩家手牌之和，地主明牌），行为】 player_trajectory.append([(usable_ace_player, player_sum, dealer_card1), action]) # 停牌 if action == ACTION_STAND: break # 否则即为继续要牌 card = get_card() # 单独使用usable_ace_player不足以区分手牌中用作11的Ace数量，需额外使用ace_count变量 ace_count = int(usable_ace_player) # 先将ace当作11用 if card == 1: ace_count += 1 player_sum += card_value(card) # 如果手牌和超过了21且ace可用，则将ace_count中的一张ace用作1 while player_sum &gt; 21 and ace_count: player_sum -= 10 ace_count -= 1 # 如果所有ace用作1后仍然大于21，则玩家爆牌，返回收益-1 if player_sum &gt; 21: return state, -1, player_trajectory assert player_sum &lt;= 21 # ace_count此时代表用作11的ace，此时只有【0、1】两种可能 usable_ace_player = (ace_count == 1) 庄家庄家行为如下：除要/停牌策略外，其余同上12345678910111213141516171819202122# dealer's turnwhile True: # 庄家策略为固定策略，由POLICY_DEALER决定 action = POLICY_DEALER[dealer_sum] # 停牌 if action == ACTION_STAND: break # if hit, get a new card new_card = get_card() ace_count = int(usable_ace_dealer) if new_card == 1: ace_count += 1 dealer_sum += card_value(new_card) while dealer_sum &gt; 21 and ace_count: dealer_sum -= 10 ace_count -= 1 # 庄家爆牌 if dealer_sum &gt; 21: return state, 1, player_trajectory usable_ace_dealer = (ace_count == 1) 结束当二人均停牌时，取牌结束，比较二者大小即可分出胜负：12345678# 在双方未爆牌情况下比较结果assert player_sum &lt;= 21 and dealer_sum &lt;= 21if player_sum &gt; dealer_sum: return state, 1, player_trajectoryelif player_sum == dealer_sum: return state, 0, player_trajectoryelse: return state, -1, player_trajectory 试探性出发 Exploring Starts蒙特卡罗算法由于不知晓完整的环境模型，且其探索空间为行动策略下的幕序列，所以为了保证算法收敛，模型做了两个比较强的假设： 试探性出发 进行策略评估时有无限多的episode下的样本序列可供试探 这里首先讨论试探性出发。 所谓试探性出发，即：保证所有的“状态，动作”二元组均有非0的概率被选为起点 需要注意的是，策略改进的方法在当前价值函数上贪心的选取动作，由于我们有动作价值函数Q(s,a)，所以不需要环境模型，贪心策略为：$$\pi(s) = argmax_a q(s,a)$$ 前面提到过，MC方法通过平均样本的回报来解决强化学习的问题，体现在：$$Q(S_t,A_t) \leftarrow avg(Returns(S_t,A_t))$$通过试探性出发来评估生成动作状态价值Q(s,a)的代码如下，其中试探性出发体现在initial_state和initial_action的随机选取：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 试探性出发：def monte_carlo_es(episodes): # 维度对应：(playerSum【12～21】, dealerCard【1～10】, usableAce【0，1】, action【hit、stand】) state_action_values = np.zeros((10, 10, 2, 2)) # Q(S,A)需要用到计数取均值，用1初始化，避免➗0 state_action_pair_count = np.ones((10, 10, 2, 2)) # 策略改进，在当前价值函数上贪心的选取并返回一个action # 由于有Q(s,a)所以不需要环境模型信息(没有环境的模型信息意味着无法直接遍历所有的状态空间) # 贪心策略为：π（s）=argmax_a q(s,a) def behavior_policy(usable_ace, player_sum, dealer_card): usable_ace = int(usable_ace) player_sum -= 12 dealer_card -= 1 # state：s 即（player_sum, dealer_card, usable_ace） # action：a 即缺省量，缺省是为了遍历a（因为argmax_a） # 取avg，即实现平均样本回报 values_ = state_action_values[player_sum, dealer_card, usable_ace, :] / \ state_action_pair_count[player_sum, dealer_card, usable_ace, :] # 贪心策略：π（S_t）= argmax_a Q(S_t,a) return np.random.choice([action_ for action_, value_ in enumerate(values_) if value_ == np.max(values_)]) # 对每一幕循环 for episode in tqdm(range(episodes)): # 试探性出发：使每个（动作initial_action，状态initial_state）都可以被选为起点 # 随机生成每一幕的初始状态【usable_ace_player, player_sum, dealer_card】 initial_state = [bool(np.random.choice([0, 1])), np.random.choice(range(12, 22)), np.random.choice(range(1, 11))] # 随机从【hit、stand】取一个策略动作 initial_action = np.random.choice(ACTIONS) # 只在第一轮（即episode==0时）用target_policy_player（Q均为0，没法贪心） # 其余时刻使用贪心动作选取：behavior_policy current_policy = behavior_policy if episode else target_policy_player # 根据初始状态（initial_state,initial_action）和current_policy生成一幕序列trajectory _, reward, trajectory = play(current_policy, initial_state, initial_action) # 对幕中的每一步循环 for (usable_ace, player_sum, dealer_card), action in trajectory: usable_ace = int(usable_ace) player_sum -= 12 dealer_card -= 1 # update values of state-action pairs state_action_values[player_sum, dealer_card, usable_ace, action] += reward state_action_pair_count[player_sum, dealer_card, usable_ace, action] += 1 # Q（St,At）= avg(returns(St,At)) return state_action_values / state_action_pair_count 代码中有一个小trick，即123456# -12和-1的操作是为了对齐数组下标# 因为player_sum永远大于11，dealer_card永远大于1# 因为state_action_values和state_action_pair_count的维度均为【10，10，2，2】# 所以需要对齐player_sum -= 12dealer_card -= 1 On-Policy为了使MC收敛，上面做了两个强假设，而事实上，试探性出发虽然能够起到explore的作用，但其随机选择的(S，A)容易不符合实际（这是显然的，尤其是在状态空间过大时，最优策略不可能分摊给每一个二元组一定的选择概率）。 为了避免很难被满足的试探性出发假设，唯一的一般性解决方法就是智能体能够持续不断的选择所有可能的动作。rf提出了On-Policy和Off-Policy两种方法来保证这一点，这里首先介绍On-Policy方法。 在On-Policy中，用于生成采样数据序列的策略和用于实际决策的待评估和改进策略相同，即action-policy=target-policy。 实现代码如下：123456789101112131415161718192021# 直接使用target-policy生成episode序列，未涉及优化policydef monte_carlo_on_policy(episodes): states_usable_ace = np.zeros((10, 10)) states_usable_ace_count = np.ones((10, 10)) states_no_usable_ace = np.zeros((10, 10)) states_no_usable_ace_count = np.ones((10, 10)) for i in tqdm(range(0, episodes)): # on-policy：生成player_trajectory和评估的策略同为：target_policy_player _, reward, player_trajectory = play(target_policy_player) for (usable_ace, player_sum, dealer_card), _ in player_trajectory: player_sum -= 12 dealer_card -= 1 if usable_ace: states_usable_ace_count[player_sum, dealer_card] += 1 states_usable_ace[player_sum, dealer_card] += reward else: states_no_usable_ace_count[player_sum, dealer_card] += 1 states_no_usable_ace[player_sum, dealer_card] += reward return states_usable_ace / states_usable_ace_count, states_no_usable_ace / states_no_usable_ace_count Off-Policy与On-Policy不同，Off-Policy中用于评估或者改进的策略与生成采样数据的策略是不同的，即生成的数据“离开了（off）”待优化策略所决定的决策序列轨迹。 为了实现从行动策略b得到的多幕样本序列取预测目标策略π，这就要求：对任意的π(a|s)&gt;0,均有b(a|s)&gt;0，换句话说，通过行动策略b采样到的序列需要覆盖掉目标策略π下的样本空间。 虽然行动策略b能够做到采样并覆盖，但其采样规律与目标策略毕竟不同，这时候就需要引入一个调和参数$\rho_{t:T-1}$，其称为importance ratio，定义如下，即一幕（t~T-1）时刻中在两种策略下产生同样的（状态，动作）二元组的概率之比：$$\rho_{t:T-1} =\prod_{k=t}^{T-1} \frac{\pi(A_k|S_k)}{b(A_k|S_k)}$$ 有了重要度采样参数，为了取平均，预测（动作）状态价值又引申出了两种方法，区分为在取平均时，选幕长还是采样比之和作为基： 普通重要度采样 ordinary_sampling：无偏估计；方差无界$$V(s)=\frac{\sum_{t \in T(s)} \rho_{(t:T(t)-1)}G_t}{|T(s)|}$$ 加权重要度采样 weighted_sampling：有偏估计，偏差逐渐收敛到0；方差能收敛到0（更偏好该方法）$$V(s)=\frac{\sum_{t \in T(s)} \rho_{(t:T(t)-1)}G_t}{\sum_{t \in T(s)} \rho_{(t:T(t)-1)}}$$ 回到游戏背景中，行动策略b与目标策略分别实现如下：1234567891011121314# 玩家目标策略：通过玩家此时的手牌和player_sum决定策略（要牌/停牌）# 用于off-policy的目标策略πdef target_policy_player(usable_ace_player, player_sum, dealer_card): return POLICY_PLAYER[player_sum]# 玩家行动策略：用于生成幕序列探索# 用于off-policy的行为策略b# 保证了ε软性，即每个action都有被选取到的概率def behavior_policy_player(usable_ace_player, player_sum, dealer_card): # 二项分布（1，0.5）执行一次p=0.5的实验 # 随机返回0/1 if np.random.binomial(1, 0.5) == 1: return ACTION_STAND return ACTION_HIT 评估对比代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# Monte Carlo Sample with Off-Policydef monte_carlo_off_policy(episodes): # 给定初始状态【ace，player_sum，dealer_card】 initial_state = [True, 13, 2] # 记录采样比、回报列表 rhos = [] returns = [] # 对每一幕循环 for i in range(0, episodes): # 根据行动策略b：behavior_policy_player生成一幕数据：player_trajectory _, reward, player_trajectory = play(behavior_policy_player, initial_state=initial_state) # get the importance ratio # 重要度采样 numerator = 1.0 # 分子为策略π denominator = 1.0 # 分母为策略b # 对幕中的每一步循环，累乘重要度采样 for (usable_ace, player_sum, dealer_card), action in player_trajectory: if action == target_policy_player(usable_ace, player_sum, dealer_card): # 行为策略b为（1,0.5）的二项分布，连乘的概率量为0.5 denominator *= 0.5 else: # 由于π(action | state)即target_policy在本例中是确定的 # 即对一个state输入，其在两个action的概率采样中必然一个为1一个为0 # 所以一旦b产生的行为action不等于π的action # 即证明此时π(A_k|S_k)==0 # 由于重要度采样比中使用连乘，所以π对应的分子直接为0 numerator = 0.0 break # 重要度采样比 rho = numerator / denominator # 重要度采样比序列 rhos.append(rho) # 回报序列 returns.append(reward) rhos = np.asarray(rhos) returns = np.asarray(returns) # 加权回报 weighted_returns = rhos * returns # 对weighted_returns进行累加 # accumulate（【1，2，3】）=【1，3，6】 weighted_returns = np.add.accumulate(weighted_returns) rhos = np.add.accumulate(rhos) # 普通重要性采样 ordinary_sampling = weighted_returns / np.arange(1, episodes + 1) # 加权重要性采样 # errstate(**kwargs) 用于浮点错误处理的上下文管理器 with np.errstate(divide='ignore',invalid='ignore'): weighted_sampling = np.where(rhos != 0, weighted_returns / rhos, 0) return ordinary_sampling, weighted_sampling 实验结果最优策略如书中所示，这里仅展示off-policy下的两种方法结果对比：虽然两种方法误差最终均能收敛接近于0，但加权重要度采样在episode开始时也能保证一个较低的误差，是实践中常常选取的方法。 参考文献[1] https://github.com/ShangtongZhang/reinforcement-learning-an-introduction]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强化学习：DP优化之价值迭代]]></title>
    <url>%2F2019%2F11%2F24%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9ADP%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%B7%E5%80%BC%E8%BF%AD%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[上一篇博客以杰克租车问题为背景建模了策略迭代算法，策略迭代算法是一类以DP优化为基础并且能够收敛到最优策略$\pi_*$的算法，但是其存在着一些缺点。比如：每一次迭代都涉及到了策略评估过程，从而导致需要多次遍历状态集合。在租车问题中，只有两个租车场的情况下，遍历状态空间需要$O(n^4)$的复杂度（租车2*还车2=4），假如再扩大停车场数，算法复杂度将以幂指数级别递增！ 价值迭代事实上，在策略迭代算法中，我们无需等到算法完全收敛。在一般情况下，策略评估算法在执行够一定轮数之后对其DP策略将不会再产生任何影响。所以核心问题变成了，如何在适当的时间节点提前阻断价值评估。 价值迭代算法应运而生。价值迭代算法为：在一次遍历后即刻停止策略评估（对每个状态进行一次更新）更新过程为：$$v_{k+1}(s) = max_a E[R_{t+1}+\gamma v_k(S_{t+1})| S_t=s,A_t=a]\\\;= max_a\sum_{s’,r}p(s’,r|s,a)[r+\gamma v_k(s’)]$$ 算法流程为： repeat： ∆ ← 0对每一个 s ∈ S repeat: v ← V(s)$V(s) \leftarrow max_a\sum_{s’,r}p(s’,r|s,a)[r+\gamma V(s’)]$∆ ← max(∆,|v-V(s)|) until ∆&lt;$\theta$输出 $\pi = argmax_a\sum_{s’,r}p(s’,r|s,a)[r+\gamma V(s’)]$ 从算法中可以看到，其与策略评估不同之处在于：算法仅执行一遍价值评估，通过遍历行为空间，选取最大的状态价值赋值。 下面我们从实际的赌徒问题中评估价值迭代算法。 赌徒问题问题背景赌徒连续抛硬币，正面朝上获得赌资，反面朝上失去赌资，直到赢到100或输完。该问题可以视为一个无折扣的有限MDP问题： 状态空间：赌徒的赌资：{1、2、3…99}行为：下注金额：{1、2、3…min{s,100-s}} (下注金额最多不会超过距离获胜的差距)收益：赢到100：+1，其余：0状态价值：状态s下获胜的概率。策略：当前持有赌资的下注金额。 超参数根据问题背景，超参数设定如下：12345678# 赢钱目标GOAL = 100# 这里包括了0和100，仅仅是为了方便作图STATES = np.arange(GOAL + 1)# 硬币正面朝上的概率HEAD_PROB = 0.4 价值更新第一部分对算法的描述中说到：价值迭代算法只对状态进行一次价值更新，随即阻断。在该问题中，参考价值迭代算法，价值更新的代码如下：1234567891011121314151617181920212223242526272829# state value即状态价值：记录状态s下获胜的概率。state_value = np.zeros(GOAL + 1)# goal状态下的获胜概率必然为1.0state_value[GOAL] = 1.0sweeps_history = []while True: old_state_value = state_value.copy() sweeps_history.append(old_state_value) # 对每一个 s ∈ S循环： for state in STATES[1:GOAL]: # 当前状态的行为空间上界不会超过：持有赌资/距离获胜所需金额 actions = np.arange(min(state, GOAL - state) + 1) # 遍历行为空间，目的是找出max_a action_returns = [] for action in actions: # p:HEAD_PROB、(1 - HEAD_PROB) # r：0 # V'(s)：后继状态价值state_value[state +(赢)\-（输） action] action_returns.append( HEAD_PROB * state_value[state + action] + (1 - HEAD_PROB) * state_value[state - action]) # 找出所有行为a下的max—value new_value = np.max(action_returns) state_value[state] = new_value delta = abs(state_value - old_state_value).max() # 价值收敛 if delta &lt; 1e-9: sweeps_history.append(state_value) break 与策略迭代中的价值评估做一个对比： 策略迭代中，价值评估仅关注在当前状态S下执行一个确定动作后产生的状态S’，进而遍历S’产生状态价值之和决定V(S)。 价值迭代中，价值评估关注在当前状态S下，执行全部动作空间后产生的状态价值列表L(S’)，进而取L(S’)中的最大值来决定V(S)。 从而使价值迭代实现了一次执行，直接阻断的效益。 计算策略赌徒背景下的策略为赌资到下注金额的映射。 最优策略$\pi = argmax_a\sum_{s’,r}p(s’,r|s,a)[r+\gamma V(s’)]$仔细观察，其与上面的价值迭代过程$V(s) \leftarrow max_a\sum_{s’,r}p(s’,r|s,a)[r+\gamma V(s’)]$的唯一不同在于$argmax_a$，所以代码结构相同，最后取下标即可。 实现代码如下：1234567891011# compute the optimal policypolicy = np.zeros(GOAL + 1)for state in STATES[1:GOAL]: actions = np.arange(min(state, GOAL - state) + 1) action_returns = [] for action in actions: action_returns.append( HEAD_PROB * state_value[state + action] + (1 - HEAD_PROB) * state_value[state - action]) # action_returns从1开始（0代表输光），np.round保留5位小数 # 取action_returns最大值的下标 policy[state] = actions[np.argmax(np.round(action_returns[1:], 5)) + 1] 结果结果如图所示： 参考文献[1] https://github.com/ShangtongZhang/reinforcement-learning-an-introduction]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强化学习：DP优化之策略迭代]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9ADP%E4%BC%98%E5%8C%96%E4%B9%8B%E7%AD%96%E7%95%A5%E8%BF%AD%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[这片博客我们以例4.2的杰克租车问题为例来讲述策略迭代算法。 策略迭代策略迭代=评估+改进。在DP的背景下，策略迭代算法的描述如下： 初始化初始化状态价值以及策略（行为）对$s \in S$，任意初始化$V(s) \in R、π(s) \in A(s)$ 策略评估所谓策略评估，即：在现有的策略$\pi$下，估计每个状态的状态价值$V(s)$ 评估算法：循环：对每个状态s使用如下方法进行评估：$$V(s) \leftarrow \sum_{s’,r}p(s’,r|s,π(s))[r+γV(s’)]$$评估收敛的依据如下，其中$\theta$为决定估计精度的收敛基准数$$|V(s)_{old}-V(s)|&lt;\theta$$ 策略改进所谓策略改进，即：通过现有的状态价值$V(s)$，改进策略行为$\pi(s)$ 改进算法：policyStable $\leftarrow$ true #判断策略是否稳定（收敛）循环：对每个状态s使用如下方法进行评估：即在状态s下选出能使累计收益最大的动作a作为新的策略$$\pi(s) \leftarrow argmax_a \sum_{s’,r}p(s’,r|s,π(s))[r+γV(s’)]\\if \; \pi_{old} \neq \pi(s): policyStable \leftarrow false$$评估收敛的依据如下:$$if \; policyStable = true ：返回\pi \approx \pi_*$$若未收敛，则重新返回策略评估。 至此，基于DP的策略迭代算法的主要框架皆已讲述完毕，下面我们将其应用到实际问题中。 问题背景问题背景为an introduction一书的例4.2，杰克租车问题。梗概：杰克有两个租车场： 状态空间：两个场持有的车的数量动作：将一部分车从A（或B）场移动到B（或A）场收益：每租出一辆车+10，每移动一辆车-2其中每个场的租车/还车请求符合泊松分布 问题建模超参数原始问题带有很多限制，所以首先进行超参数设定。使用到的超参数如下：123456789101112131415161718192021222324252627282930# 每个场的车容量MAX_CARS = 20# 每晚最多移动的车数MAX_MOVE_OF_CARS = 5# A场租车请求的平均值RENTAL_REQUEST_FIRST_LOC = 3# B场租车请求的平均值RENTAL_REQUEST_SECOND_LOC = 4# A场还车请求的平均值RETURNS_FIRST_LOC = 3# B场还车请求的平均值RETURNS_SECOND_LOC = 2# 收益折扣DISCOUNT = 0.9# 租车收益RENTAL_CREDIT = 10# 移车支出MOVE_CAR_COST = 2# （移动车辆）动作空间：【-5，5】actions = np.arange(-MAX_MOVE_OF_CARS, MAX_MOVE_OF_CARS + 1)# 租车还车的数量满足一个poisson分布，限制由泊松分布产生的请求数大于POISSON_UPPER_BOUND时其概率压缩至0POISSON_UPPER_BOUND = 11# 存储每个（n,lamda）对应的泊松概率poisson_cache = dict() 泊松分布泊松分布的概率式为：$$P(X = n) = \frac{\lambda^n}{n!}e^{-\lambda}$$其可由scipy.stats库中的poisson模块产生，为了避免重复调用，我们使用一个字典来记录每个状态下的概率值：1234567def poisson_probability(n, lam): global poisson_cache key = n * 10 + lam if key not in poisson_cache: # 计算泊松概率 poisson_cache[key] = poisson.pmf(n, lam) return poisson_cache[key] 计算状态价值计算状态价值的函数代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667def expected_return(state, action, state_value, constant_returned_cars): """ @state: 状态定义为每个地点的车辆数 @action: 车辆的移动数量【-5，5】，负：2-&gt;1，正：1-&gt;2 @stateValue: 状态价值矩阵 @constant_returned_cars: 将还车的数目设定为泊松均值，替换泊松概率分布 """ # initailize total return returns = 0.0 # 移动车辆产生负收益 returns -= MOVE_CAR_COST * abs(action) # 移动后的车辆总数不能超过20 NUM_OF_CARS_FIRST_LOC = min(state[0] - action, MAX_CARS) NUM_OF_CARS_SECOND_LOC = min(state[1] + action, MAX_CARS) # 遍历两地全部的可能概率下（&lt;11）租车请求数目 for rental_request_first_loc in range(POISSON_UPPER_BOUND): for rental_request_second_loc in range(POISSON_UPPER_BOUND): # prob为两地租车请求的联合概率 # 即：1地请求租车rental_request_first_loc量且2地请求租车rental_request_second_loc量 prob = poisson_probability(rental_request_first_loc, RENTAL_REQUEST_FIRST_LOC) * \ poisson_probability(rental_request_second_loc, RENTAL_REQUEST_SECOND_LOC) # 两地原本的车的数量 num_of_cars_first_loc = NUM_OF_CARS_FIRST_LOC num_of_cars_second_loc = NUM_OF_CARS_SECOND_LOC # 有效的租车数目必须小于等于该地原有的车辆数目 valid_rental_first_loc = min(num_of_cars_first_loc, rental_request_first_loc) valid_rental_second_loc = min(num_of_cars_second_loc, rental_request_second_loc) # 计算回报，更新两地车辆数目变动 reward = (valid_rental_first_loc + valid_rental_second_loc) * RENTAL_CREDIT num_of_cars_first_loc -= valid_rental_first_loc num_of_cars_second_loc -= valid_rental_second_loc # 如果还车数目为泊松分布的均值 if constant_returned_cars: # 两地的还车数目均为泊松分布均值 returned_cars_first_loc = RETURNS_FIRST_LOC returned_cars_second_loc = RETURNS_SECOND_LOC # 还车后总数不能超过车场容量 num_of_cars_first_loc = min(num_of_cars_first_loc + returned_cars_first_loc, MAX_CARS) num_of_cars_second_loc = min(num_of_cars_second_loc + returned_cars_second_loc, MAX_CARS) # 核心： # 策略评估：V(s) = p(s',r|s,π(s))[r + γV(s')] returns += prob * (reward + DISCOUNT * state_value[num_of_cars_first_loc, num_of_cars_second_loc]) # 否则计算所有泊松概率分布下的还车空间 else: for returned_cars_first_loc in range(POISSON_UPPER_BOUND): for returned_cars_second_loc in range(POISSON_UPPER_BOUND): prob_return = poisson_probability( returned_cars_first_loc, RETURNS_FIRST_LOC) * poisson_probability(returned_cars_second_loc, RETURNS_SECOND_LOC) num_of_cars_first_loc_ = min(num_of_cars_first_loc + returned_cars_first_loc, MAX_CARS) num_of_cars_second_loc_ = min(num_of_cars_second_loc + returned_cars_second_loc, MAX_CARS) # 联合概率为【还车概率】*【租车概率】 prob_ = prob_return * prob returns += prob_ * (reward + DISCOUNT * state_value[num_of_cars_first_loc_, num_of_cars_second_loc_]) return returns 总而言之，由于状态空间的决定涉及到【租车】+【还车】两个行为，所以需要在遍历满足泊松分布租车请求的基础上继续遍历满足泊松分布的还车请求来实现对状态价值的评估，算法复杂度可达$O(n^4)$！ 策略评估在能计算出状态价值之后，进行策略评估便不是什么困难的事情，参考第一部分中的算法，策略评估的实现如下：123456789101112131415# 策略评估（in-place）# 未改进前，第一轮policy全为0，即【0，0，0...】while True: old_value = value.copy() for i in range(MAX_CARS + 1): for j in range(MAX_CARS + 1): # 更新V（s） new_state_value = expected_return([i, j], policy[i, j], value, constant_returned_cars) # in-place value[i, j] = new_state_value # 比较V_old(s)、V(s) max_value_change = abs(old_value - value).max() # 收敛 if max_value_change &lt; 1e-4: break 策略改进在上一部分可以看到，策略policy全都是0，如不进行策略改进，其必然不会收敛到实际最优策略。改进部分的代码如下：12345678910111213141516171819202122# 策略改进 policy_stable = True # i、j分别为两地现有车辆总数 for i in range(MAX_CARS + 1): for j in range(MAX_CARS + 1): old_action = policy[i, j] action_returns = [] # actions为全部的动作空间，即【-5、-4...4、5】 for action in actions: if (0 &lt;= action &lt;= i) or (-j &lt;= action &lt;= 0): action_returns.append(expected_return([i, j], action, value, constant_returned_cars)) else: action_returns.append(-np.inf) # 找出产生最大动作价值的动作 new_action = actions[np.argmax(action_returns)] # 更新策略 policy[i, j] = new_action if policy_stable and old_action != new_action: policy_stable = False # 策略收敛 if policy_stable: break 结果结果如图：正数代表从1场移动到2场，负数代表从1场移动到2场。 代码在运行完5轮后达到收敛，即policy4可视为收敛策略。由于1场的租车和还车请求均为3，而2场的租车请求为4、还车请求为2，所以更偏向于从1场向2场移动车。 参考文献[1] https://github.com/ShangtongZhang/reinforcement-learning-an-introduction]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强化学习：DP优化之in-place更新]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9ADP%E4%BC%98%E5%8C%96%E4%B9%8Bin-place%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[这里讲述一下DP（动态规划）优化中的in-place（就地）更新。 首先先介绍一下DP 动态规划在算法设计中经常接触到DP这一思想，其属于一类优化方法，在给定一个用马尔可夫决策过程（MDP）描述的完备环境模型的情况下，可以计算最优的策略。在强化学习中，DP的核心思想是使用价值函数来结构化地组织对最优策略的搜索：$$v_*(s) = max_a E[R_{t+1} + γv_*(S_{t+1}) | S_t=s, A_t=a]\\q_*(s,a) = E[R_{t+1} + γmax_{a’} q_*(S_{t+1},a’) | S_t=s, A_t=a]$$ 通过将贝尔曼方程转化近似逼近理想价值函数的递归更新公式，就得到了DP算法。 策略评估策略评估的目的是在给定策略π下，计算其状态价值$v_π$，通常依照如下式子进行迭代策略评估，即迭代着计算状态价值：$$v_{k+1}(s) = E_π[R_{t+1} + γv_k(S_{t+1}) | S_t=s]$$ 更新细节通常而言，在编程实现时可以考虑用两种方法来实现策略评估部分的需求，即： 使用两个数组： 一个用于存储旧的价值函数vk(s)一个用于存储新的价值函数vk+1(s) 也可以采用一个数组进行in place就地更新：每次直接用新的价值函数替换掉旧的价值函数。 如果使用就地更新，vk+1的在更新时，式子右侧有时会使用到vk的新的价值函数（各状态更新的先后顺序可能不同），而不是旧的价值。而事实上，这种就地更新的方法依然能够收敛到实际状态价值$v_π$，而由于每次获得了新数据就能够马上使用，反而比双数组的传统更新算法要更快。 结果比对我们再次以MDP章节提到的格子世界为例做一次对比。使用双数组进行状态价值更新的代码如下：123456789101112131415161718192021new_state_values = np.zeros((WORLD_SIZE, WORLD_SIZE))iteration = 0while True: # 双数组 state_values = new_state_values.copy() # 旧状态价值数组由新状态拷贝构造 old_state_values = state_values.copy() for i in range(WORLD_SIZE): for j in range(WORLD_SIZE): value = 0 for action in ACTIONS: (next_i, next_j), reward = step([i, j], action) value += ACTION_PROB * (reward + discount * state_values[next_i, next_j]) new_state_values[i, j] = value max_delta_value = abs(old_state_values - new_state_values).max() if max_delta_value &lt; 1e-4: break iteration += 1 使用in place进行状态价值更新的代码如下：123456789101112131415161718new_state_values = np.zeros((WORLD_SIZE, WORLD_SIZE))iteration = 0while True: # 只用一个数组进行就地更新 state_values = new_state_values for i in range(WORLD_SIZE): for j in range(WORLD_SIZE): value = 0 for action in ACTIONS: (next_i, next_j), reward = step([i, j], action) value += ACTION_PROB * (reward + discount * state_values[next_i, next_j]) new_state_values[i, j] = value max_delta_value = abs(old_state_values - new_state_values).max() if max_delta_value &lt; 1e-4: break iteration += 1 代码的运行结果如下：实验结果表明，执行in place能够提升35%左右的迭代效率。 参考文献[1] https://github.com/ShangtongZhang/reinforcement-learning-an-introduction]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强化学习：k臂赌博机]]></title>
    <url>%2F2019%2F11%2F22%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9Ak%E8%87%82%E8%B5%8C%E5%8D%9A%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[这一节我们介绍k臂赌博机问题，首先来熟悉一下问题的背景知识 问题背景重复的在k个选项或动作（k个老虎机的杆）中进行选择，每次做出选择之后都会得到一定数额的收益，我们的目的是在一段时间内最大化总收益的期望。 bandit建模在用代码实现赌博机时，我们需要考虑多方因素，下面先列出一个bandit初始化时需要考虑到的各种参数：1234567891011121314def __init__(self, k_arm=10, epsilon=0., initial=0., step_size=0.1, sample_averages=False, UCB_param=None, gradient=False, gradient_baseline=False, true_reward=0.): self.k = k_arm self.step_size = step_size self.sample_averages = sample_averages self.indices = np.arange(self.k) self.time = 0 self.UCB_param = UCB_param self.gradient = gradient self.gradient_baseline = gradient_baseline self.average_reward = 0 self.true_reward = true_reward self.epsilon = epsilon self.initial = initial k_arm：赌博机的臂数，其决定了可选动作空间的大小，例如当k_arm=10时意味着：每个时刻有10个可选动作，其分别决定着不同的收益。 epsilon：在每次进行动作选取时，一个朴素的思想就是每次都选带来最大收益的动作，即$A_t = agrmax_aQ_t(a)$，我们称之为“贪心”，贪心有利于exploit但不利于explore，为了平衡开发和试探，可采用ε-greedy方法进行动作的选择，即在每个时刻，使用1-ε的概率选取最优动作，使用ε的概率选取随机动作。 initial：在对动作价值估计之前，我们通常为每个动作的价值Q(a)初始化为0。使用乐观初始值(即高于真实价值的均值)估计会去鼓励bandit进行explore，因为无论哪种动作被选取，其带来的收益均要小于乐观初始值，因此bandit会转而采取另一种动作，从而使每一个动作在收敛之前都被尝试很多次。 step_size：步长参数，有固定步长和非固定步长两种类别可选。用于动作估计值的更新：$Q_{n+1} = Q_n + stepsize*(R_n - Q_n)$ sample_averages：用非固定步长$1/n$作为步长参数$stepsize$，用于动作估计值的更新：$Q_{n+1} = Q_n + (R_n - Q_n)/n$ UCB_param：UCB即对应置信度上界，即动作的选取从$A_t = agrmax_aQ_t(a)$改变为$A_t = agrmax_a[Q_t(a)+c\sqrt{lnt/N_t(a)}]$，其中UCB_param即动作选取公式中的c，可解释为：平方根项是对a动作值估计的不确定性或方差的度量，参数c决定了置信水平，但随着a选取次数$N_t(a)$的增多，其不确定性会逐渐减少。 gradient：对应梯度赌博机算法，算法中每个动作被选取的概率为softmax分布所确定：$P(A_t=a) = e^{H_t(a)}/\sum_{b=1}^{k}e^{H_t(b)} = π_t(a)$，其中$π_t(a)$代表时刻t动作a被选择的概率，而$H_t(a)$则代表动作a的偏好函数。 gradient_baseline：在梯度赌博机算法中，待学习的变量为偏好函数$H_t(a)$，可以把其理解为动作a的收益，但其本身不重要，重要的是一个动作对另一个动作的相对偏好。偏好函数的更新如下：$$H_{t+1}(a) = H_t(a) + stepsize*(R_t - baseline)(1-π_t(A_t))$$当使用baseline时，baseline被赋值为到t为止的平均收益；不使用时则等于0。使用基准项可以实现缩减方差的作用，使算法快速收敛。 动作选取对于一个MDP问题而言，其过程必定可以被建模为：$$S_t + A_t \rightarrow S_{t+1} + R_{t+1}$$所以首先来考虑动作的选取。 由bandit的模型基础可知，动作的选取由ε-greedy、UCB_param、gradient决定，我们可以直接给出如下的动作选取代码：1234567891011121314151617181920212223# get an action for this bandit def act(self): if np.random.rand() &lt; self.epsilon: return np.random.choice(self.indices) # epsilon概率随机选取一个动作下标 # 基于置信度上界的动作选取 # At = agrmax_a [Qt(a)+c√(lnt/Nt(a))] if self.UCB_param is not None: UCB_estimation = self.q_estimation + \ self.UCB_param * np.sqrt(np.log(self.time + 1) / (self.action_count + 1e-5)) q_best = np.max(UCB_estimation) # 取UCB估值序列的最大值 return np.random.choice(np.where(UCB_estimation == q_best)[0]) #在相同的最大值中随机选取 # 梯度赌博机算法 # P&#123;At=a&#125; = e^Ht(a) / ∑_b e^Ht(b) = πt(a) if self.gradient: exp_est = np.exp(self.q_estimation) self.action_prob = exp_est / np.sum(exp_est) return np.random.choice(self.indices, p=self.action_prob) # 以概率表action_prob的概率在下标列表indices中选取 # 否则就直接选去估计值最大的动作 q_best = np.max(self.q_estimation) return np.random.choice(np.where(self.q_estimation == q_best)[0]) 价值更新由bandit建模部分可以得知，在选取完动作后，与动作价值更新有关的参数为sample_averages、gradient、gradient_baseline，给出代码如下：1234567891011121314151617181920212223242526272829# take an action, update estimation for this action def step(self, action): # generate the reward under N(real reward, 1) reward = np.random.randn() + self.q_true[action] self.time += 1 self.action_count[action] += 1 self.average_reward += (reward - self.average_reward) / self.time if self.sample_averages: # update estimation using sample averages # 增量式实现（非固定步长1/n） # Qn+1 = Qn + [Rn-Qn]/n self.q_estimation[action] += (reward - self.q_estimation[action]) / self.action_count[action] elif self.gradient: one_hot = np.zeros(self.k) one_hot[action] = 1 if self.gradient_baseline: baseline = self.average_reward else: baseline = 0 # 梯度式偏好函数更新： # 对action At：Ht+1(At) = Ht(At) + å(Rt-R_avg)(1-π(At)) self.q_estimation += self.step_size * (reward - baseline) * (one_hot - self.action_prob) else: # update estimation with constant step size # 如过上面两种方法都没有选取，就选用常数步长更新 # Qn+1 = Qn + å(Rn-Qn) self.q_estimation[action] += self.step_size * (reward - self.q_estimation[action]) return reward 对比评估评估结果与an introduction书中所示类似，这里只给出一些结果：测试四种方法的结果对比，可以看到，最优的结果出现在使用小步长+baseline时的情况。 参考文献[1]https://github.com/ShangtongZhang/reinforcement-learning-an-introduction]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强化学习：有限马尔科夫决策过程]]></title>
    <url>%2F2019%2F11%2F21%2F%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%89%E9%99%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在有限马尔科夫决策这一部分，我们通过一个网格问题来理解分幕式问题的建模和求解过程。 网格问题示例给出的长方形网格代表一个简单的有限MDP:状态：网格中的格子代表一个状态动作：在每个格子中都有{东、南、西、北}四个可选动作收益：当agent执行动作后脱离了网格，其收益-1；当处在状态A或B时，执行任何动作都会转移至状态A’或B’，其收益分别为+10、+5；其余所有状态收益+0。 表格中‘φ’为空白 A B φ φ B’ φ φ A’ φ 我们的目的是计算出在每个网格中的状态价值，限定折扣系数：γ=0.9 超参数设计在编写agent行为之前需要先设置一些全局变量，此处的全局变量共包括如下： 12345678910111213141516# A、B、A‘、B’位置坐标WORLD_SIZE = 5A_POS = [0, 1]A_PRIME_POS = [4, 1]B_POS = [0, 3]B_PRIME_POS = [2, 3]# 折扣系数DISCOUNT = 0.9# 动作空间：东、南、西、北ACTIONS = [np.array([0, -1]), np.array([-1, 0]), np.array([0, 1]), np.array([1, 0])]# 每个状态下动作执行等概率的动作选取ACTION_PROB = 0.25 状态转换网格问题的状态转换，即下述MDP：$$S_t + A_t → S_{t+1}, R_{t+1}$$ 我们用代码来实现：1234567891011121314def step(state, action): if state == A_POS: # A点会无条件转移到A'，并且收益+10 return A_PRIME_POS, 10 if state == B_POS: # B点会无条件转移到B'，并且收益+5 return B_PRIME_POS, 5 next_state = (np.array(state) + action).tolist() x, y = next_state if x &lt; 0 or x &gt;= WORLD_SIZE or y &lt; 0 or y &gt;= WORLD_SIZE: reward = -1.0 # 出界收益-1 next_state = state # 出界状态不变 else: reward = 0 # 其余收益+0 return next_state, reward 等概率下的状态价值为了求解每个状态的状态价值，我们假定每个状态下选取东、南、西、北四个动作的概率相等，均为0.25。邻接时刻的回报可以用递归的方式来表示：$$G_t = R_{t+1} + γR_{t+2} + γ^2R_{t+3} + … = R_{t+1} + γG_{t+1}$$其在代码中通过new_value[i, j] += ACTION_PROB * (reward + DISCOUNT * value[next_i, next_j])来实现 我们用代码实现如下：1234567891011121314151617181920212223value = np.zeros((WORLD_SIZE, WORLD_SIZE)) # 训练至收敛 while True: # keep iteration until convergence new_value = np.zeros_like(value) for i in range(WORLD_SIZE): for j in range(WORLD_SIZE): # 在每一格都执行东南西北走位,遍历该状态下的动作空间 for action in ACTIONS: (next_i, next_j), reward = step([i, j], action) # bellman equation # 价值更新: Gt = Rt+1 + γGt+1 # t：即（i，j）所在位置，t+1：即（next_i, next_j）所在位置 # ACTION_PROB=0.25，即四个方向对价值更新的贡献相同 new_value[i, j] += ACTION_PROB * (reward + DISCOUNT * value[next_i, next_j]) # 收敛：sum新价值-sum旧价值变化 &lt; 1e-4 if np.sum(np.abs(value - new_value)) &lt; 1e-4: draw_image(np.round(new_value, decimals=2)) plt.savefig('../images/figure_3_2.png') plt.close() break # value记录上一轮价值 value = new_value 执行结果如下，可以看到，如果在网格中的每个状态中执行等概率的动作选取，其状态价值如下： 最优动作下的状态价值上面展示了，在每个状态下动等概率选取动作的状态价值结果。下面我们假定在每个状态下执行最优动作$A^*$，重新计算每个状态下的状态价值。 同样，邻接时刻的回报可以用递归的方式来表示：$$G_t = R_{t+1} + γR_{t+2} + γ^2R_{t+3} + … = R_{t+1} + γG_{t+1}$$但这里我们选取最优价值$q^*$所对应的动作$A^*$，替换掉0.25的等概率动作选取。 代码实现如下：123456789101112131415161718while True: # keep iteration until convergence new_value = np.zeros_like(value) for i in range(WORLD_SIZE): for j in range(WORLD_SIZE): values = [] for action in ACTIONS: (next_i, next_j), reward = step([i, j], action) # value iteration values.append(reward + DISCOUNT * value[next_i, next_j]) # 不使用等概率的（东南西北）动作选择，直接使用最优的动作 new_value[i, j] = np.max(values) if np.sum(np.abs(new_value - value)) &lt; 1e-4: draw_image(np.round(new_value, decimals=2)) plt.savefig('../images/figure_3_5.png') plt.close() break value = new_value 与上一节不同的是：在遍历动作空间ACTION时，变量values负责记录每个动作所产生的回报，而只有最大回报np.max(values)对应的最优动作会对价值更新产生贡献，即new_value[i, j] = np.max(values)。 执行结果如下，可以看到，如果在网格中的每个状态中执行最优的动作选取，其状态价值如下，相比等概率选取，执行最优极大的提高了每个状态下的状态价值： 参考文献[1] https://github.com/ShangtongZhang/reinforcement-learning-an-introduction]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[保研经验]]></title>
    <url>%2F2019%2F07%2F16%2F%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[从期末考完开始，到现在为止，折腾了半个多月，总算是拿到了计算所网数实验室的offer，这里来总结一下这其中碰到了种种问题。 总而言之，问题主要包括：机试、数学和项目，三个大主题，首先来谈一下最简单粗暴的数学。 与数学有关的主要包括： 微积分 线性代数 概率论 而与数学有关的东西大都是在大一所学，如果没有针对性的复习，几乎无法应对面试的提问，但短时间内复习完高等数学的三大块内容也不现实，所以这里事后诸葛亮一下，总结自己遇到和可能遇到的一些问题。 线性代数矩阵的秩的含义被问到这个问题的时候脑子里一片空白，其实自己只是会计算矩阵的秩，但并不明白其具体含义是什么 矩阵的秩的定义：是其行向量或列向量的极大无关组中包含向量的个数。 那么就可以问下一个问题！（事实上老师也的确是这么做的） 线性无关的意义 $K_n$中如果有向量组$α1,α2,…αs(s≥1)$是线性无关的,那么从式子$k_1α_1+k_2α_2+…k_sα_s=0$中可以得到$k_1=k_2=…=0$ 从这个定义也可以推导出线性相关的条件，即：$k_1、k_2…$不全为0 所以从个人理解上去解释线性无关，即矩阵内的行（或列）向量无法通过线性运算的方法互相消除。 其实在面试现场的线性代数有关的问题就只遇到了这两个，因为自己实在是只会算但并不理解其意义，所以回答的情况并不理想。 下面再补充一些可能会遇到的问题。 矩阵的特征值/特征向量的意义从定义出发，特征值和特征向量的定义如下： $Ax=cx$：A为矩阵，c为特征值，x为特征向量 其意义为： 矩阵A乘以x表示:对向量x进行一次转换（旋转或拉伸）（是一种线性转换），该转换的效果为常数c乘以向量x（即只进行拉伸）。 这样做的目的通常如下： 我们通常求特征值和特征向量即为求出该矩阵能使哪些向量（当然是特征向量）只发生拉伸，使其发生拉伸的程度如何（特征值大小）。这样做的意义在于，看清一个矩阵在那些方面能产生最大的效果（power），并根据所产生的每个特征向量（一般研究特征值最大的那几个）进行分类讨论与研究。 概率论概率总是和AI、数据科学贴的非常近，所以面试对于概率论的考核也是一个比较重要的内容，下面罗列一下在面试中遇到的问题。 大数定律是什么通俗的说，大数定律就是：在试验不变的条件下，重复试验多次，随机事件的频率近似于它的概率。即用频率代替概率，用样本均值来取代理论均值。 什么是先验概率/后验概率 先验概率：直观理解，所谓“先”，就是在事情之前，即在事情发生之前事情发生的概率，是根据以往经验和分析得到的概率。即通过训练集样本所得的概率。 后验概率：事情已经发生了，事情发生可能有很多原因，判断事情发生时由哪个原因引起的概率。 后验概率涉及到一个重要的计算公式，即贝叶斯公式。$$P(A|B) = P(B|A)·P(A) / P(B|A)·P(A)+P(B|C)·P(C)$$在B已经发生的情况下，A发生的概率即为P(B|A)，此即后验概率。]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统——文件系统]]></title>
    <url>%2F2019%2F06%2F13%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[实验简介本实验要求在模拟的I/O系统之上开发一个简单的文件系统。用户通过create, open, read等命令与文件系统交互。文件系统把磁盘视为顺序编号的逻辑块序列，逻辑块的编号为0至L − 1。I/O系统利用内存中的数组模拟磁盘。 整体设计根据题设要求，文件系统的整体设计框架如下： I/O系统设计要求实际物理磁盘的结构是多维的：有柱面、磁头、扇区等概念。I/O系统的任务是隐藏磁盘的结构细节，把磁盘以逻辑块的面目呈现给文件系统。逻辑块顺序编号，编号取值范围为0至L−1，其中L表示磁盘的存储块总数。实验中，我们可以利用数组ldisk[C][H][B]构建磁盘模型，其中CHB 分别表示柱面号，磁头号和扇区号。每个扇区大小为512字节。I/O系统从文件系统接收命令，根据命令指定的逻辑块号把磁盘块的内容读入命令指定的内存区域，或者把命令指定的内存区域内容写入磁盘块。 数据结构本实验需要用数组来模拟实际磁盘的三维结构，为了方便表述对扇区内存储内容的描述，我们使用如下结构体：1234567typedef struct ldisk&#123; int C; //柱面号 int H; //磁头号 int B; //扇区号 char content[SIZE + 1]; //扇区中的内容&#125;LDISK; 功能接口read_block函数原型1read_block(int i, char *p) 实现的功能：把逻辑块i的内容读入到指针p指向的内存位置，拷贝的字符个数为存储块的长度B。核心思想：根据传入的逻辑块i计算出其对应的磁盘三维坐标数据，计算过程如注释所述。其中sectorsPerTrack代表每个磁道上的扇区数目。12345678910111213int read_block(int i, char *p)&#123; int y = i / sectorsPerTrack; //扇区号 disk[i].B = i % sectorsPerTrack + 1; //柱面号 disk[i].C = y &gt;&gt; 1; //磁头号 disk[i].H = y &amp; 1; //读入p strcpy(p, disk[i].content); return 0;&#125; write_block函数原型1int write_block(int i, char *p) 实现的功能：把指针p指向的内容写入逻辑块i，拷贝的字符个数为存储块的长度B。实现思路同上，核心思想也是解决坐标的变换。代码如下：12345678910111213int write_block(int i, char *p)&#123; int y = i / sectorsPerTrack; //扇区号 disk[i].B = i % sectorsPerTrack + 1; //柱面号 disk[i].C = y &gt;&gt; 1; //磁头号 disk[i].H = y &amp; 1; //写入 strcpy(disk[i].content, p); return 0;&#125; 文件系统设计要求文件系统的总体设计共有如下要求： 文件系统位于I/O系统之上； 文件系统需提供如下函数：create, destroy, open, read, write； 磁盘的前k个块是保留区，其中包含如下信息：位图和文件描述符； 文件系统中仅设置一个目录，该目录包含文件系统中的所有文件； 创建文件/删除文件； 文件打开：在打开文件表中为其分配一个表目； 文件关闭：其对应的表目被释放； 文件读写：计算读写指针对应的位置在读写缓冲区中的偏移、把缓冲区中的内容拷贝到指定的内存位置。 文件系统的组织磁盘的前k个块是保留区，其中包含如下信息：位图和文件描述符。位图用来描述磁盘块的分配情况。位图中的每一位对应一个逻辑块。创建或者删除文件，以及文件的长度发生变化时，文件系统都需要进行位图操作。前k个块的剩余部分包含一组文件描述符。每个文件描述符包含如下信息：• 文件长度，单位字节• 文件分配到的磁盘块号数组。该数组的长度是一个系统参数。在实验中我们可以把它设置为一个比较小的数，例如3。 为了辅助实现用户与文件系统之间的接口函数，需要定义文件类型变量的结构体，根据上述需求，结构体中需要包含如下的的成员变量：123456789typedef struct files&#123; int number; //文件编号 char *filename; //文件名 int size; //文件大小 int pos; //文件偏移指针 INDIRECT *addr[3]; //3个直接地址 char *content; //存放文件中的所有内容&#125;FILES; 用户与文件系统之间的接口根据题目要求，该处的主要工作为上述五个接口函数的实现。 create函数原型1int create(char *filename) 实现的功能：根据指定的文件名创建新文件。 实现思想：首先根据传入文件名判断是否已存在同名文件，若存在则报错；若不存在则将其装入位图。实现代码如下，其中M为位图的行数、K为保留区的长度、L为总的逻辑扇区数目1234567891011121314151617181920212223242526272829303132333435363738int create(char *filename)&#123; DIC *dic = dicHead; int flag = 0; for(int i = 0; i &lt; countOfFiles; i ++) &#123; if(strcmp(dic-&gt;filename, filename) == 0) &#123; flag = 1; break; &#125; dic = dic-&gt;next; &#125; if(flag == 1) &#123; printf("FileExisted!\n"); return NULL; &#125; int a = M; int start = K; int size = L - K; countOfFiles ++; //生成随机数 int blockNumber = createRandomNUmber(start, size); //查询位图 while(map[blockNumber / a][blockNumber % a] == 1) blockNumber = createRandomNUmber(start, size); //置位图为1 map[blockNumber / a][blockNumber % a] = 1; //建立目录 createDirectory(filename, blockNumber); printf("创建%s成功\n", filename); return 0;&#125; delete函数原型1int delete(char *filename) 实现的功能：根据指定的文件名删除指定文件。 实现思想：首先根据传入文件名判断是否已存在同名文件，若不存在则报错；若存在则将其从块、目录中删除。实现代码如下，其中SIZE为扇区大小（字节数）123456789101112131415161718192021222324252627282930313233343536int destroy(char *filename)&#123; DIC *dic = dicHead; int flag = 0; for(int i = 0; i &lt; countOfFiles; i ++) &#123; if(strcmp(dic-&gt;filename, filename) == 0) &#123; flag = 1; break; &#125; dic = dic-&gt;next; &#125; if(flag == 0) &#123; printf("FileNotExist!\n"); return -1; &#125; //删除文件 int blockNumber = dic-&gt;index1-&gt;size / SIZE; if(dic-&gt;index1-&gt;size % SIZE &gt; 0) blockNumber ++; //删除所有块里的元素 for(int i = 0; i &lt; blockNumber; i ++) &#123; write_block(dic-&gt;index1-&gt;addr[i]-&gt;diskNum, "\0"); &#125; //删除目录 destoryDirectory(filename); countOfFiles --; return 0;&#125; open函数原型1FILES *open(char *filename) 实现的功能：根据指定的文件名打开文件，且该函数返回的索引号可用于后续的read, write, lseek,或close操作。 实现思想：首先根据传入文件名判断是否已存在同名文件，若不存在则报错；若存在则计算块号和块内偏移地址，并将其从磁盘中读至file。实现代码如下，其中SIZE为扇区大小（字节数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748FILES *open(char *filename)&#123; DIC *dic = dicHead; char buffer[512] = ""; //缓冲区 int flag = 0; for(int i = 0; i &lt; countOfFiles; i ++) &#123; if(strcmp(dic-&gt;filename, filename) == 0) &#123; flag = 1; break; &#125; dic = dic-&gt;next; &#125; if(flag == 0) &#123; printf("FileNotExist!\n"); return NULL; &#125; FILES *file = NULL; file = (FILES *)malloc(sizeof(FILES)); file-&gt;number = dic-&gt;index1-&gt;number; for(int i = 0; i &lt; 3; i ++) file-&gt;addr[i] = (INDIRECT *)malloc(sizeof(INDIRECT)); for(int i = 0; i &lt; 3; i ++) memcpy(file-&gt;addr[i], dic-&gt;index1-&gt;addr[i], sizeof(INDIRECT)); file-&gt;size = dic-&gt;index1-&gt;size; file-&gt;filename = (char *)malloc(strlen(filename) * sizeof(char)); memcpy(file-&gt;filename, filename, strlen(filename)); file-&gt;pos = 0; //将磁盘中的内容读到file中 int block = file-&gt;size / SIZE; int offset = file-&gt;size % SIZE; file-&gt;content = (char *)malloc(file-&gt;size * sizeof(char)); if(offset &gt; 0) block ++; for(int i = 0; i &lt; block; i ++) &#123; read_block(dic-&gt;index1-&gt;addr[i]-&gt;diskNum, buffer); strcpy(&amp;file-&gt;content[i * SIZE], buffer); &#125;// printf("打开成功\n"); return file;&#125; close函数原型1int close(FILES *file) 实现的功能：关闭指定文件。实现思想：将file指针指定的文件的文件名和文件内容释放。1234567891011121314151617181920212223int close(FILES *file)&#123; for(int i = 0; i &lt; 3; i ++) free(file-&gt;addr[i]); for(int i = 0; i &lt; 3; i ++) file-&gt;addr[i] = NULL; //释放文件名 if(file-&gt;filename != NULL) &#123; free(file-&gt;filename); file-&gt;filename = NULL; &#125; //释放文件内容 if(file-&gt;content != NULL) &#123; free(file-&gt;content); file-&gt;content = NULL; &#125; //释放file指针 free(file); printf("关闭成功\n"); return 0;&#125; read函数原型1FILES *read(FILES *file, char *mem_area, int count) 实现的功能：从指定文件顺序读入count个字节memArea指定的内存位置。读操作从文件的读写指针指示的位置开始。 实现思想：根据count指定的长度计算需要读的扇区数目a，然后依次从这a个扇区中将file-&gt;content所指向的数据依次读入缓冲区buffer，并拷贝至指定的内存连续区mem_area，最后修改读写文件指针file-&gt;pos向后移动count个位置即可。1234567891011121314151617FILES *read(FILES *file, char *mem_area, int count)&#123; char buffer[512] = ""; //缓冲区 if((count + file-&gt;pos) &gt; file-&gt;size) return NULL; //越界错误 int a = count / SIZE; for(int i = 0; i &lt; a; i ++) &#123; memcpy(buffer, &amp;file-&gt;content[file-&gt;pos + i * SIZE], SIZE * sizeof(char)); strcpy(&amp;mem_area[i * SIZE], buffer); &#125; memcpy(buffer, &amp;file-&gt;content[file-&gt;pos + a * SIZE], (count % SIZE) * sizeof(char)); strcpy(&amp;mem_area[a * SIZE], buffer); file-&gt;pos = file-&gt;pos + count; printf("读入成功\n"); return file;&#125; write函数原型1FILES *write (FILES *file, char *mem_area, int count) 实现的功能：把memarea指定的内存位置开始的count个字节顺序写入指定文件。写操作从文件的读写指针指示的位置开始。 实现思想：写入文件的逻辑较读操作来说更为复杂。首先需要根据文件指针找到文件所在的逻辑块并清空所对应磁盘中的内容；其次需要将位图的对应部分清空；最后还需要将现有目录中的对应内容（即diskNum、count）清空。准备工作完成后，下面进行写入动作。首先根据写入文件的数据大小count更新文件读写指针的位置为file-&gt;pos + count；其次为文件内容区域重新分配内存空间并把待写入的数据mem_area写入；最后将写入新数据的file写回磁盘和目录中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586FILES *write (FILES *file, char *mem_area, int count)&#123; DIC *dic = dicHead; char buffer[512] = ""; //缓冲区 if(file-&gt;pos + count &gt; file-&gt;size) return NULL; //越界 //清除原先磁盘扇区中的数据 int m = M; int blocknumber = file-&gt;size / SIZE; if((file-&gt;size % SIZE) &gt; 0) blocknumber ++; for(int i = 0; i &lt; blocknumber; i ++) strcpy(disk[file-&gt;addr[i]-&gt;diskNum].content, "\0"); for(int i = 1; i &lt; blocknumber; i ++) //改位图 map[file-&gt;addr[i]-&gt;diskNum / m][file-&gt;addr[i]-&gt;diskNum % m] = 0; //找到目录 for(int i = 0; i &lt; countOfFiles; i ++) &#123; if(dic-&gt;index1-&gt;number == file-&gt;number) break; dic = dic-&gt;next; &#125; //更改目录中的内容 for(int i = 1; i &lt; blocknumber; i ++) dic-&gt;index1-&gt;addr[i]-&gt;diskNum= 0; for(int i = 0; i &lt; 3; i ++) dic-&gt;index1-&gt;addr[i]-&gt;count = 0; for(int i = 1; i &lt; 3; i ++) dic-&gt;index1-&gt;addr[i]-&gt;diskNum = -1; //更改file指针中文件的内容 file-&gt;size = file-&gt;pos + count; //重新分配空间 char *s; s = (char *)malloc(strlen(file-&gt;content) *sizeof(char)); memcpy(s, file-&gt;content, strlen(file-&gt;content) *sizeof(char)); file-&gt;content = (char *)realloc(file-&gt;content, file-&gt;size * sizeof(char)); memcpy(file-&gt;content, s, sizeof(file-&gt;pos) *sizeof(char)); memcpy(&amp;file-&gt;content[file-&gt;pos], mem_area, count * sizeof(char)); //将file中的内容通过buffer写入磁盘 blocknumber = file-&gt;size / SIZE; if(file-&gt;size % SIZE &gt; 0) blocknumber ++; //生成随机的磁盘扇区块 int start = K; int size = L - K; for(int i = 1; i &lt; blocknumber; i ++) &#123; file-&gt;addr[i]-&gt;diskNum = createRandomNUmber(start, size); while(map[file-&gt;addr[i]-&gt;diskNum / m][file-&gt;addr[i]-&gt;diskNum % m] != 0) file-&gt;addr[i]-&gt;diskNum = createRandomNUmber(start, size); &#125; //从buffer中写入扇区 for(int i = 0; i &lt; blocknumber - 1; i ++) &#123; //存入缓冲区 memcpy(buffer, &amp;file-&gt;content[i * SIZE], (SIZE) * sizeof(char)); //缓冲区存入磁盘 write_block(file-&gt;addr[i]-&gt;diskNum, buffer); &#125; if(count % SIZE &gt; 0) &#123; strcpy(buffer, &amp;file-&gt;content[(blocknumber - 1) * SIZE]); write_block(file-&gt;addr[blocknumber - 1]-&gt;diskNum, buffer); &#125; else if(count % SIZE == 0) &#123; memcpy(buffer, &amp;file-&gt;content[(blocknumber - 1) * SIZE], SIZE * sizeof(char)); write_block(file-&gt;addr[blocknumber - 1]-&gt;diskNum, buffer); &#125; for(int i = 0; i &lt; blocknumber - 1; i ++) file-&gt;addr[i]-&gt;count = SIZE; if(file-&gt;size == SIZE) file-&gt;addr[blocknumber - 1]-&gt;count = file-&gt;size; else file-&gt;addr[blocknumber - 1]-&gt;count = file-&gt;size % SIZE; //写回目录 for(int i = 0; i &lt; 3; i ++) memcpy(dic-&gt;index1-&gt;addr[i], file-&gt;addr[i], sizeof(INDIRECT)); dic-&gt;index1-&gt;size = file-&gt;size; file-&gt;pos = file-&gt;size; printf("写入成功\n"); free(buffer); return file;&#125; lseek函数原型1FILES *lseek(FILES* file, int pos) 实现的功能：把文件的读写指针移动到pos指定的位置。pos是一个整数，表示从文件开始位置的偏移量。文件打开时，读写指针自动设置为0。每次读写操作之后，它指向最后被访问的字节的下一个位置。lseek能够在不进行读写操作的情况下改变读写指针能位置。 实现思想：直接对file指针对应的结构体变量pos操作即可。12345FILES *lseek(FILES* file, int pos)&#123; file-&gt;pos += pos; return file;&#125; 目录我们的文件系统中仅设置一个目录，该目录包含文件系统中的所有文件。除了不需要显示地创建和删除之外，目录在很多方面和普通文件相像。目录对应0号文件描述符。初始状态下，目录中没有文件，所有目录对应的描述符中记录的长度应为0，而且也没有分配磁盘块。每创建一个文件，目录文件的长度便增加。目录文件的内容由一系列的目录项组成，其中每个目录项由如下内容组成：• 文件名• 文件描述符序号 数据结构地址项12345typedef struct indirect&#123; int diskNum; //磁盘逻辑扇区号 int count; //使用过的长度&#125;INDIRECT; 文件标识符123456typedef struct index&#123; int number; //文件标识符号 int size; //大小 INDIRECT *addr[3]; //3个直接地址&#125;INDEX; 目录的存储结构目录结构体的存储结构如下：123456typedef struct directory1&#123; int number; //文件标识符号 int size; //大小 INDIRECT **addr; //目录所占的直接地址&#125;DIC1; 这里通过链表结构来显示目录中的所有文件及其长度：123456typedef struct directory&#123; char *filename; //文件名 INDEX *index1;//文件索引 struct directory *next; //使用循环链表储存目录信息&#125;DIC; 与目录相关的操作如下所述： 初始化目录初始化即为目录的相关成员分配各自的内存空间。1234567891011int initDic()&#123; printf("初始化目录-----"); dic1 = (DIC1 *)malloc(sizeof(DIC1)); dic1-&gt;number = 0; dic1-&gt;size = 0; dicHead = (DIC *) malloc(sizeof(DIC)); dicTail = (DIC *) malloc(sizeof(DIC)); printf("ok\n"); return 0;&#125; 创建目录123456789101112131415161718192021222324252627282930313233int createDirectory(char *filename, int blockNumber)&#123; int k = K; if(countOfFiles * sizeof(DIC) + sizeof(dic1) &gt; (k - blockOfMap) * SIZE) return -1; //目录越界 DIC *dic = NULL; dic = (DIC *) malloc(countOfFiles * sizeof(DIC)); dic-&gt;filename = (char *) malloc(strlen(filename) * sizeof(char)); strcpy(dic-&gt;filename, filename); dic-&gt;index1 = (INDEX *)malloc(sizeof(INDEX)); dic-&gt;index1-&gt;number = countOfFiles; dic-&gt;index1-&gt;size = 0; for(int i = 0; i &lt; 3; i ++) dic-&gt;index1-&gt;addr[i] = (INDIRECT *)malloc(sizeof(INDIRECT)); dic-&gt;index1-&gt;addr[0]-&gt;diskNum = blockNumber; dic-&gt;index1-&gt;addr[0]-&gt;count = 0; dic-&gt;next = (DIC *)malloc(sizeof(DIC)); //生成链表 if(countOfFiles == 1) &#123; memcpy(dicHead, dic, sizeof(DIC)); dicTail = dicHead; dicHead-&gt;next = dicTail; dicTail-&gt;next = dicHead; free(dic); &#125; else &#123; dicTail-&gt;next = dic; dic-&gt;next = dicHead; dicTail = dic; &#125; return 0;&#125; 删除目录12345678910111213141516171819202122232425262728293031323334int destoryDirectory(char *filename)&#123; DIC *dic = dicHead; DIC *dic2 = dicHead; int a = M; int i; //找到filename对应的目录 for(i = 0; i &lt; countOfFiles; i ++) &#123; if(strcmp(dic-&gt;filename, filename) == 0) break; dic2 = dic; dic = dic-&gt;next; &#125; //计算出文件占用了多少扇区 int x = dic-&gt;index1-&gt;size; int y = x / SIZE; if(x % SIZE &gt; 0) y ++; //释放所有扇区信息 for(int j = 0; j &lt; y; j ++) //修改位图 map[dic-&gt;index1-&gt;addr[j]-&gt;diskNum / a][dic-&gt;index1-&gt;addr[j]-&gt;diskNum % a] = 0; for(int i = 0; i &lt; 3; i ++) free(dic-&gt;index1-&gt;addr[i]); free(dic-&gt;index1); //释放文件名 free(dic-&gt;filename); //释放目录 dic2-&gt;next = dic-&gt;next; dicHead = dic2-&gt;next; free(dic); return 0;&#125; 测试在文件系统的基础功能都完成之后，编写外壳程序来将各个功能组织到一起，下面来对各个功能进行测试。首先通过终端编译生成可执行文件：创建文件：通过调用1号功能来新建三个测试文件test1、test2和test3显示文件：通过调用8号功能来显示目前已有的文件，可以观察到刚刚新建的三个文件的物理信息（文件名，文件标号，大小，所占磁盘块，所占大小）删除文件：通过调用2号功能来删除测试文件test3，再通过8号功能显示文件信息如下写文件：通过调用3号功能首先打开测试文件test1，再通过6号功能向文件中写入测试数据，最后通过8号功能显示文件信息如下读文件：通过5号功能从已打开的文件test1中读取10位测试数据，显示读取结果如下，可以看到成功把之前向文件中写入的测试字符串按指定长度读中并显示 至此，文件系统的基本功能：增删改查已全部实现！]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——编译器前端]]></title>
    <url>%2F2019%2F06%2F05%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[写在前面终于写完了最后一个必做实验，编译原理课程也几乎要告一段落了，在最后一次实验完成之际，我想简单陈述一下我个人对于这门课程的感悟和想法。 之前我常常疑惑，计科和别的专业的区别是什么，为什么小专业学我们学过的课，也学我们不学的课呢，这么看来计科怎么都好像是他们的一个“子集”。 到大三下，我发现了一个“不合群”的课程——编译原理。这是一个只有计科的才有植入的专业核心课，也是计科专业区别于其他专业的唯一标准。 于是责任心鞭策着我要认真对待这门课。争取课代表、每节课坐前排、手写作业认真完成、课程实验撰写博客、选做题积极响应等是我对这门课的态度。 课程涵盖了文法定义、词法分析、符号表处理、各式各样的语法分析、到最后的目标代码生成，从内而外的介绍了编程语言被编译识别的过程，也让我体会到了计算机程序语言被机器所识别的内涵和精髓，这种上下文无关语言的识别过程为我探索自然语言处理等上下文有关语言的研究铺垫了道路，不论是知识开荒还是兴趣培养，这门课对我来说受益匪浅。 最后引用一句实验指导书的片头语： 编译原理课程中蕴含着计算机科学中解决问题的思路、抽象问题和解决问题的方法，其内容可让计算机专业学生“享用一辈子”。 这门课的知识应该是一个计科专业的人贯穿自始至终的课程。 目标任务实验项目将词法分析程序设计原理与实现（专题1）和基于SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现（专题5）形成一个程序，即程序的输入为符号串源程序，输出为中间代码四元式序列。 设计要求（1）词法分析的输入为符号串，词法分析的输出为二元式形式的中间文件；（2）语法制导翻译读取二元式形式的中间文件并生成中间代码四元式形式的中间文件；（3）设计两个测试用例（尽可能完备），并给出程序执行结果。 实验1&amp;5封装由于我的实验一采用了C++所编写，所以首要解决的一个问题就是： 如何利用python调用C++程序？ 词法分析器输出重定向因为需要将词法分析器与SLR语法分析器链接成一个整体，所以需要首先修改词法分析器的输出中间文件，即通过一定方法令词法分析器实现输出重定向功能。 由于词法分析器的输出全部由函数out(int c,string tok)所控制，函数实现如下：1234567891011121314151617void out(int c,string tok)&#123; // 保留字只输出编码 if(tok == "reserved") cout&lt;&lt;c&lt;&lt;" "&lt;&lt;reserved.at(c)&lt;&lt;endl; //ID和int输出 else if(c==10||c==11)&#123; cout&lt;&lt;"i"&lt;&lt;" "&lt;&lt;tok&lt;&lt;endl; &#125; //注释(不)输出 else if(c==25)&#123; return; //cout&lt;&lt;"COMMENT "&lt;&lt;tok&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;tok&lt;&lt;endl; &#125;&#125; 所以只需要针对其修改输出定向即可，实现语句如下：1FILE *fp1 = freopen("/Users/jiahaonan/Desktop/大三下/编译原理/前端展示/out.txt", "w+", stdout); 再此执行词法分析器，可以观察到词法分析器的输出结果均被定向至out.txt文件中 封装词法分析器由于不是同一语言，解决输出重定向问题后，在保证词法分析器功能无误的前提下，需要对词法分析器进行功能封装，即转变为可执行程序。 可以通过通过终端下的g++编译器实现，指令如下：1g++ -o word_analyse main.cpp 将编译生成的可执行文件word_analyse放入与SLR语法分析类相同目录的文件夹下。 到此，词法分析器的修改封装已成功完成。 若需要在python中调用此可执行文件，需要使用如下代码：123import osos.system("word_analyse") 语法分析器由于实验5在设计时采用了面向对象的思想，故在实验6中通过如下代码可以直接引入SLR类来使用，无需修改！ 123import SLRSLR.test() 这里的test即为实验5中的主测试函数，代码如下：1234567891011121314151617181920212223242526def test(): # 终结符号集/非终结符号集 Vn = ['A', 'V', 'E', 'T', 'F'] Vt = ['+', '-', '*', '/', '(', ')', 'i', '='] # 规则集合 rule = &#123; 'A': ["V=E"], 'E': ["E+T", "E-T", "T"], 'T': ["T*F", "T/F", "F"], 'F': ["(E)", "i"], 'V': ["i"] &#125; slr = SLR(start='A', Vt=Vt, Vn=Vn, rule=rule) test_words = "" test_symbol = "" f = open("out.txt", 'r') while (True): t = f.readline().strip('\n') if (t == ''): break test_symbol += t[0] test_words += t[-1] slr.compile(symbol=test_symbol, word=test_words, log=True) 数据流在封装好词法分析器后、引入语法分析器后，下一步需要做的就是如何设计文件I/O流，以衔接词法分析器和SLR语法分析器。 我的设计思想如下： 总体来说，共需要使用到3个操作文件： in.txt：词法分析器的接受输入文件 out.txt：词法分析器的二元组输出文件，同时供语法分析器输入 out1.txt：语法分析器的语法制导翻译过程输出文件 文件的预览如下： 需要说明的是，out1文件为了观测的直观性输出了一些辅助性信息，可以通过控制输出来取消，无大影响。 图形化前端设计虽然本次实验的前端含义不代表web/图形化前端，但既然已经将工程转移到python下了，就一不做二不休。 根据题目的需求，前端应该具有如下功能： 接受待分析的代码输入 对代码进行词法分析，并输出二元式中间文件 对二元组中间文件进行语法分析，并输出四元式中间文件 这里通过tkinter库来依次完成以上需求。 接受输入通过一个Entry类型的控件实现输入功能，代码如下：12345tip = Label(root,text="你可以在此输入代码",font=("手扎体-简",18))tip.place(x=100,y=110)code = Entry(root,width=18)code.place(x=100,y=135) 如果要调用code控件的输入内容，只需使用如下函数即可：1code.get() 词法分析对输入的代码进行词法分析应该属于功能选择类，所以我们需要通过两个Button类型的控件实现选择并打印，通过一个Text类型的控件实现词法分析结果的输出 代码如下：12345678910111213141516171819202122232425262728293031# 选择词法分析def compile_confirm(event): if(len(code.get())==0): a = messagebox.showinfo("","您没有输入任何语句") return f = open("in.txt", 'w') var = code.get() f.write(code.get()) f.write('\n')word_show = Text(root,height=6,width=30)word_show.place(x=75,y=235)# 选择打印结果def print_confirm1(event): word_ans = "" os.system("word_analyse") with open("out.txt",'r') as f: word_ans += f.read() word_show.delete('1.0', 'end') word_show.insert(INSERT,word_ans)btn_compile = Button(root, text=" 词法分析 ")btn_compile.place(x=140,y=180)btn_compile.bind("&lt;Button-1&gt;",compile_confirm)btn_print1 = Button(root, text=" 打印结果 ")btn_print1.place(x=140,y=205)btn_print1.bind("&lt;Button-1&gt;",print_confirm1) 执行效果如下： 语法分析词法分析成功之后，接下来实现语法分析功能。 语法分析的实现机理与词法分析类似，需要通过一个Button类型的控件实现语法分析功能选择，通过一个Text类型的控件实现语法分析结果的输出 代码如下；1234567891011121314langu_show = Text(root,height=10,width=30)langu_show.place(x=75,y=365)def print_confirm2(event): langu_ans = "" SLR.test() with open("out1.txt",'r') as f: langu_ans += f.read() langu_show.delete('1.0', 'end') langu_show.insert(INSERT,langu_ans)btn_compile1 = Button(root, text=" 语法分析 ")btn_compile1.place(x=140,y=335)btn_compile1.bind("&lt;Button-1&gt;",print_confirm2) 执行效果如下： 到此，前端的设计圆满成功！ 附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import osfrom tkinter import *from tkinter import messageboximport SLRroot = Tk()root.title("前端展示")root.geometry('400x600')title = Label(root,text="编译前端",font=("手扎体-简",30))title.place(x=120,y=30)tip = Label(root,text="你可以在此输入代码",font=("手扎体-简",18))tip.place(x=100,y=110)code = Entry(root,width=18)code.place(x=100,y=135)def compile_confirm(event): if(len(code.get())==0): a = messagebox.showinfo("","您没有输入任何语句") return f = open("in.txt", 'w') var = code.get() f.write(code.get()) f.write('\n')word_show = Text(root,height=6,width=30)word_show.place(x=75,y=235)def print_confirm1(event): word_ans = "" os.system("word_analyse") with open("out.txt",'r') as f: word_ans += f.read() word_show.delete('1.0', 'end') word_show.insert(INSERT,word_ans)langu_show = Text(root,height=10,width=30)langu_show.place(x=75,y=365)def print_confirm2(event): langu_ans = "" SLR.test() with open("out1.txt",'r') as f: langu_ans += f.read() langu_show.delete('1.0', 'end') langu_show.insert(INSERT,langu_ans)btn_compile = Button(root, text=" 词法分析 ")btn_compile.place(x=140,y=180)btn_compile.bind("&lt;Button-1&gt;",compile_confirm)btn_print1 = Button(root, text=" 打印结果 ")btn_print1.place(x=140,y=205)btn_print1.bind("&lt;Button-1&gt;",print_confirm1)btn_compile1 = Button(root, text=" 语法分析 ")btn_compile1.place(x=140,y=335)btn_compile1.bind("&lt;Button-1&gt;",print_confirm2)root.mainloop()]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——基于SLR1的语法制导翻译及中间代码生成]]></title>
    <url>%2F2019%2F06%2F03%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ESLR1%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[目标任务实验项目完成以下描述赋值语句SLR(1)文法语法制导生成中间代码四元式的过程。12345G[A]: A→V=E E→E+T∣E-T∣T T→T*F∣T/F∣F F→(E)∣i V→i 设计说明终结符号i为用户定义的简单变量，即标识符的定义。 设计要求（1）构造文法的SLR(1)分析表，设计语法制导翻译过程，给出每一产生式对应的语义动作；（2）设计中间代码四元式的结构；（3）输入串应是词法分析的输出二元式序列，即某赋值语句“专题1”的输出结果，输出为赋值语句的四元式序列中间文件；（4）设计两个测试用例（尽可能完备），并给出程序执行结果四元式序列。 实验过程数据结构在明确好编程思想后，首先需要确定下来的就是如何组织类及类成员，如何存储数据。下面给出算符优先语法分析类class SLR的成员变量/函数及其设计说明： 类成员变量 成员变量 类型 备注 start str 文法开始符号 Vt set() 终结符号集合 Vn set() 非终结符号集合 V set() 文法全部符号集合，用于构造SLR分析表 rule dict{str: list[str]} 文法产生式规则 point str 即符号‘.’，用于构造项目集 first set() 文法的first集，用于构造follow集 follow set() 文法的follow集，用于解决冲突项目 C dict{int: dict{str:list[str]}} 记录有效项目集规范族 r dict{int: dict{str:str}}} 记录产生式序号，辅助生成action表中的r项 action dict{(int,str):str} 记录SLR分析表中的action动作，包括‘S’和‘r’ goto dict{(int,str):int} 记录SLR分析表中的goto动作，即记录待跳转的下一个项目集序号 类成员函数 成员函数 备注 init(self, start, Vn, Vt, rule) 类的构造函数，通过输入文法的开始符号、非终结符/终结符号集、产生式规则从而构造并返回SLR类 get_first(self) 构造first集合 get_follow(self) 构造follow集合 op_start(self) 构造有效项目集的第一步动作，即加入：‘.’+开始符号产生式 op_closure(self,c_j) 求c_j项目集的闭包 op_go(self,i,x) 实现Go(Ci ,x)函数功能 judge(self,i) 判断C[i]是否为终态，辅助构造有效项目集C get_C(self) 生成有效项目集规范族C get_r(self) 生成带序号的产生式，用于生成action表中的r部分 get_action(self) 构造分析表的action部分 get_goto(self) 构造分析表的goto部分 compile(self, symbol, word, log) 对输入语句进行语法分析，其中 symbol: 符号语句；word: 真实语句；log: 是否打印四元式 本次实验的重点在于下面几个成员函数的实现： 求c_j项目集的闭包get_C(self): 自动生成有效项目集规范族Cget_action(self): 构造分析表的action部分get_goto(self): 构造分析表的goto部分compile(self, symbol, word, log): 对输入语句进行语法分析 求C[j]项目集的闭包求C[j]项目集闭包，即实现closure(Cj)的功能，其算法如下： $$① C_i 的任何项目均属于closure(C_i)$$ $$② （重复）若A → α·X β(X∈V_n) ∈ closure(C_i) ,则X → ·λ ∈ closure(C_i)$$ $$③ C_i = closure(C_i)$$ 代码实现如下，上面三步在代码中有详细注释：12345678910111213141516171819202122232425def op_closure(self,c_j): #① C_i 的任何项目均属于closure(C_i) closure_i = c_j #② （重复）若A → α·X β(X∈V_n) ∈ closure(C_i) ,则X → ·λ ∈ closure(C_i) while(True): closure_i1=closure_i.copy() key_list = list(closure_i.keys()) for A in key_list: for aXb in closure_i[A]: for j in range(len(aXb)-1): if(aXb[j]==self.point and aXb[j+1] in self.Vn): # 如何没有则新建一个key if(aXb[j+1] not in closure_i.keys()): closure_i.update(&#123;aXb[j + 1]:[]&#125;) key_list.append(aXb[j + 1]) for l in rule[aXb[j+1]]: temp = self.point+l if(temp not in closure_i[aXb[j+1]]): closure_i[aXb[j+1]].append(temp) # 重复,直至 closure(Ci)不再增大. if(closure_i != closure_i1): closure_i1 = closure_i.copy() else: # ③ C_i = closure(C_i) return closure_i 自动生成有效项目集规范族C在SLR(1)分析过程中，前期准备中最重要的就是构建SLR(1)的有效项目集规范族C 根据生成算法，我们来对代码进行逐步实现 1.拓广文法,保证唯一初态. 1234# 拓广文法self.rule['S'] = start + "#"self.Vn.append('S')self.start = 'S' 2.生成C0={S→ ·δ} ∪{S→ ·δ的闭包操作} 1234# 生成C0=&#123;S→ ·δ&#125;self.op_start()# ∪ &#123;S→ ·δ的闭包操作&#125;self.C[0]=self.op_closure(self.C[0]) 3.重复以下过程,直至C不再增大为止. Ci读操作,生成Cj1,Cj2,…….CjnCj1,Cj2,…….Cjn闭包操作(若其中某项目集已经存在就略去) 123456789101112131415161718192021222324i = 0j = 1while(True): # 判断C[i]是否为终态 if (i == j): break if(self.judge(i)==True): self.tC.append(i) i=i+1 continue for v in self.V: c_j = self.op_go(i,v) if(len(c_j)!=0): closure_j = self.op_closure(c_j) flag = True if self.check_in_C(closure_j): flag=False if flag: self.C[j]=closure_j j = j + 1 if (i&lt;j): i=i+1 else: break 到此，该文法下的有效项目集规范族已被完全构建，看一下预览：可以看到，拓广文法后产生的21个项目完全正确 构造分析表的action部分SLR(1)文法的分析表包括action和Goto两个部分，这里先谈第一部分，即action部分的实现 action动作的添加主要分为三种情况： 1.若GO(Ci, a)=Cj a∈Vt, 置ACTION(i,a)=Sj Sj:移进,把下一状态j和现输入符号a移入栈 2.若S→δ· ∈ Ck , (S为拓广文法开始符号) 置ACTION(k,#)=acc acc:接受 3.若A→α·∈Ci , 且 a∈FOLLOW(A) , a∈Vt 置ACTION(i,a)=rj (A → α为第 j个产生式) rj:归约,按第j产生式归约 所以我们的目的是，遍历文法Vt中的所有终结符号在构造好的项目集C中找到对应情况下的（项目，符号）组合，为该组合添加对应动作 代码实现如下：12345678910111213141516171819202122232425262728293031# 构造分析表的action部分 def get_action(self): # 若GO(Ci, a)=Cj a∈Vt, 置ACTION(i,a)=Sj for i in self.C.keys(): for a in self.Vt: j = self.GO(i,a) if(j!=-1): self.action[(i,a)]='S'+str(j) # 若A→α·∈Ci , 且 a∈FOLLOW(A) # a∈Vt 置ACTION(i,a)=rj (A → α为第 j个产生式) for i in self.C: for A in self.C[i].keys(): for item in self.C[i][A]: # 项目最后一个为点 '·' if(item[-1] == self.point): for a in self.follow[A]: # 找到对应的规约产生式 for j in self.r.keys(): temp = &#123;A:item[:-1]&#125; if(self.r[j] == temp): self.action[(i,a)]='r'+str(j) # 若S→δ·∈ Ck ,(S为拓广文法开始符号） # 置ACTION(k,#)=acc omiga = rule[self.start]+self.point for k in self.C: for key in self.C[k].keys(): if(key==self.start and omiga in self.C[k][key]): self.action[(k,'#')]="acc" 构造分析表的Goto部分Goto部分是在遍历文法Vn中的所有非终结符号时产生的动作，即状态S面临文法符号x时下一状态 Goto动作的添加仅对应一种情况： 若GO(Ci,A)=Cj , A∈Vn ,置GOTO(i,A)=j 代码实现如下：12345678# 构造分析表的goto部分def get_goto(self): # 若GO(Ci, A)=Cj A∈Vn, 置GOTO(i,A)=j for i in self.C.keys(): for A in self.Vn: j = self.GO(i, A) if (j != -1): self.goto[(i, A)] = j 到此，我们已经构造好了SLR(1)分析表的所有部分，对于该题文法下的分析表，预览如下： 可对比上面生成的项目集，结果完全正确！ 语法分析在SLR类构建完毕之后，下面我们便可以通过接收输入来进行语法分析过程。 控制输入根据题干要求，输入参数应为词法分析器所输出的二元组，所以这里对分析函数的参数列表构建如下，其中，word代表真实符号，symbol代表根据真实符号所转化的定义符号：1def compile(self, symbol, word, log) 举个例子，对于输入语句：X = A*(B+C)+D而言：12symbol : i=i*(i+i)+iword : X=A*(B+C)+D 可以看出，symbol的作用在于进行语法分析，而word的作用在于生成四元式。 当然，这实现起来很简单，只需要在读如文件时控制读如组合即可，代码如下：12345678test_words = ""test_symbol = ""f = open("in2.0.txt",'r')while(True): t = f.readline().strip('\n') if(t == ''): break test_symbol += t[0] test_words += t[-1] 对于如下格式的二元组输入： 可以看到这样的拼接结果： SLR(1)分析SLR(1)的分析过程与LR(0)相同，需要两个栈来辅助分析，分别是：状态栈、符号栈分析过程如图： 代码实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# SLR（1）法分析# symbol: 符号语句 word: 真实语句def compile(self, symbol, word, log): # 补充# symbol+="##" # 状态栈 state = ['0'] # 符号栈 charater = ['#'] #输入串下标 k=0 while(True): state_now = eval(state[len(state)-1]) input_ch = symbol[k] if ((state_now,input_ch) in self.action.keys()): action = self.action[(state_now, input_ch)] else: action='-1' if(action[0]=='S'): #if(input_ch != '#'): k = k+1 charater.append(input_ch) state.append(action[1:]) continue elif(action[0]=='r'): # 规约动作r r = &#123;&#125; r = self.r[eval(action[1])] # 规约长度 lenth = 0 # 规约终结符 substitude = '' r_rule='' for left in r.keys(): substitude = left for right in r[left]: r_rule+=right for i in range(len(r_rule)): charater.pop() state.pop() # 新规约终结符进符号栈 charater.append(substitude) new_state = self.goto[(eval(state[len(state)-1]),substitude)] state.append(str(new_state)) elif(action=='acc'): return True else: return False 其中，substitute和r_rule记录了每次规约时所选用的产生式substitute -&gt; r_rule所以根据此，我们可以去匹配生成对应的四元式组。 由课上所学可知，运算赋值语句文法每次规约时产生的对应动作如下： 用代码实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 根据规约规则r_rule决定执行动作, log为分析开关 # 预定义.PLACE变量 if log == True: E_place = [] F_place = [] V_place = [] T_place = [] t = 0 #temp计数器 # 添加至上段中的while(True)中 if log==True: # ② A →V=E if (substitude == 'A' and r_rule == "V=E"): print("( =, "+E_place.pop()+", ,"+V_place.pop()+" )") # ③ E(1)→E(2)+T elif (substitude == 'E' and r_rule == "E+T"): E1_place = "temp"+str(t) t=t+1 print("( +, "+E_place.pop()+", "+T_place.pop()+", "+E1_place+" )") E_place.append(E1_place) # ④ E → T elif (substitude == 'E' and r_rule == "T"): E_place.append(T_place.pop()) # ⑤ T(1)→ T(2)*F elif (substitude == 'T' and r_rule == "T*F"): T1_place = "temp"+str(t) t=t+1 print("( *, "+T_place.pop()+", "+F_place.pop()+", "+T1_place+" )") T_place.append(T1_place) # ⑥ T → F elif (substitude == 'T' and r_rule == "F"): T_place.append(F_place.pop()) # ⑦ F →(E) elif (substitude == 'F' and r_rule == "(E)"): F_place.append(E_place.pop()) # ⑧ F → i elif (substitude == 'F' and r_rule == "i"): F_place.append(word[k-1]) # ⑨ V →i elif (substitude == 'V' and r_rule == "i"): V_place.append(word[k-1]) 这里需要注意的一点是如何区分诸如E(1)→E(2)+T规则中的（1）和（2）我的解决方法为：用栈结构来存储各个place变量。根据运算赋值文法的特点，后产生的E一定会被先规约用掉，所以用栈来模拟可以保证先产生的E不被后续的E所覆盖。 到此，本次实验的SLR类已经被完全构建完毕。 SLR类分析测试我们以语句：X=A*(B+C)+D为例对其进行词法分析，首先得到二元组结果文件如下： 经过文件组织拼接后，调用函数1slr.compile(symbol=test_symbol,word=test_words,log=True) 得到输出结果如下： 为了详细分析，通过适当调整输出来观测状态栈、符号栈的变化，结果如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 /Users/jiahaonan/Desktop/大三下/编译原理/算符优先/SLR.py[状态栈]:[&apos;0&apos;][符号栈]:[&apos;#&apos;][状态栈]:[&apos;0&apos;, &apos;3&apos;][符号栈]:[&apos;#&apos;, &apos;i&apos;][1]: V -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;10&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;i&apos;][2]: F -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;8&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;F&apos;][3]: T -&gt; F[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;10&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;i&apos;][4]: F -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;8&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;F&apos;][5]: T -&gt; F[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;7&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;T&apos;][6]: E -&gt; T[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;11&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;+&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;11&apos;, &apos;10&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;+&apos;, &apos;i&apos;][7]: F -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;11&apos;, &apos;8&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;+&apos;, &apos;F&apos;][8]: T -&gt; F[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;11&apos;, &apos;16&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;+&apos;, &apos;T&apos;][9]: E -&gt; E+T( +, B, C, temp0 )[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;20&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;)&apos;][10]: F -&gt; (E)[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;18&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;F&apos;][11]: T -&gt; T*F( *, A, temp0, temp1 )[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;][12]: E -&gt; T[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;, &apos;11&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;, &apos;+&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;, &apos;11&apos;, &apos;10&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;, &apos;+&apos;, &apos;i&apos;][13]: F -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;, &apos;11&apos;, &apos;8&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;, &apos;+&apos;, &apos;F&apos;][14]: T -&gt; F[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;, &apos;11&apos;, &apos;16&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;, &apos;+&apos;, &apos;T&apos;][15]: E -&gt; E+T( +, temp1, D, temp2 )[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;][16]: A -&gt; V=E( =, temp2, ,X )[状态栈]:[&apos;0&apos;, &apos;1&apos;][符号栈]:[&apos;#&apos;, &apos;A&apos;][状态栈]:[&apos;0&apos;, &apos;1&apos;, &apos;4&apos;][符号栈]:[&apos;#&apos;, &apos;A&apos;, &apos;#&apos;]TrueProcess finished with exit code 0 分析过程及四元式产生结果完全正确！ 优势 本次代码编写采用了面向对象的编程思想，保证了SLR类的泛用性 只需要改变输入的符号集合及文法规则，即可对不同的满足SLR1文法的语句进行语法分析 程序能给出每一步的精确分析过程，并产生对应四元组 附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469class SLR: def __init__(self, start, Vn, Vt, rule): # 初始化类元素 self.start = start self.Vt = Vt self.Vt.append('#') self.Vn = Vn self.rule = rule self.point = '.' self.V = Vn + Vt # 拓广文法 self.rule['S'] = start + "#" self.Vn.append('S') self.start = 'S' # 获得first集 self.first = &#123;vn:set() for vn in self.Vn&#125; self.get_first() # 获得follow集 self.follow = &#123;vn: set() for vn in self.Vn&#125; self.get_follow() # 生成有效项目集 #self.C = &#123;k : dict() for k in range(12)&#125; self.C = &#123;&#125; self.tC = [] # 终态项目集 self.get_C() # 生成action表 self.r = &#123;&#125; # 记录规约序号，辅助生成action表中的r项 self.get_r() self.action = dict() self.get_action() # 生成Goto表 self.goto = dict() self.get_goto() def get_first(self): rule1 = self.rule.copy() item = rule1[self.start] rule1[self.start] = [item] ''' 若X∈Vn 有X→aα , (a ∈Vt )或/和X→ε 则 a或 /和ε ∈ FIRST(x) ''' for left in rule1.keys(): for right in rule1[left]: if(right[0] in self.Vt): self.first[left].add(right[0]) ''' 对X→Y1Y2.......Yk(且Y1 ∈Vn), 反复使用以下 直到每一个FIRST(X)不再增大为止. i 若Y1 ∈Vn 则把FIRST(Y1 )\&#123;ε&#125;元素加入FIRST(X)中 ii 若Y1、Y2、......Y i-1 ∈Vn (2≤i ≤k) 且ε ∈FIRST(Y j) (1≤j ≤i-1) 则把FIRST(Yi )\&#123;ε&#125;元素加入FIRST(x)中 iii 若Y1、Y2、......Yk ∈Vn 且ε ∈FIRST(Y j) (1≤j ≤k) 则把ε元素加入FIRST(x)中 ''' size1 = 0 size2 = 0 for key in self.first: for item in self.first[key]: size1 += len(item) while(True): for left in rule1.keys(): for right in rule1[left]: Y1 = right[0] if(Y1 in self.Vn): set1 = self.first[Y1] for item in set1: self.first[left].add(item) for key in self.first: for item in self.first[key]: size2 += len(item) if(size1 != size2): size1=size2 size2=0 continue else: break def get_follow(self): rule1 = self.rule.copy() item = rule1[self.start] rule1[self.start] = [item] # 1. 令# ∈FOLLOW(S) S为文法开始符号 self.follow[self.start].add('#') # 2. 对A→ αBβ, 且β ≠ ε 则将 FIRST(β)\&#123;ε&#125;加入FOLLOW(B)中 for left in rule1.keys(): for right in rule1[left]: for k in range(len(right)-1): # B:right[k] if(right[k] in self.Vn): # B下一个字符是终结符，则直接加入B的follow集 if(right[k+1] in self.Vt): self.follow[right[k]].add(right[k+1]) # B下一个字符不是终结符，则将FIRST(β)加入B的follow集 elif(right[k+1] in self.Vn): set1 = self.first[right[k+1]] for item in set1: self.follow[right[k]].add(item) # 3.反复, 直至每一个FOLLOW(A)不再增大 # 对A→ αB或A→ αBβ(且ε ∈ FIRST(β)) # 则FOLLOW(A)中的全部元素加入FOLLOW(B) size1=0 size2=0 for key in self.follow: for item in self.follow[key]: size1 += len(item) while(True): for left in rule1.keys(): for right in rule1[left]: # B:right[-1] 对A→ αB if(right[-1] in self.Vn): set1 = self.follow[left] for item in set1: self.follow[right[-1]].add(item) for key in self.follow: for item in self.follow[key]: size2 += len(item) if (size1 != size2): size1=size2 size2=0 continue else: break ''' 开始操作:S为开始符号, S→δ 则 S→·δ ∈ C0 ''' def op_start(self): self.C[0]= &#123;'S':[self.point+self.rule['S']]&#125; ''' 闭包操作:closure(Ci) Ci的闭包 ① Ci 的任何项目均属于closure(Ci) ② 若A → α·X β且X∈Vn属于closure(Ci) 则X → ·λ 属于closure(Ci) 重复,直至 closure(Ci)不再增大. ③ Ci = closure(Ci) ''' def op_closure(self,c_j): #closure_i = self.C[i] #dict类型 closure_i = c_j while(True): closure_i1=closure_i.copy() key_list = list(closure_i.keys()) for A in key_list: for aXb in closure_i[A]: for j in range(len(aXb)-1): if(aXb[j]==self.point and aXb[j+1] in self.Vn): # 如何没有则新建一个key if(aXb[j+1] not in closure_i.keys()): closure_i.update(&#123;aXb[j + 1]:[]&#125;) key_list.append(aXb[j + 1]) for l in rule[aXb[j+1]]: temp = self.point+l if(temp not in closure_i[aXb[j+1]]): closure_i[aXb[j+1]].append(temp) # 重复,直至 closure(Ci)不再增大. if(closure_i != closure_i1): closure_i1 = closure_i.copy() else: return closure_i ''' 读操作: Go(Ci ,x ) x∈V Go(Ci ,x )=Cj 其中: Cj=&#123;A→αx·β∣ A→α·x β∈Ci&#125; ''' def op_go(self,i,x): c_j = dict() dict_j = self.C[i] for A in dict_j.keys(): for aXb in dict_j[A]: for j in range(len(aXb) - 1): if(aXb[j] == self.point and aXb[j+1] == x): if(A not in c_j.keys()): c_j.update(&#123;A:[]&#125;) c_j[A].append(aXb[:j]+aXb[j+1]+self.point+aXb[j+2:]) return c_j # 判断C[i]是否为终态 def judge(self,i): dict_i = self.C[i] for key in dict_i.keys(): for value in dict_i[key]: if(value[-1]!=self.point): return False return True def check_in_C(self,closure_j): for i in self.C.keys(): if closure_j == self.C[i]: return True return False def get_C(self): # 生成C0=&#123;S→ ·δ&#125; self.op_start() # ∪ &#123;S→ ·δ的闭包操作&#125; self.C[0]=self.op_closure(self.C[0]) ''' 重复以下过程,直至C不再增大为止. Ci读操作,生成Cj1,Cj2,…….Cjn Cj1,Cj2,…….Cjn闭包操作 (若其中某项目集已经存在就略去) ''' i = 0 j = 1 while(True): # 判断C[i]是否为终态 if (i == j): break if(self.judge(i)==True): self.tC.append(i) i=i+1 continue for v in self.V: c_j = self.op_go(i,v) if(len(c_j)!=0): #self.C[j] = c_j closure_j = self.op_closure(c_j) flag = True # for key in self.C.keys(): # if(closure_j == self.C[key]): # flag = False if self.check_in_C(closure_j): flag=False if flag: self.C[j]=closure_j j = j + 1 if (i&lt;j): i=i+1 else: break # 用于建分析表的Go函数返回状态集的编号 def GO(self,i,x): c_j = dict() dict_j = self.C[i] for A in dict_j.keys(): for aXb in dict_j[A]: for j in range(len(aXb) - 1): if (aXb[j] == self.point and aXb[j + 1] == x): if (A not in c_j.keys()): c_j.update(&#123;A: []&#125;) c_j[A].append(aXb[:j] + aXb[j + 1] + self.point + aXb[j + 2:]) # 别忘了闭包 c_j = self.op_closure(c_j) for key in self.C.keys(): if self.C[key]==c_j: return key return -1 # 生成辅助规约映射self.r def get_r(self): rule1 = self.rule.copy() item = rule1[self.start] rule1[self.start]=[item] i = 0 for left in rule1.keys(): for right in list(rule1[left]): self.r[i] = &#123;left: right&#125; i = i+1 # 构造分析表的action部分 def get_action(self): # 若GO(Ci, a)=Cj a∈Vt, 置ACTION(i,a)=Sj for i in self.C.keys(): for a in self.Vt: j = self.GO(i,a) if(j!=-1): self.action[(i,a)]='S'+str(j) # 若A→α·∈Ci , 且 a∈FOLLOW(A) # a∈Vt 置ACTION(i,a)=rj (A → α为第 j个产生式) for i in self.C: for A in self.C[i].keys(): for item in self.C[i][A]: # 项目最后一个为点 '·' if(item[-1] == self.point): for a in self.follow[A]: # 找到对应的规约产生式 for j in self.r.keys(): temp = &#123;A:item[:-1]&#125; if(self.r[j] == temp): self.action[(i,a)]='r'+str(j) # 若S→δ·∈ Ck ,(S为拓广文法开始符号） # 置ACTION(k,#)=acc omiga = rule[self.start]+self.point for k in self.C: for key in self.C[k].keys(): if(key==self.start and omiga in self.C[k][key]): self.action[(k,'#')]="acc" # 构造分析表的goto部分 def get_goto(self): # 若GO(Ci, A)=Cj A∈Vn, 置GOTO(i,A)=j for i in self.C.keys(): for A in self.Vn: j = self.GO(i, A) if (j != -1): self.goto[(i, A)] = j # SLR（1）法分析 # symbol: 符号语句 word: 真实语句 def compile(self, symbol, word, log): # 预定义.PLACE变量 if log == True: E_place = [] F_place = [] V_place = [] T_place = [] t = 0 #temp计数器 kk = 1#log计数器 # 补充# symbol+="##" # 状态栈 state = ['0'] # 符号栈 charater = ['#'] #输入串下标 k=0 while(True): state_now = eval(state[len(state)-1]) input_ch = symbol[k] if ((state_now,input_ch) in self.action.keys()): action = self.action[(state_now, input_ch)] else: action='-1' if(action[0]=='S'): #if(input_ch != '#'): k = k+1 charater.append(input_ch) state.append(action[1:]) continue elif(action[0]=='r'): # 规约动作r r = &#123;&#125; r = self.r[eval(action[1])] # 规约长度 lenth = 0 # 规约终结符 substitude = '' r_rule='' for left in r.keys(): substitude = left for right in r[left]: r_rule+=right for i in range(len(r_rule)): charater.pop() state.pop() # 根据规约规则r_rule决定执行动作, log为分析开关 if log==True: print("["+str(kk)+"]: "+substitude+" -&gt; "+r_rule) kk = kk+1 # ② A →V=E if (substitude == 'A' and r_rule == "V=E"): print("( =, "+E_place.pop()+", ,"+V_place.pop()+" )") # ③ E(1)→E(2)+T elif (substitude == 'E' and r_rule == "E+T"): E1_place = "temp"+str(t) t=t+1 print("( +, "+E_place.pop()+", "+T_place.pop()+", "+E1_place+" )") E_place.append(E1_place) # ④ E → T elif (substitude == 'E' and r_rule == "T"): E_place.append(T_place.pop()) # ⑤ T(1)→ T(2)*F elif (substitude == 'T' and r_rule == "T*F"): T1_place = "temp"+str(t) t=t+1 print("( *, "+T_place.pop()+", "+F_place.pop()+", "+T1_place+" )") T_place.append(T1_place) # ⑥ T → F elif (substitude == 'T' and r_rule == "F"): T_place.append(F_place.pop()) # ⑦ F →(E) elif (substitude == 'F' and r_rule == "(E)"): F_place.append(E_place.pop()) # ⑧ F → i elif (substitude == 'F' and r_rule == "i"): F_place.append(word[k-1]) # ⑨ V →i elif (substitude == 'V' and r_rule == "i"): V_place.append(word[k-1]) # 新规约终结符进符号栈 charater.append(substitude) new_state = self.goto[(eval(state[len(state)-1]),substitude)] state.append(str(new_state)) elif(action=='acc'): return True else: return Falseif __name__ == "__main__": # 终结符号集/非终结符号集 Vn = ['A', 'V', 'E', 'T', 'F'] Vt = ['+', '-', '*', '/', '(', ')', 'i' , '='] # 规则集合 rule = &#123; 'A': ["V=E"], 'E': ["E+T","E-T","T"], 'T': ["T*F", "T/F", "F"], 'F': ["(E)","i"], 'V': ["i"] &#125; slr = SLR(start='A',Vt=Vt,Vn=Vn,rule=rule) test_words = "" test_symbol = "" f = open("in2.0.txt",'r') while(True): t = f.readline().strip('\n') if(t == ''): break test_symbol += t[0] test_words += t[-1] print(slr.compile(symbol=test_symbol,word=test_words,log=True))]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——页面置换算法]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实验目的设计和实现最佳置换算法、先进先出置换算法、最近最久未使用置换算法、改进型Clock置换算法、页面缓冲置换算法；通过页面访问序列随机发生器实现对上述算法的测试及性能比较。 前提假设 页表用整数数组或结构数组来表示 页面访问序列串是一个整数序列，整数的取值范围为0到N-1。页面访问序列串中的每个元素p表示对页面p的一次访问 实验设计全局变量为了便于对不同算法的统一设计，在代码中设计了一些全局变量，作如下说明： 变量名 类型 备注 req typedef struct { int request;bool lack=false; int modify=0;} 记录一个页面请求。request：请求页号；lack：该请求是否缺页；modify：请求页是否被修改。 re vector&lt;req> 数组记录，re[i]代表第i个时刻进来的页面请求结构体。 bar int [M][N] 记录物理块情况。M个块、N个请求。 access int [M] 记录M个块所存页号的访问位 modify int [M] 记录M个块所存页号的修改位 FIFOFIFO即first in first out该算法的替换策略为： 每次发生缺页时总是替换出最早进入物理块的页号，即最先进来的就最先出去。 所以整个算法总共分为三步： 页号预装(注：预装页号默认为不会重复，下同) 1234567891011//没个块，n个请求double FIFO(int m,int n)&#123; memset(bar, -1, sizeof(bar)); //初始化前0〜m-1个序列 //i: 周期 for(int i=0;i&lt;m;i++)&#123; //j: 块 for(int j=0;j&lt;=i;j++)&#123; bar[j][i] = re[j].request; &#125; &#125; 检查所到请求是否存在于物理块中 123456789101112131415161718//装载第i: m〜n-1个序列for(int i=m;i&lt;n;i++)&#123; //对j：0〜m块，首先把第i-1时段各块的情况拷贝给第i的时段 for(int j=0;j&lt;m;j++)&#123; bar[j][i] = bar[j][i-1]; &#125; //记录第i个请求 int now_req=re[i].request; //判断现在内存中有无该请求页号 bool has=false; for(int j=0;j&lt;m;j++)&#123; if(bar[j][i]==now_req)&#123; has=true; break; &#125; &#125; //有的话直接下一个 if(has) continue; 如果不存在，则将最早进入物理块的页号替换出去 123456789101112131415161718192021222324252627// 没有的话要考虑把谁替换掉 // 先记录缺页 re[i].lack=true; // 考察序列范围：第i+1个到第n-1个 // 对m个块中个字各自装载的页号考察 // 需要向前检查bar[j][i]，即bar[j]目前内存中的页号装载了几个周期 int long_m=-1;//记录待了最久的bar[j]的次数 int long_j=-1;//记录待了最久的bar[j]的下标j for(int j=0;j&lt;m;j++)&#123; int temp_m=0; int temp_no=bar[j][i]; for(int k=i-1;k&gt;0;k--)&#123; if(temp_no==bar[j][k]) temp_m++; else break; &#125; if(temp_m&gt;long_m)&#123; long_m=temp_m; long_j=j; &#125; &#125; //替换 bar[long_j][i]=now_req;&#125; OPT最佳页面置换算法OPT，即optimal page replacement该算法的替换策略为： 选择永不使用或是在最长时间内不再被访问（即距现在最长时间才会被访问）的页面淘汰出内存 所以在遇到缺页时，需要根据物理块中现有的页号向后考察请求队列，将最晚出现或者从未出现的页号替换出内存整个算法总共分为三步： 页号预装 1234567891011//最佳置换: m个块，n个周期序列double OPT(int m,int n)&#123; memset(bar, -1, sizeof(bar)); //初始化前0〜m-1个序列 //i: 周期 for(int i=0;i&lt;m;i++)&#123; //j: 块 for(int j=0;j&lt;=i;j++)&#123; bar[j][i] = re[j].request; &#125; &#125; 检查所到请求是否存在于物理块中 123456789101112131415161718//装载第i: m〜n-1个序列for(int i=m;i&lt;n;i++)&#123; //对j：0〜m块，首先把第i-1时段各块的情况拷贝给第i的时段 for(int j=0;j&lt;m;j++)&#123; bar[j][i] = bar[j][i-1]; &#125; //记录第i个请求 int now_req=re[i].request; //判断现在内存中有无该请求页号 bool has=false; for(int j=0;j&lt;m;j++)&#123; if(bar[j][i]==now_req)&#123; has=true; break; &#125; &#125; //有的话直接下一个 if(has) continue; 如果不存在，则将未来最长时间内不再被请求的页号替换出去 123456789101112131415161718192021222324252627282930313233343536// 没有的话要考虑把谁替换掉 // 先记录缺页 re[i].lack=true; // 考察序列范围：第i+1个到第n-1个 // 对m个块中个字各自装载的页号考察 bool find=false; int far_no=-1,far_m=-1;//记录最远出现的页号和其所在块 for(int j=0;j&lt;m;j++)&#123; int temp_no=bar[j][i]; int temp_m=-1; int k=i+1; for(;k&lt;n;k++)&#123; //在未来的请求序列中找到了temp_no if(re[k].request==temp_no)&#123; temp_m=k; find=true; break; &#125; &#125; //记录距离最大的 if(temp_m&gt;far_m)&#123; far_m=temp_m; far_no=j; &#125; //未来请求中没有，则肯定替换这个 if(k==n)&#123; find=false; bar[j][i]=now_req; break; &#125; &#125; //找到了一个未来中最大的 if(find)&#123; bar[far_no][i]=now_req; &#125; LRU最近最久未使用置换算法LRU，即Least Recently Used该算法的替换策略为： 以“最近的过去”作为“最近的将来”的近似，选择最近一段时间最长时间未被访问的页面淘汰出内存 该算法的思想与OPT类似，但搜索方向相反，每次在遇到缺页时其总是根据物理块中现有的页号向前考察请求队列，将最早出现的请求页号替换出内存整个算法总共分为三步： 页号预装 12345678910double LRU(int m,int n)&#123; memset(bar, -1, sizeof(bar)); //初始化前0〜m-1个序列 //i: 周期 for(int i=0;i&lt;m;i++)&#123; //j: 块 for(int j=0;j&lt;=i;j++)&#123; bar[j][i] = re[j].request; &#125; &#125; 检查所到请求是否存在于物理块中 123456789101112131415161718//装载第i: m〜n-1个序列for(int i=m;i&lt;n;i++)&#123; //对j：0〜m块，首先把第i-1时段各块的情况拷贝给第i的时段 for(int j=0;j&lt;m;j++)&#123; bar[j][i] = bar[j][i-1]; &#125; //记录第i个请求 int now_req=re[i].request; //判断现在内存中有无该请求页号 bool has=false; for(int j=0;j&lt;m;j++)&#123; if(bar[j][i]==now_req)&#123; has=true; break; &#125; &#125; //有的话直接下一个 if(has) continue; 如果不存在，则将此时刻之前最久没有被请求过的页号替换出去 12345678910111213141516171819202122232425262728293031// 没有的话要考虑把谁替换掉 // 先记录缺页 re[i].lack=true; // 考察序列范围：第i-1个到第0个 // 对m个块中个字各自装载的页号考察 bool find=false; int far_no=-1,far_m=0xff;//记录最远出现的页号和其所在块 for(int j=0;j&lt;m;j++)&#123; int temp_no=bar[j][i]; int temp_m=-1; int k=i-1; for(;k&gt;0;k--)&#123; //在过去的请求序列中找到了temp_no if(re[k].request==temp_no)&#123; temp_m=k; find=true; break; &#125; &#125; //记录距离最大的 if(temp_m&lt;far_m)&#123; far_m=temp_m; far_no=j; &#125; &#125; //找到了一个过去中最远出现的 if(find)&#123; bar[far_no][i]=now_req; &#125;&#125; new clock改进型Clock置换算法与上面三个有所不同，其需要用到页面的访问位和修改位，即在全局变量部分的access和modify数组。算法的思想如下： ① 从查寻指针当前位置起扫描内存分页循环队列，选择A=0且M=0的第一个页面淘汰；若未找到，转②② 开始第二轮扫描，选择A=0且M=1的第一个页面淘汰，同时将经过的所有页面访问位置0；若不能找到，转① 所以在算法执行时主要考察两类物理块，即 1类(A =0, M = 0)：表示该页面最近既未被访问，又未被修改，是最佳淘汰页。 2类(A =0, M = 1)：表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。 算法的设计需要五步： 页号预装、变量初始化 12345678910111213double new_clock(int m,int n)&#123; memset(bar, -1, sizeof(bar)); //初始化前0〜m-1个序列 //i: 周期 for(int i=0;i&lt;m;i++)&#123; //j: 块 for(int j=0;j&lt;=i;j++)&#123; bar[j][i] = re[j].request; access[j] = 1;//被访问 modify[j] = re[j].modify;//被修改过 &#125; &#125; int p=0;//充当指针 检查所到请求是否存在于物理块中 1234567891011121314151617181920212223//装载第i: m〜n-1个序列for(int i=m;i&lt;n;i++)&#123; //对j：0〜m块，首先把第i-1时段各块的情况拷贝给第i的时段 for(int j=0;j&lt;m;j++)&#123; bar[j][i] = bar[j][i-1]; &#125; //记录第i个请求 int now_req=re[i].request; int now_modify=re[i].modify; //判断现在内存中有无该请求页号 bool has=false; for(int j=0;j&lt;m;j++)&#123; if(bar[p][i]==now_req)&#123; has=true; access[p]=1; modify[p]=now_modify; p = (p+1)%m; break; &#125; p = (p+1)%m; &#125; //有的话直接下一个 if(has) continue; 如果不存在，则先找第一类 access=0 &amp;&amp; modify==0 123456789101112131415161718192021222324// 没有的话要考虑把谁替换掉 // 先记录缺页 re[i].lack=true; do&#123; //先找第一类 access=0 &amp;&amp; modify==0 bool first=false; //从指针所指位置开始 for(int j=0;j&lt;m;j++)&#123; if(access[p]==0 &amp;&amp; modify[p]==0)&#123; bar[p][i] = now_req;//找到则替换 access[p] = 1;//被访问 modify[p] = now_modify; p = (p+1)%m; first=true; break; &#125; p = (p+1)%m; &#125; if(first)&#123; break; &#125; 如果第一类不存在，则找第二类 access=0 &amp;&amp; modify==1 12345678910111213141516171819202122//第一类失败//再第二类 access=0 &amp;&amp; modify==1bool second=false;for(int j=0;j&lt;m;j++)&#123; if(access[p]==0 &amp;&amp; modify[p]==1)&#123; bar[p][i] = now_req;//找到则替换 access[p] = 1;//被访问 modify[p] = now_modify; p = (p+1)%m; second=true; break; &#125; else&#123; access[p]=0;//访问位均改为0 p = (p+1)%m; &#125;&#125;if(second)&#123; break;&#125; 如果第二类也不存在，则转回第三步 12345678//第二类失败 //指针返回开始位置 p=0; //将所有的访问位复0 for(int j=0;j&lt;m;j++)&#123; access[j]=0; &#125;&#125;while(1); PBA页面缓冲算法PBA，即Page Buffering Algorithm该算法与前面提到的四个算法有着很大的差别，简单来说，该算法需要额外创建一个空闲页面链表，该链表的作用好比额外提供了一定数目的空闲物理块，挂在空闲链表上的页号仍然存在于内存中，只是不在现有的驻留集中，即存在位==0。每当请求页号不在现有的驻留集中时，需要先考察链表上是否挂有请求页号，如果有则将其摘下俩表重新填回驻留集中，如果没有则将填入链首所指向的物理块中。被替换的页号可以采用上面四种中的任意一种方法决定，在该实验中我选取的替换策略为FIFO。 实现PBA需要额外引入一些新的变量，并且需要重新修改物理块的定义：1234567891011121314//PBA:基于先进先出: m个块，n个周期序列，k个空闲块// 空闲页面链表typedef struct &#123; int what;//块内容 int which;//块号&#125;idle_bar;list&lt;idle_bar&gt; idle;// 物理块typedef struct &#123; int flag=0;//存在位 int No=-1;//块号 int time=-1;//time时进入块，用于辅助先进先出判断&#125;NODE;NODE node[M+K]; 算法的设计需要五步： 页号预装、空闲页面链表初始化 1234567891011121314151617double PBA(int m,int n,int k)&#123; //初始化前0〜m-1个序列 //i: 周期 printf("预设:\n"); for(int i=0;i&lt;m;i++)&#123; node[i].No=re[i].request; node[i].flag=1; node[i].time=i; &#125; //idle装入k个空闲物理块 for(int i=0;i&lt;k;i++)&#123; idle_bar temp; temp.what=-1; temp.which=m+i; idle.push_back(temp); &#125; 检查所到请求是否存在于物理块中且在当前驻留集中 1234567891011121314151617181920212223//装载第i: m〜n-1个序列 for(int i=m;i&lt;n;i++)&#123; int now_req=re[i].request; //先在物理块中寻找有没有 int has=-2; for(int j=0;j&lt;m+k;j++)&#123; //存在位为0，说明是挂在idle上的块 if(node[j].flag==0&amp;&amp;node[j].No==now_req)&#123; //has记录在哪个块中 has=j; break; &#125; if(node[j].flag==1&amp;&amp;node[j].No==now_req)&#123; has=-1; break; &#125; &#125; //在内存中且在驻留集中 if(has==-1)&#123; printf("[%d]: 在驻留集中\n",now_req); continue; &#125; 请求存在于物理块中，但不在当前驻留集中 123456789101112131415161718192021222324252627282930313233//在内存中但不在驻留集中 if(has&gt;-1)&#123; printf("[%d]: 在空闲链表上\n",now_req); //要把其拿回到驻留集中 for(list&lt;idle_bar&gt;::iterator it=idle.begin();it!=idle.end();it++)&#123; if(it-&gt;what==now_req)&#123; //fifo替换准则 int mintime=n,minjj=-1; for(int jj=0;jj&lt;m+k;jj++)&#123; if(node[jj].flag==0)//只能替换存在的 continue; if(node[jj].time&lt;mintime)&#123; mintime=node[jj].time; minjj=jj; &#125; &#125; node[minjj].flag=0; node[has].flag=1;//更新为存在 node[has].time=i;//更新时间 //在链表上删除掉，并把替换下来的minjj放入idle中 idle.erase(it); idle_bar temp; temp.what=node[minjj].No; temp.which=minjj; idle.push_back(temp); break; &#125; &#125; for(int ii=0;ii&lt;m+k;ii++) if(node[ii].flag==1)printf("%d ",node[ii].No); cout&lt;&lt;endl; continue; &#125; 请求不在于物理块中，但当前空闲链表中存在空物理块 123456789101112131415161718192021222324252627282930313233343536373839404142//如果不在物理块(内存)中 if(has==-2)&#123; printf("[%d]: 不在物理块中\n",now_req); re[i].lack=true;//缺页 //基于fifo替换 int mintime=n,minjj=-1; for(int jj=0;jj&lt;m+k;jj++)&#123; if(node[jj].flag==0)//只能替换存在的 continue; if(node[jj].time&lt;mintime)&#123; mintime=node[jj].time; minjj=jj; &#125; &#125; //决定了要被替换的为node[minjj] //先看idle中的空闲块没用满的情况 //则新来的直接进空闲块 int flag1=-1; for(list&lt;idle_bar&gt;::iterator it=idle.begin();it!=idle.end();it++)&#123; //空闲块 if(it-&gt;what==-1)&#123; node[it-&gt;which].flag=1; node[it-&gt;which].No=now_req; node[it-&gt;which].time=i; idle.erase(it);//idle链表上删去这个空闲块 idle_bar temp; temp.what=node[minjj].No; temp.which=minjj; idle.push_back(temp);//被替换下来的进idle node[minjj].flag=0; flag1=1; break; &#125; &#125; if(flag1==1)&#123; for(int ii=0;ii&lt;m+k;ii++) if(node[ii].flag==1)printf("%d ",node[ii].No); cout&lt;&lt;endl; continue;//空闲替换成功 &#125; 请求不在于物理块中，当前空闲链表中不存在空物理块 1234567891011121314151617181920//idle中已经没有空闲块的情况 //需要替换链首块的内容 //将now_req放入此时idle链首的块里，原来链首的内容被彻底移出内存块 //根据fifo提出新的块放入idle中 int head=idle.begin()-&gt;which; node[head].flag=1; node[head].time=i; node[head].No=now_req; idle.pop_front();//移出队首 idle_bar temp; temp.what=node[minjj].No; temp.which=minjj; idle.push_back(temp);//被替换下来的进idle node[minjj].flag=0; for(int ii=0;ii&lt;m+k;ii++) if(node[ii].flag==1)printf("%d ",node[ii].No); cout&lt;&lt;endl;&#125; 在所有页面置换算法实现之后，现在来构建页面访问序列随机生成函数。 随机生成算法根据实验的要求，符合局部访问特性的随机生成算法执行步骤如下： 确定虚拟内存的尺寸N，工作集的起始位置p，工作集中包含的页数e，工作集移动率m（每处理m个页面访问则将起始位置p +1），以及一个范围在0和1之间的值t； 生成m个取值范围在p和p + e间的随机数，并记录到页面访问序列串中； 生成一个随机数r，0 ≤ r ≤ 1； 如果r &lt; t，则为p生成一个新值，否则p = (p + 1) mod N； 如果想继续加大页面访问序列串的长度，请返回第2步，否则结束。 根据以上思想，可以编写如下生成函数：123456789101112131415161718192021222324252627282930313233343536373839// 页面访问序列随机生成/* 虚拟内存大小：16位=64K 工作集的起始位置p， 工作集中包含的页数e， 工作集移动率m（每处理m个页面访问则将起始位置p +1）， 以及一个范围在0和1之间的值t； */void init()&#123; int p = rand() % 64; int m = 8, e = 4; int i, j; double t; t = rand() % 10 / 10.0; for (i = 0; i &lt; 4; i++) &#123; //生成m个取值范围在p和p + e间的随机数，并记录到页面访问序列串中； for (j = i * m; j &lt; (i + 1) *m; j++) &#123; req temp; temp.request = (p + rand() % e) % 64; temp.modify = rand()%2;//被随机修改，只针对clock算法 re.push_back(temp); &#125; //生成一个随机数r，0 ≤ r ≤ 1； double r = (rand() % 10) / 10.0; //如果r &lt; t，则为p生成一个新值，否则p = (p + 1) mod N if (r&lt;t) &#123; p=rand()%64; &#125; else &#123; p=(p+1)%64; &#125; &#125;&#125; 测试在准备工作都完毕后，这一节将对各个算法进行测试。 注：1.下列测试均认为预设页面不算做缺页2.‘X’代表当前请求产生缺页中断3.应用PBA算法时，既不在驻留集也不在空闲链表上时才认为缺页 生成访问序列首先调用init()函数，生成符合局部访问特性的随机序列123序列1:42 44 43 42 42 42 45 43 45 46 46 45 45 43 44 44 46 45 45 44 46 47 44 44 48 47 47 45 45 48 48 45序列2:54 56 55 55 54 56 57 55 55 56 56 57 56 58 56 56 59 56 57 56 56 56 59 56 59 57 59 59 60 59 58 57序列3:21 24 22 22 21 23 23 22 23 22 24 24 24 24 24 25 23 26 25 25 24 25 24 24 46 49 48 48 47 47 49 47 下面所有测试均取参数为：12m = 3 // 3个物理块n = 32 // 32个页号请求 FIFO针对序列1，调用FIFO(m,n)，可得到如下执行结果 OPT针对序列1，调用OPT(m,n)，可得到如下执行结果 LRU针对序列1，调用LRU(m,n)，可得到如下执行结果 new clock针对序列1，调用new_clock(m,n)，可得到如下执行结果 PBAPBA的测试与上述四种略有不同，由于其新增了一个空闲链表，故输出格式采用按时间序列输出。 本次测试采用k=2作为参数，即空闲链表上挂有两个空闲物理块。 针对序列1，调用PBA(m,n,k)，可得到如下执行结果 汇总针对序列2和序列3的测试结果此处不作详细展示下面对基于序列1、2、3应用五种算法的结果作一个汇总 序列1 算法 缺页率 FIFO 0.1875 OPT 0.15625 LRU 0.25 new clock 0.25 PBA 0.125 序列2 算法 缺页率 FIFO 0.21875 OPT 0.15625 LRU 0.28125 new clock 0.3125 PBA 0.125 序列3 算法 缺页率 FIFO 0.25 OPT 0.21875 LRU 0.3125 new clock 0.375 PBA 0.21875 平均缺页率 算法 缺页率 FIFO 0.21875 OPT 0.17708 LRU 0.28125 new clock 0.3125 PBA 0.15625 可以看到，相较之下缺页率最低的页面置换算法为PBA，这也符合实际情况。 另外需要说明的是，在应用new clock算法时，需要人为附加每个请求页的修改位标记，即modify，而另外四种算法则均忽略了修改位，所以单凭该试验结果，并不能说明表现最差的算法为改进型Clock置换算法，只能说明表现较好的算法为PBA和OPT算法。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pintos_project1]]></title>
    <url>%2F2019%2F05%2F16%2Fpintos-project1%2F</url>
    <content type="text"><![CDATA[本次博客将详细解释pintos project1的mission2部分。 首先来回顾一下pintos project1 mission1：在mission1里，我们的主要任务是实现了timer_sleep函数唤醒机制。这里需要说明的是，经过mission1之后，我们应该明白，pintos操作系统并不是一个空白的系统：它要求我们做的东西，大部分都已经实现了。就比如timer_sleep函数，在我们对其做更为优化的实现时，实际上该函数原本就有一套实现的原理：系统原本是使用busy wait实现的，即线程不停地循环，直到时间片耗尽。 （1）pintos project1 mission2的主要任务是在Pintos中实现优先级调度，需要解决的问题有如下两个，我们将分别对其进行实现。具体的思路为：先看这一部分的test要求我们做什么，然后按照test的内容去做我们的实现。这样的做法是比较高效的。（2）先看除去donation以外的测试。第一个测试priority-fifo的源代码如下。这个测试创建了一个优先级PRI_DEFAULT+2的主线程，并用这个线程创建了16个优先级PRI_DEFAULT+1的子线程，然后把主线程的优先级设置为优先级PRI_DEFAULT，所以现在pintos内有16个优先级PRI_DEFAULT+1的线程和1个优先级PRI_DEFAULT的线程在跑，测试需要把16个线程跑完再结束那一个线程。（3）注意OS中线程是并行执行的，有可能最开始的一个线程在设置完优先级之后立刻结束了，而此时其他线程并未结束，即注释。在线程设置完优先级之后应该立刻重新调度，因此只需要在thread_set_priority()函数里添加thread_yield()函数即可。（4）priority-fifo解决：（5）再看测试priority-preempt。该测试样例创建了一个新的高优先级线程抢占当前线程。需要解决的问题是高优先级对于低优先级的中断和抢占。（6）解决：如果新线程的优先级高于当前线程优先级，调用thread_yield()函数。（7）此时可发现priority-change也过了，查看此测试。这个测试创建了一个新线程并要这个线程立刻调用，然后在降低优先级之后它就不应该继续执行了，这正好对应于之前修改的两处，所以自然能通过测试。（8）上述三个测试解决之后的结果。 （9）接下来的两个测试都是线程同步问题。首先来看priority-seme测试：这个测试创建了10个优先级不等的线程，并且每个线程调用sema_down函数，其他得不到信号量的线程都得阻塞。而每次运行的线程释放信号量时必须确保优先级最高的线程继续执行。（10）解决：显然我们需要修改sema_up。查看semaphore结构体【位置：～/pintos/src/threads/synch.h】，结构体中有一waiters为阻塞队列，而pintos的sema_up设计：只是把waiters最前面的线程取出来加入到ready_list。那么修改方法就是在waiters中取出优先级最高的thread，并yield()。（11）priority-condvar测试：和前面的信号量机制类似，条件变量也维护了一个waiters用于存储等待接受条件变量的线程，那么就修改cond_signal（）函数唤醒优先级最高的线程即可，和priority-sema类似。实质：condition的waiters队列是优先级队列。（12）线程同步问题的阶段结果。 （13）剩下的测试都是有关于优先级捐赠的问题。那么什么是优先级捐赠问题？举例来说：线程A,B,C分别具有1,2,3优先级(数字越大说明优先级越高), 线程A,B目前在就绪队列中等待调度,线程A对一个互斥资源拥有线程锁。而此时,高优先级的线程C也想要访问这个互斥资源,线程C只好在这个资源上等待,不能进入就绪队列。当调度器开始调度时,它只能从A和B中进行选择,根据优先级调度原理,线程B将会首先运行。这时就产生了一个问题, 即本来线程C优先级比线程B高,但是线程B却先运行了,从而产生了优先级翻转问题。（14）怎么解决这个问题？ 当发现高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。对于优先级捐赠的这几个测试来说，有两个关键的问题，一是优先级嵌套，另一是因为互斥锁而导致的线程阻塞。并且这一系列的问题的解决并不是独立的。（15）接下来重点讲两个测试的原理。首先是测试priority-donte-multiple：original_thread是优先级为PRI_DEFAULT的线程，然后创建2个锁，接着创建优先级为PRI_DEFAULT+1的线程a，把锁a丢给这个线程的执行函数。这时候线程a抢占式地调用a_thread_func，获取了a这个锁，阻塞。然后original_thread输出线程优先级的msg。然后再创建一个线程优先级为PRI_DEFAULT+2的线程b， 和a一样做同样的操作。好， 然后original_thread释放掉了锁b，此时线程b被唤醒，抢占式执行b_thread_func。然后original再输出msg，a同上。实现思路是：释放一个锁的时候，将该锁的拥有者改为该线程被捐赠的第二优先级，若没有其余捐赠者， 则恢复原始优先级。那么我们的线程必然需要一个数据结构来记录所有对这个线程有捐赠行为的线程。（16）接下来是测试priority-donate-chain：这个测试其实就是一个链式优先级捐赠，本质测试的还是多层优先级捐赠逻辑的正确性。（17）donate的所有测试逻辑整合。（18）接下来是这部分测试的整体实现流程。 （19）最终结果如下。至此，我们实现了mission2里的全部内容。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——算符优先语法分析]]></title>
    <url>%2F2019%2F05%2F12%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面人们常说，对于同一个工程的代码量而言：1C/C++ : JAVA : python = 1000:100:10 前三次在C/C++为主导下创作的作业，代码量明显是一个逐次递增的过程，甚至到实验三的时候，代码量已经破了500大关！我寻思这可不是一个好的趋势，于是赶紧投笔从戎，放下C刀，从军python 人生苦短，我用python！ 目标任务实验项目实现算符优先分析算法，完成以下描述算术表达式的算符优先文法的算符优先分析过程。123G[E]:E→E+T∣E-T∣T T→T*F∣T/F∣F F→(E)∣i 设计说明终结符号i为用户定义的简单变量,即标识符的定义。 设计要求（1）构造该算符优先文法的优先关系矩阵或优先函数；（2）输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果。（3）算符优先分析过程应能发现输入串出错。（4）设计两个测试用例（尽可能完备，正确和出错），并给出测试结果；（5）考虑编写程序根据算符优先文法构造算符优先关系矩阵，并添加到你的算符优先分析程序中。 实验过程由于本次实验切换到了python下，虽然python的语法规范宽泛，没有严格的句式要求，但是为了保证结果的泛用性，我决定采用面向对象编程的方法来组织此次作业。 数据结构在明确好编程思想后，首先需要确定下来的就是如何组织类及类成员，如何存储数据。下面给出算符优先语法分析类class OPG的成员变量/函数及其设计说明： 成员变量 类型 备注 start str 记录文法开始符号 Vt list[str] 记录文法非终结符号集 Vn list[str] 记录文法终结符号集 rule dict{str: list[str]} 记录文法产生式 rule1 dict{str: list[str]} 用N替换rule产生式中的非终结符号，辅助判断最左素短语能否被规约 firstVt dict{str: set()} 记录非终结符号str对应的firstVt集 lastVt dict{str: set()} 记录非终结符号str对应的lastVt集 matrix dict{(str,str): str} 记录优先关系矩阵 成员函数 类型 备注 __init__(self,start,Vn,Vt,rule) class OPG 类的构造函数，通过输入文法的开始符号、非终结符/终结符号集、产生式规则从而构造并返回OPG类 get_firstVt(self) void 自动生成所有非终结符对应的firstVt集 get_lastVt(self) void 自动生成所有非终结符对应的lastVt集 get_matrix(self) void 自动生成优先关系矩阵 get_assistrule(self) void 生成辅助规则集合rule1 can_statute(self,test) bool 判断字符串test能否被规约 compile(self,test) bool 判断输入程序是否满足算符优先文法 自动生成firstVt生成firstVt由函数get_firstVt(self)实现，算法流程如下：其实现代码如下，注释均详细对应上述流程图1234567891011121314151617181920212223242526272829303132333435363738394041424344def get_firstVt(self): # 初始化firstVt self.firstVt = &#123;Vn: set() for Vn in self.Vn&#125; # 初始化辅助栈 stack = [] # 初始化辅助布尔判断函数 F = dict() # 根据原则①：若有规则U→b…, 或U→Vb…,则b∈FIRSTVT(U) # first -&gt; right for left in self.firstVt: for right in self.rule[left]: # U→b… if(right[0] in self.Vt): self.firstVt[left].add(right[0]) stack.append((left, right[0])) F[(left,right[0])] = True # U→Vb… elif(len(right)&gt;1 and right[0] in self.Vn and right[1] in self.Vt): self.firstVt[left].add(right[1]) stack.append((left, right[1])) F[(left, right[1])] = True # 根据原则②：若有规则U→V…,且b ∈FIRSTVT(V)，则b ∈FIRSTVT(U) while(len(stack)&gt;0): # 弹出栈顶元素,记(V,b) V,b = stack.pop() for left in self.Vn: for right in self.rule[left]: # 对每一个形如U→V…的规则 # U即left if(right[0]==V): # 若F(U,b) 为假,变为真, 进STACK栈 if((left,b) not in F.keys()): F[(left, b)]=True stack.append((left,b)) # 若F(U,b)为真,再循环 if(F[(left,b)]==True): continue # FIRSTVT(U)=&#123;b∣F(U,b)=TRUE&#125; for key in F: self.firstVt[key[0]].add(key[1]) 执行程序的结果如下，可以看出get_firstVt函数已正确执行： 自动生成lastVt生成lastVt由函数get_lastVt(self)实现，流程与生成firstvt几乎相同，只是在规则①和②的地方改为了寻找最后一个或倒数两个字符，算法流程如下：其实现代码如下，注释均详细对应上述流程图1234567891011121314151617181920212223242526272829303132333435363738394041424344def get_lastVt(self):# 初始化lastVtself.lastVt = &#123;Vn: set() for Vn in self.Vn&#125;# 初始化辅助栈stack = []# 初始化辅助布尔判断函数F1 = dict()# 根据原则①：若有规则U→…b, 或U→…bV,则b∈LASTVT(U)# first -&gt; rightfor left in self.firstVt: for right in self.rule[left]: # U→…b if(right[-1] in self.Vt): self.lastVt[left].add(right[-1]) stack.append((left, right[-1])) F1[(left,right[-1])] = True # U→…Vb elif(len(right)&gt;1 and right[-1] in self.Vn and right[-2] in self.Vt): self.lastVt[left].add(right[-2]) stack.append((left, right[-2])) F1[(left, right[-2])] = True# 根据原则②：若有规则U→…V,且b ∈ LASTVT(V)，则b ∈ LASTVT(U)while(len(stack)&gt;0): # 弹出栈顶元素,记(V,b) V,b = stack.pop() for left in self.Vn: for right in self.rule[left]: # 对每一个形如U→…V的规则 # U即left if(right[-1]==V): # 若F(U,b) 为假,变为真, 进STACK栈 if((left,b) not in F1.keys()): F1[(left, b)]=True stack.append((left,b)) # 若F(U,b)为真,再循环 if(F1[(left,b)]==True): continue# FIRSTVT(U)=&#123;b∣F(U,b)=TRUE&#125;for key in F1: self.lastVt[key[0]].add(key[1]) 执行程序的结果如下，可以看出get_lastVt函数已正确执行： 自动生成优先关系矩阵生成优先关系矩阵由函数get_matrix(self)实现，根据算法描述，程序需要考虑以下四种字符组合情况： …ab… : Xi = Xi+1 …aVb… : Xi = Xi+2 …aU… : a &lt; firstvt(U) …Ub… : lastvt(U) &gt; b 对所有产生式中的规则而言，其均满足上述四种情况中的一种，其实现程序如下：1234567891011121314151617181920212223242526272829303132333435def get_matrix(self): # 用字典映射来记录算符优先关系（横，纵）-&gt; '&gt;、&lt;、=' self.matrix = dict() # left -&gt; right for left in self.Vn: for right in self.rule[left]: for i in range(len(right)-1): # ...ab... : Xi = Xi+1 if(right[ i ] in self.Vt and right[i + 1] in self.Vt): self.matrix[(right[i], right[i + 1])] = '=' # ...aVb... : Xi = Xi+2 if(i&lt;len(right)-2 and right[i] in self.Vt and right[i+2] in self.Vt): self.matrix[(right[i], right[i + 2])] = '=' # ...aU... : a &lt; firstvt(U) if(right[i] in self.Vt and right[i+1] in self.Vn): for b in self.firstVt[right[i+1]]: self.matrix[(right[i], b)] = '&lt;' # ...Ub... : lastvt(U) &gt; b if(right[i] in self.Vn and right[i+1] in self.Vt): for a in self.lastVt[right[i]]: self.matrix[(a, right[i+1])] = '&gt;' # 处理：'#' # '#' &lt; firstvt(S) # '#' &lt; lastvt(S) # '(#,#)'='=' for item in self.firstVt[self.start]: self.matrix[('#',item)]='&lt;' for item in self.lastVt[self.start]: self.matrix[(item,'#')]='&gt;' self.matrix[('#','#')]='=' 最后别忘了对#的处理，由于#只出现在拓广文法S-&gt;\#E\#中，所以可以直接应用上述第2、3、4种情况下的对应处理方法，即： # = # # &lt; firstVt[E] lastVt[E] &gt; # 程序的执行结果如下，可以看到优先关系矩阵的详细信息： 判断能否规约在分析OPG分析过程中，涉及到一步：对于找到的最左素短语，应判断是否存在产生式规则能对其进行规约。由于在分析过程中，非终结符均被N所替代，所以首先要调用get_assistrule(self)将rule中非的终结符用N来替换，生成辅助规则集rule1，以便检查规约。get_assistrule(self)的代码如下：1234567891011def get_assistrule(self): self.rule1 = &#123;key : list() for key in self.rule.keys()&#125; for key in self.rule.keys(): for right in self.rule[key]: right1="" for c in range(len(right)): if (right[c] in self.Vn): right1+='N' else: right1+=right[c] self.rule1[key].append(right1) 在替换完成后，我们便可根据rule1来进行规则的匹配，对于传入的最左素短语test而言，调用函数can_statute(self,test)即可给出判断结果，代码如下：1234567# 判断最左素短语能否规约def can_statute(self,test): for key in self.rule1: for right in self.rule1[key]: if(test==right): return True return False 主分析在上述准备工作都完成后，接下来便可以开始我们的主分析流程。主分析对应函数compile(self,test)，其功能为：对于传入的程序串test，可以给出其对于算符优先文法的判别结果，如果出错可以返回出错分析结果。算法的处理流程如下：总而言之，分析流程的思想为，先找到一个符号串满足如下约束：$$a_j&lt; a_j+1 = a_j+2 = … a_i &gt; R$$其中: R为即将输入的字符，a为分析栈中的字符如果找到了这样的字符串，说明此时我们已经找到了分析栈中待规约的最左素短语$a_j-1…a_i$。如果其能规约，只需将这一串字符替换为N；如果不能规约，说明其不满足该文法下的算符优先语法，即出错。 主分析的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273def compile(self,test): # 分析栈 analyse_stack = ['#'] i = 0 j = 0 # j+1到i记录最左素短语 k = -1 # i记录输入串下标 while(True): k = k+1 # 数组越界则为出错 if(k&gt;len(test) or i&gt;len(analyse_stack) or j&gt;len(analyse_stack)): print("[error] 输入串格式不满足算符文法格式") return False R = test[k] # R记录输入串下一个要输入的字符 while(True): # 寻找非终结符 if(analyse_stack[i] in self.Vt): j = i else: j = i-1 # S(j),R 无优先关系 if((analyse_stack[j],R) not in self.matrix.keys()): print("[error] \'" + analyse_stack[j] + "\',\'" + R + "\' 无优先关系") return False # S(j)&lt;R 或 S(j)=R if(self.matrix[(analyse_stack[j],R)]!='&gt;'): i = i+1 if(i&gt;=len(analyse_stack)): analyse_stack.append(R) else: #analyse_stack.append(R) analyse_stack[i]=R break # S(j)&gt;R while(True): # Q=S(j) Q = analyse_stack[j] j = j-1 if(analyse_stack[j] not in self.Vt): j = j-1 # S(j),Q 无优先关系 if ((analyse_stack[j], Q) not in self.matrix.keys()): print("[error] \'" + analyse_stack[j] + "\',\'" + Q + "\' 无优先关系") return False # S(j)&lt; Q &gt;R temp=self.matrix[(analyse_stack[j],Q)] if(temp=='&lt;'): break # 检验最左素短语是否能规约 item = j+1 the_left="" while(item&lt;=i): the_left += analyse_stack[item] item+=1 if(self.can_statute(the_left)): for c in range(j+2,i+1): analyse_stack.pop() i = j+1 analyse_stack[i] = 'N' else: print("无法规约："+the_left) return False # 成功 if(i==1 and R=='#'): return True 测试分析基于题设要求，输入文件为词法分析器的输出结果，类似如下格式： 我共选用了两组五个测试样例对模型进行了测试，包括两正三负： 正确样例 错误样例模型可检测出不满足产生式的句型：模型可检测出无优先级的句型：模型可检测出包含未定义的符号（即无优先级）的句型： 总结到此，本次算符优先实验已全部完成。我的模型具有如下优点： 根据产生式规则自动生成firstVt集合 根据产生式规则自动生成lastVt集合 根据产生式规则自动生成优先关系矩阵 可以分析多种出错原因 面向对象的思想，模型泛化能力强。只需要改变输入规则集，其可以应对一切算符优先文法。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——LL(1)语法分析器]]></title>
    <url>%2F2019%2F05%2F02%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94LL-1-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实验项目实现LL(1)分析中控制程序（表驱动程序）;完成以下描述赋值语句的LL(1)文法的LL(1)分析过程。123456789S→V=EE→TE′E′→ATE′|εT→FT′T′→MFT′|εF→ (E)|iA→+|-M→*|/V→i 设计说明终结符号i为用户定义的简单变量，即标识符的定义 设计要求（1）输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果；（2）LL(1)分析过程应能发现输入串出错；（3）设计两个测试用例（尽可能完备，正确和出错），并给出测试结果；（4）考虑根据LL(1)文法编写程序构造LL（1）分析表，并添加到你的LL（1）分析程序中。 设计思路总数据流LL(1)语法分析器的实现相比递归下降而言复杂了很多，但概括起来程序的实现总共需要如下几步： 构造非终结符的First集 构造非终结符的Follow集 根据First集和Follow集构造LL(1)分析表 根据分析表构造分析栈逐个匹配 所以流程如下： 存储结构在总数据流确定之后，可以发现在分析过程中涉及到很多辅助量，例如各个非终结符对应的First集。而设置怎样的数据结构来存储这些辅助量是一个在程序编写之前就应该确定下来的问题。下面给出我在程序编写中所预设的数据结构： table th:first-of-type { width: 100px; } 变量名 类型 含义 rule map&lt;string,vector&gt; 记录产生式规则: string→{string,string...} first map&lt;char,set&gt; 记录各个非终结符号对应的first集 follow map&lt;char,set&gt; 记录各个非终结符号对应的follow集 Vt set&lt;char> 记录终结符集合Vt Vn set&lt;char> 记录非终结符集合Vn start char 文法开始符号 point struct Point{char vt; char vn} 记录分析表坐标 table map&lt;point,string&gt; LL(1)分析表：point[坐标]→string[对应动作] file_tuple typedef struct {int code; char symbol} 记录输入的二元组,code:编码,symbol:符号 file_text vector&lt;file_tuple&gt; 存储整个输入文件 在存储结构确定之后，我们便可以着手落实LL(1)语法分析器的实现了，首先从first集的构造开始。 自动构造first集首先需要对first集有一个理性的定义： $$first(α)=\lbrace a| α=^*&gt;aδ,且a∈V_t,δ∈V^* \big\rbrace (若α=^*&gt;ε,则ε∈first(α)\big)$$ first集的构造有确定的算法，算法的描述如下： 若x∈Vt, 则FIRST(x)={x}若X∈Vn, 有X→aα,(a∈Vt)或/和X→ε,则a或/和ε∈FIRST(x)对X→Y1Y2…….Yk(且Y1∈Vn), 反复使用以下直到每一个FIRST(X)不再增大为止. i. 若Y1 ∈Vn,则把FIRST(Y1 )\ {ε}元素加入FIRST(X)中ii. 若Y1、Y2、……Y i-1 ∈Vn (2≤i ≤k),且ε ∈FIRST(Yj) (1≤j≤i-1),则把FIRST(Yi)\ {ε}元素加入FIRST(x)中iii. 若Y1、Y2、……Yk ∈Vn,且ε∈FIRST(Yj)(1≤j≤k),则把ε元素加入FIRST(x)中 用代码实现这样抽象的算法并不是一件简约的事情，下面是构造first集的代码，其中各个步骤都标有详细的注释，分别对应上述算法中的各个步骤：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110void make_first()&#123; //初始化first集 for(set&lt;char&gt;::iterator it = Vn.begin();it!=Vn.end();it++)&#123; set&lt;char&gt;t; first.insert(make_pair(*it,t)); &#125; //遍历规则rule //2.若X∈Vn,有X→aα,(a∈Vt)或/和X→ε 则a或/和ε∈FIRST(x) for(map&lt;string,vector&lt;string&gt;&gt;::iterator it=rule.begin();it!=rule.end();it++)&#123; //用tempp记录it-&gt;first对应的first集 set&lt;char&gt; tempp; //left -&gt; right vector&lt;string&gt; right=it-&gt;second; string left=it-&gt;first; for(int i=0;i&lt;right.size();i++)&#123; // X-&gt;aα (a∈Vt) a即right[i][0] if(Vt.count(right[i][0])!=0)&#123; tempp.insert(right[i][0]); &#125; // X→ε 则ε∈FIRST(x) if(right[i]==" ")&#123; tempp.insert(' '); &#125; &#125; if(first.at(*left.c_str()).size()==0)&#123; first.at(*left.c_str())=tempp; &#125; else first.at(*left.c_str()).insert(tempp.begin(),tempp.end()); &#125; //循环结束条件： 直到每一个FIRST(X)不再增大为止 //3.对X→Y0Y1…….Yk(且Y0 ∈Vn), 反复使用以下直到每一个FIRST(X)不再增大为止 set&lt;char&gt; temp[9]; int k=0,first_size=0; for(map&lt;string,vector&lt;string&gt;&gt;::iterator it=rule.begin();;it++,k++)&#123; //用temp[k]记录it-&gt;first对应的first集 //set&lt;char&gt; temp; //left -&gt; right vector&lt;string&gt; right=it-&gt;second; string left=it-&gt;first; //3.对X→Y0Y1…….Yk(且Y0 ∈Vn), 反复使用以下直到每一个FIRST(X)不再增大为止 bool flag=true;//检测连续含&#123;ε&#125;的Yj for(int i=0;i&lt;right.size();i++)&#123; for(int j=0;j&lt;right[i].size()&amp;&amp;(Vn.count(right[i][j])&gt;0)&amp;&amp;flag;j++)&#123; //FIRST(Yj) set&lt;char&gt; temp1=first.at(right[i][j]); //i 若Y0∈Vn 则把FIRST(Y0)\&#123;ε&#125;元素加入FIRST(X)中 if(j==0)&#123; //\&#123;ε&#125; if(temp1.count(' ')&gt;0)&#123; temp1.erase(' '); &#125; //Y0不含&#123;ε&#125; else&#123; flag=false; &#125; //FIRST(Y0)\&#123;ε&#125; temp[k].insert(temp1.begin(),temp1.end()); &#125; /* ii 若Y1、Y2、……Y i-1 ∈Vn(2≤i ≤k) 且ε ∈FIRST(Y j) (1≤j ≤i-1) 则把FIRST(Yi )\&#123;ε&#125;元素加入FIRST(x)中 */ else if(j&lt;right[i].size()-1)&#123; //Y0...Yj-1含&#123;ε&#125; if(temp1.count(' ')&gt;0)&#123; temp1.erase(' '); &#125; //Yj不含&#123;ε&#125; else&#123; flag=false; &#125; //FIRST(Yj)\&#123;ε&#125; temp[k].insert(temp1.begin(),temp1.end()); &#125; /* iii 若Y0、Y1、……Yk ∈Vn且ε ∈FIRST(Yj)(0≤j ≤k) 则把ε元素加入FIRST(x)中 */ else&#123; temp[k].insert(' '); &#125; &#125; &#125; if(first.at(*left.c_str()).size()==0)&#123; first.at(*left.c_str())=temp[k]; &#125; else first.at(*left.c_str()).insert(temp[k].begin(),temp[k].end()); //跳出条件 if(k==first.size()-1)&#123; int cnt=0; //求和，观察first集有无增大 for(int kk=0;kk&lt;=k;kk++)&#123; cnt+=temp[kk].size(); &#125; //和上一次大小一样，循环终止 if(cnt==first_size) break; //重新循环 else&#123; k=0; it=rule.begin(); first_size=cnt; &#125; &#125; &#125;&#125; 自动构造follow集在构造完first集之后，下一步便可进入到follow集的构造。当然顺序不是我规定的，但是follow集必须在first集构造完后构造，因为其算法描述是基于first集所定义的。follow集的定义如下： $$follow(A)= \lbrace a| S=^*&gt;αAaδ,且a∈V_t,α,δ∈V^* \rbrace \big(若S=^*&gt;αA,则 \sharp∈follow(A)\big)$$ 当然，也存在构造follow集的成熟算法，算法描述为： i. 置FIRST(α)={ }ii. FIRST(X1)\ {ε}加入FIRST(α)iii. 若ε ∈ FIRST(X1),则FIRST(X2)\ {ε}加入FIRST(α)&emsp;&nbsp;若ε ∈ FIRST(X1)且ε ∈ FIRST(X2),则FIRST(X3)\ {ε}加入FIRST(α) ……..以此类推&emsp;&nbsp;若ε ∈ FIRST(Xi) 1≤ i ≤n 则ε ∈ FIRST(α) 在定义和算法都描述清晰之后，下一步需要把算法细化为代码实现。follow集的实现与first集的实现大同小异，代码如下，其中各个步骤都标有详细的注释，分别对应上述算法中的各个步骤：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void make_follow()&#123; //初始化follow集 for(set&lt;char&gt;::iterator it = Vn.begin();it!=Vn.end();it++)&#123; set&lt;char&gt;t; //令#∈FOLLOW(S) S为文法开始符号 if(*it==start) t.insert('#'); follow.insert(make_pair(*it,t)); &#125; //遍历规则rule //2.对A→ αBβ,且β ≠ε, 则将 FIRST(β)\&#123;ε&#125;加入FOLLOW(B)中 for(map&lt;string,vector&lt;string&gt;&gt;::iterator it=rule.begin();it!=rule.end();it++)&#123; //left -&gt; right vector&lt;string&gt; right=it-&gt;second; string left=it-&gt;first; //对每个left遍历 for(int i=0;i&lt;right.size();i++)&#123; //对left的每一个规则遍历 for(int j=0;j&lt;right[i].size();j++)&#123; //找到B所在：right[i][j] if(Vn.count(right[i][j])!=0)&#123; set&lt;char&gt; tt; //β属于Vt if(Vt.count(right[i][j+1])!=0)&#123; tt.insert(right[i][j+1]); follow.at(right[i][j]).insert(tt.begin(),tt.end()); &#125; //β属于Vn,FIRST(β)\&#123;ε&#125;加入FOLLOW(B)中 if(Vn.count(right[i][j+1])!=0)&#123; tt=first.at(right[i][j+1]); tt.erase(' '); follow.at(right[i][j]).insert(tt.begin(),tt.end()); &#125; &#125;//找到B所在：right[i][j] &#125;//对left的每一个规则遍历 &#125;//对每个left遍历 &#125;//遍历规则rule // 3.反复, 直至每一个FOLLOW(A)不再增大 // 对A→ αB或A→ αBβ(且ε ∈ FIRST(β)) // 则FOLLOW(A)中的全部元素加入FOLLOW(B) int k=0; int follow_size=0;//记录follow集的大小 for(map&lt;string,vector&lt;string&gt;&gt;::iterator it=rule.begin();;it++,k++)&#123; //left -&gt; right vector&lt;string&gt; right=it-&gt;second; string left=it-&gt;first; //对每个left遍历(一个left对应多个规则) for(int i=0;i&lt;right.size();i++)&#123; //对left的每一个规则遍历（一个规则对应多个字符） for(int j=0;j&lt;right[i].size();j++)&#123; //找到B所在：right[i][j] if(Vn.count(right[i][j])!=0)&#123; set&lt;char&gt; tt; //到规则的最后一个字符 if(j==right[i].size()-1)&#123; //最后一个字符是Vn，即A→αB，则FOLLOW(A)中的全部元素加入FOLLOW(B) tt=follow.at(*left.c_str()); follow.at(right[i][j]).insert(tt.begin(),tt.end()); &#125; //没到最后一个,即A→ αBβ(且ε∈FIRST(β)) 这种情况 else&#123; bool flag=true; //检索ε∈FIRST(β)是否成立 for(int jj=j+1;jj&lt;right[i].size()&amp;&amp;flag;jj++)&#123; //right[i][jj]是Vn且包含ε if(Vn.count(right[i][jj])!=0&amp;&amp;first.at(right[i][jj]).count(' ')!=0)&#123; continue; &#125; //right[i][jj]不是Vn或不包含ε else&#123; flag=false; &#125; &#125; //A→ αBβ(且ε∈FIRST(β))情况满足 if(flag)&#123; tt=follow.at(*left.c_str()); follow.at(right[i][j]).insert(tt.begin(),tt.end()); &#125; &#125; &#125;//找到B所在：right[i][j] &#125;//对left的每一个规则遍历 &#125;//对每个left遍历 //跳出条件 if(k==follow.size()-1)&#123; int cnt=0; for(map&lt;char,set&lt;char&gt;&gt;::iterator it1=follow.begin();it1!=follow.end();it1++)&#123; cnt+=it1-&gt;second.size(); &#125; //和上一次大小一样，循环终止 if(cnt==follow_size) break; //重新循环 else&#123; k=0; it=rule.begin(); follow_size=cnt; &#125; &#125;//跳出条件 &#125;&#125; 自动生成LL(1)分析表在first集和follow集都构造好之后，我们的前期准备工作已经进入到了最后阶段现在我们需要做的就是：根据first集和follow集来构造LL(1)分析表分析表的横坐标由终结符Vt构成，纵轴由非终结符Vn构成，坐标点的内容为对横纵坐标组合所采取的产生式动作。 由每一个产生式A→α1|α2|...|αn确定M[A,a]矩阵，a∈Vt，分析表M的定义如下： i. 任何a∈FIRST(αi),置M[A, a]=“pop,push(αi′)”,α′为α倒置 或将A→αi 规则填入M[A, a]ii. 若ε ∈ FIRST(αi),则对于任一个b∈FOLLOW(A),b∈Vt或#,置M[A, b]=“pop”或将A → ε规则填入M[A,b],此时b不属于FIRST(A)iii. 其它空白为出错 根据分析表的算法描述，可以编写出如下的代码，其中各个步骤都标有详细的注释，分别对应上述算法中的各个步骤：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void make_table()&#123; string action; //纵轴遍历Vn for(set&lt;char&gt;::iterator it1=Vn.begin();it1!=Vn.end();it1++)&#123; //横轴遍历Vt for(set&lt;char&gt;::iterator it2=Vt.begin();it2!=Vt.end();it2++)&#123; //结构体t（vn，vt）来记录坐标 point t; t.vn=*it1; t.vt=*it2; action=""; //如果it2是it1的first集元素:it2∈first(it1) if(first.at(t.vn).count(t.vt)!=0)&#123; //本应有一步动作：查询it2是it1哪一个规则的first集元素 string v= &amp;t.vn;//将it1转化为string类型 vector&lt;string&gt; Trule; Trule=rule.at(v.substr(0,1)); //剔除空产生式 int T=0; for(vector&lt;string&gt;::iterator it=Trule.begin();T&lt;Trule.size();it++,T++)&#123; if(*it==" ") Trule.erase(it); &#125; if(Trule.size()&gt;1)&#123; for(int ii=0;ii&lt;Trule.size();ii++)&#123; //空动作不管 if(Trule[ii]==" ") continue; //产生式的第一个即为vt，则必定为其first集 if(Trule[ii].find(t.vt)!=string::npos)&#123; action=Trule[ii]; break; &#125; &#125; &#125; else action = rule.at(v.substr(0,1))[0];//直接拿第一个规则，因为第二个规则即末尾规则肯定为it1-&gt;ε table.insert(make_pair(t, action)); &#125; //如果it2是it1的follow集元素:it2∈follow(it1),且若ε ∈ FIRST(it1) else if(first.at(t.vn).count(' ')!=0&amp;&amp;follow.at(t.vn).count(t.vt)!=0)&#123; action="pop"; table.insert(make_pair(t, action)); &#125; //对应分析表中的空白，即出错 else&#123; action="-1"; table.insert(make_pair(t, action)); &#125; &#125;//横轴遍历Vt //纵轴添加一个‘#’ point t1; t1.vn=*it1; t1.vt='#'; //添加条件：Vn-&gt;ε 且 ‘#’ ∈ follow(Vn) if(first.at(t1.vn).count(' ')!=0&amp;&amp;follow.at(t1.vn).count(t1.vt)!=0)&#123; action="pop"; table.insert(make_pair(t1, action)); &#125; //对应分析表中的空白，即出错 else&#123; action="-1"; table.insert(make_pair(t1, action)); &#125; &#125;//纵轴遍历Vn&#125; 代码中的action变量记录各种情况下应该采取的动作，即M[A,a]此外，对于空白，算法的描述为错误，代码这里将空白描述为action=‘-1’来代表出错。 到此，我们的first集、follow集和分析表已经全部构造完毕！ 构造分析栈准备工作全部完成之后，接下来便是构造分析栈来对输入二元组进行语法分析。分析的算法流程描述如下： 其中start为文法开始符号 测试选用两组用例包含两错两对，测试结果如下： 正确样例对于i=i+i，编译结果为：对于i=i*i/i，编译结果为： 错误样例对于i=i+-，编译结果为：对于i=i*i/)，编译结果为：可以看到，语法分析器可以正确实现其功能！ 优点 通过文件输入规则，自动纳入规则集 自动构造first集 自动构造follow集 自动构造LL(1)分析表 通过文件输入二元组，自动输出判别结果 总结对于这种具有多个复杂存储结构的实验，一定要在事先理清楚各个变量的数据结构的意义，否则很容易陷入迷惑。此外在c++中需要尽量避免char类型和string类型的混合使用，尽管string提供了c_str方法，但其返回值为char*，在循环时很容易造成指针错误，所以要谨慎使用！]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——递归下降语法分析器]]></title>
    <url>%2F2019%2F05%2F01%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实验项目完成以下描述赋值语句的LL(1)文法的递归下降分析程序123456789S→V=EE→TE′E′→ATE′|εT→FT′T′→MFT′|εF→ (E)|iA→+|-M→*|/V→i 设计说明终结符号i为用户定义的简单变量，即标识符的定义 设计要求（1）输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果，输出为输入串是否为该文法定义的算术表达式的判断结果；（2）递归下降分析程序应能发现简单的语法错误；（3）设计两个测试用例（尽可能完备，正确和出错），并给出测试结果 设计思路接收输入词法分析器输出文件由设计要求中的（1）可知，语法分析器所能接受的输入为词法分析器所输出的二元组首先我们来回顾一下词法分析器所输出的二元组的格式：可以看到，语句i=i+i)对应的词法分析输出二元组格式为：&lt;number,token&gt;的格式 number：编码数字token：符号/字符串 显然，我们可以通过一个结构体来接受词法分析器所输入的二元组！ 数据存储结构我构造的结构体如下：12345//记录词法分析器生成的二元组typedef struct &#123; int num; string token;&#125;two; 考虑到语句长度总是变化的，所以为了提高程序的鲁棒性，总的数据结构应定义为可变数组：12//记录全部的二元组vector&lt;two&gt; text; 到此，数据储存结构的准备工作1已全部完成。 构造执行函数根据递归下降分析的思想，我们首先需要对所有非终结符对应的产生式构造执行函数。再者，根据设计要求，我们在进行字符匹配时仅使用编码two-&gt;num进行匹配即可 编码映射在本题中所使用到的主要编码如下： 字符 编码 # -1 id 10 = 18 + 19 - 21 * 23 / 24 ( 27 ) 28 S()对产生式：S→V=E，可以得到如下的递归调用流程。 由词法分析器的编码可知，match（18）中的18代表字符= E()对产生式：E→TE′，可以得到如下的递归调用流程。 E’()对产生式：`E′→ATE′|ε，可以得到如下的递归调用流程。 由于产生式包含空动作E′→ε，所以在程序执行时需要判断是否读到E’的follow集元素，其中编码28代表字符)，编码-1代表字符#。 T()对产生式：T→FT′，可以得到如下的递归调用流程。 T’()对产生式：T′→MFT′|ε，可以得到如下的递归调用流程。 由于产生式包含空动作T′→ε，所以在程序执行时需要判断是否读到E’的follow集元素，其中编码19代表字符+，编码21代表字符-，编码28代表字符)，编码-1代表字符#。 F()对产生式：F→ (E)|i，可以得到如下的递归调用流程： 10代表用户定义标识符，27代表字符（，28代表字符） A()对产生式：A→+|-，可以得到如下的递归调用流程： 19代表字符+，21代表字符- M()对产生式：M→*|/，可以得到如下的递归调用流程： 23代表字符*，24代表字符/ V()对产生式：V→i，可以得到如下的递归调用流程： 10代表用户定义标识符 测试正确用例对于语句：1i = i + i 编译结果为： 对于语句：1i = i * (i/i) 编译结果为： 错误用例对于语句：1i = i + i ） 编译结果为： 对于语句：1i = i + - 编译结果为： 至此，该递归下降语法分析器已全部符合题目要求]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——语法分析G[]]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90G-%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目描述本次选做题需要实现一个简单的语法分析器，其文法描述如下： &lt;程序&gt;→begin &lt;语句&gt; end &lt;语句&gt;→&lt;赋值语句&gt;│&lt;条件语句&gt; &lt;赋值语句&gt;→&lt;变量&gt;:=&lt;表达式&gt; &lt;条件语句&gt;→if &lt;表达式&gt; then &lt;语句&gt; &lt;表达式&gt;→&lt;表达式&gt;+&lt;变量&gt;│&lt;变量&gt; &lt;变量&gt;→i 消除左递归一目了然就可以看到，产生式：&lt;表达式&gt;→&lt;表达式&gt;+&lt;变量&gt;│&lt;变量&gt;存在左递归。所以第一步要做的是消除左递归，消除结果为： &lt;表达式&gt;→&lt;变量&gt;&lt;表达式1&gt; &lt;表达式1&gt;→+&lt;变量&gt;&lt;表达式1&gt;|ε 到此，文法中的左递归已经完全消除，且满足LL(1)文法。 重命名为了便于编程，下面对文法中的非终结符用单词替换，如下： program 程序 statement 语句 assign 赋值语句 condition 条件语句 expression 表达式 expression_1 表达式1 variable 变量 程序实现 根据递归下降编程的思想，上述7个非终结符分别对应7个子函数，其实现的流程图分别如下： 其中： match(token)函数的作用是用token与当前扫描到的字符(串)进行匹配，匹配成功则返回true nextsym()函数的作用是使指针item滑动到下一个单词处 program statement assign condition expression expression_1这里需要说明的是，由于产生式&lt;表达式1&gt;→+&lt;变量&gt;&lt;表达式1&gt;|ε中含有&lt;表达式1&gt;→ε，故在匹配时如果没有match到其first集中的元素，则接下来需要去match其follow集中的元素，即“end”和“then”，若与follow集中的元素匹配成功，则指针item需要回滚。 variable 测试我选用了正确和错误的两组共四个测试用例对程序进行了测试，测试结果如下： 正确样例 错误样例 可以看到，程序能够成功识别该文法的语言并给出正确的反馈信息！]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——文件名识别]]></title>
    <url>%2F2019%2F04%2F11%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%90%8D%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[题目思考本次选做题是制作一个文件名的识别程序，其可以识别诸如xx:xx.xx之类的文件名，具体题目要求如下：某操作系统下合法的文件名规则为：device:name.extention,其中第一部分（device:)和第三部分（.extention)可缺省，若device、name和extention都是由字母组成，长度不限，但至少一位。 显然这样的题目要求与词法分析器和无符号数识别类似，按照之前的词法分析器程序的编写思路，首先来构造程序的状态转换图。 状态转换图题目给出了文件名规则：device:name.extention，我们令d代表字母，则该规则可以转化为正则式表示为：d*:d+.d*，其中*和+分别代表0和1次及以上自重复。 从而可以得到如下的状态转换图： 其中：2状态的终结态代表device和extension均缺省的情况，4状态的终结态代表extension缺省的情况，6状态的终结态代表device缺省的情况。 数据流根据上述状态转换图，可以拟定初步的编程数据流图如下： 子程序实现显然，从数据流图中可以看到，功能实现的核心在于函数：int next_state(int current_state,char temp)即根据现在状态以及下一个字符判断下一个状态，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int next_state(int current_state,char temp)&#123; int next=-1; switch (current_state) &#123; case 1:&#123; if(isalpha(temp))&#123; next=2; &#125; else&#123; next=-1; &#125; break; &#125; case 2:&#123; if(isalpha(temp))&#123; next=2; &#125; else if(temp=='.')&#123; next=5; &#125; else if(temp==':')&#123; next=3; &#125; else&#123; next=-1; &#125; break; &#125; case 3:&#123; if(isalpha(temp))&#123; next=4; &#125; else&#123; next=-1; &#125; break; &#125; case 4:&#123; if(isalpha(temp))&#123; next=4; &#125; else if(temp=='.')&#123; next=5; &#125; else&#123; next=-1; &#125; break; &#125; case 5:&#123; if(isalpha(temp))&#123; next=6; &#125; else&#123; next=-1; &#125; break; &#125; case 6:&#123; if(isalpha(temp))&#123; next=6; &#125; else&#123; next=-1; &#125; break; &#125; &#125; return next;&#125; 代码测试在程序完备之后，我对程序选择了如下测试样例进行测试： 可以看到，凡是name缺省的错误文件命名均可以被识别。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git——日常使用]]></title>
    <url>%2F2019%2F04%2F06%2Fgit%E2%80%94%E2%80%94%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天好不容易写完了操作系统，刚想行云流水一波上传到GitHub，结果在最后一步pull的时候报错，给我慌了十分钟的一批，解决完决定记录一下有关的操作流程。 用网页传代码或者文件着实不像一个计算机系学生应有的水准，下面来列支一下每次上传文件的流程。 git init git add . git commit -m &quot;xxx&quot; git push -u origin master 对，没有问题，操作仅仅就这么几步而已，那么我今天遇到的error是什么呢？ 上一次手残把project2的commit写错了，想改发现不能直接在网页端改，所以还是需要依靠命令来修改。 修改的步骤如下： git log：罗列commit记录，每一次commit都对应一个记录编码 git reset --hard xxx：将HEAD强行指向xxx所对应的commit记录 git push -u origin master -f：更新仓库，这一步至关重要，如果缺少了这一步就会导致本地与GitHub端的HEAD指向不匹配，从而报错 至此，平时所需要的的操作就叙述结束了，当然git命令还不止这些，下面这些命令也有可能被用到： git clone https://仓库地址：下载文件到本地 git remote add origin https:// https://github.com/hnjia00/OS2019：这条命令可以与仓库建立联系]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——进程同步]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[本次实验全部基于Ubuntu 16.04完成代码托管于GitHub: https://github.com/hnjia00/OS2019 本次试验的内容核心在于对于信号量的理解和利用，通过信号量的合理配置从而使进程和线程的运行合乎逻辑。 实验目的 系统调用的进一步理解。 进程上下文切换。 同步的方法。 Q1.通过fork的方式，产生4个进程P1,P2,P3,P4，每个进程打印输出自己的名字，例如P1输出“I am the process P1”。要求P1最先执行，P2、P3互斥执行，P4最后执行。通过多次测试验证实现是否正确。 A1.首先需要理清楚进程的逻辑关系，为了使这四个进程满足题目要求的执行顺序，我在程序里使用了三组信号量，分别为sem1，sem2，sem3。 需要注明的是： 为了满足p1最先执行，p2和p3在其后等待，sem1设置了两个信号量，即sem1 = [0,0]。 p2等待p1的信号量sem1[0]，p3等待p1的信号量sem1[1]从而达到在p1之后执行的要求。此外，为了满足p2和p3互斥执行，还定义了一个互斥信号量sem2 = 1，这样p2和p3在等待sem1之后还需要等待sem2以实现互斥执行的要求。 为了满足p4最后执行，即满足p4在p2和p3之后执行，sem3设置了两个信号量，即sem3 = [0,0]。其需要等待p2结束后产生的信号量sem3[0]，以及等待p3结束后产生的信号量sem3[1]，从而实现最后执行的要求，整体逻辑图如下： 在逻辑图实现之后，需要考虑进程的创建关系。 虽然一个父进程能创建若干个子进程，但是一个子进程只能对应一个父进程，也就是说进程的创建不能以信号量逻辑图为基础，因为P4不能对应两个父进程P2和P3。 所以在创建中各个进程所对应的父子关系与信号量逻辑图略有不同。 主程序代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int main(int argc, char *argv[])&#123; pid_t pid1, pid2, pid3; int sem1, sem2, sem3; sem1 = semget(1000, 2, 0666 | IPC_CREAT);//[0,0]，保证p1最先 sem2 = semget(1001, 1, 0666 | IPC_CREAT);//[1],保证p2、p3互斥 sem3 = semget(1002, 2, 0666 | IPC_CREAT);//[0,0]，保证p4最后 //信号量赋值 ushort init_arry[2] = &#123;0, 0&#125;; setSemValues(sem1, init_arry); setSemValue(sem2, 0, 1); setSemValues(sem3, init_arry); pid1 = fork(); if (pid1 &gt; 0) &#123; pid2 = fork(); //p1 if (pid2 &gt; 0) &#123; printf("P1:I am P1\n"); printf("pid,ppid:%d,%d\n",getpid(),getppid() ); signal(sem1,0); signal(sem1,1); sleep(1); &#125; //p4 if(pid2 == 0) &#123; wait(sem3, 0); wait(sem3, 1); printf("P4:I am P4\n"); printf("pid,ppid:%d,%d\n",getpid(),getppid() ); &#125; &#125; if (pid1 == 0) &#123; pid3 = fork(); //p2 if (pid3 &gt; 0) &#123; wait(sem1, 0); wait(sem2, 0); printf("P2:I am P2\n"); printf("pid,ppid:%d,%d\n",getpid(),getppid() ); signal(sem2, 0); signal(sem3, 0); sleep(1); &#125; //p3 if (pid3 == 0) &#123; wait(sem1, 1); wait(sem2, 0); printf("P3:I am P3\n" ); printf("pid,ppid:%d,%d\n",getpid(),getppid() ); signal(sem2, 0); signal(sem3, 1); &#125; &#125; return 0;&#125; 在第一题中，信号量的定义部分我使用了semget()函数，虽然其常用于定义一个单信号量，但我也用到了其定义信号量集的功能（如sem1和sem3），函数注释如下：12345678int semget(key_t key, int num_sems, int sem_flags):功能描述： 创建一个新信号量或取得一个已有信号量参数说明： key:整数值,不相关的进程可以通过它访问一个信号量,它代表程序可能要使用的某个资源 num_sems:指定需要的信号量数目 sem_flags:一组标志,当想要当信号量不存在时创建一个新的信号量,可以和值IPC_CREAT做按位或操作 0666:创建了一个权限为666的信号量,每个人可读和可写 此外，代码中所用到的setSemValues(),setSemValue(),wait(),signal()的具体实现均已托管至GitHub，有兴趣可以进一步一探究竟！ 代码的执行结果如图，可以看到，多次执行均能保证进程次序。 Q2.火车票余票数ticketCount 初始值为1000，有一个售票线程，一个退票线程，各循环执行多次。添加同步机制，使得结果始终正确。要求多次测试添加同步机制前后的实验效果。(说明：为了更容易产生并发错误，可以在适当的位置增加一些pthread_yield()，放弃CPU，并强制线程频繁切换。) A2.从题目可以体会到，这是一个典型的生产者消费者问题，售票线程为消费者，退票线程为生产者，临界资源为火车票余票数ticketCount。 初步分析进一步分析可以得知： 退票线程能够访问临界资源的条件为：火车票余量空间满足退票数目。 售票线程能够访问临界资源的条件为：火车票余量大于0. 有了以上思路后，可以通过设置两个信号量来实现上述功能，两个信号量的介绍如下： empty = 0：记录剩余空间 full = 1000：记录剩余票数 初步实现代码的实现逻辑如下： 为了保证代码和逻辑的鲁棒性，需要在关键代码部分增加pthread_yield()函数来测试代码，对pthread_yield()函数的解释为： pthread_yield() causes the calling thread to relinquish the CPU.The thread is placed at the end of the run queue for its static priority and another thread is scheduled to run. 即pthread_yield（）使调用线程放弃CPU。该线程放在运行队列的末尾，以获得其静态优先级并计划运行另一个线程。 售票线程、退票线程的实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243int ticketCount=1000;//剩余票数int temp;sem_t *empty = NULL;//记录剩余空间sem_t *full = NULL;//记录剩余票数int N_sell;//售票数int N_return;//退票数int pthread_yield(void);//售票void *Psell()&#123; int i=0; for(;i&lt;N_sell;i++)&#123; sem_wait(full); //售票进程关键代码 temp=ticketCount; pthread_yield(); temp=temp-1; pthread_yield(); ticketCount=temp; // printf("[Sell - %d]\n",i+1); sem_post(empty); &#125; printf("[Sell end: total sell:%d]\n",i);&#125;//退票进程void *Preturn()&#123; int i=0; for(;i&lt;N_return;i++)&#123; sem_wait(empty); //退票进程关键代码 temp=ticketCount; pthread_yield(); temp=temp+1; pthread_yield(); ticketCount=temp; // printf("&#123;Return + %d&#125;\n",i+1); sem_post(full); &#125; printf("&#123;Return end: total return:%d&#125;\n",i);&#125; 初步测试对于售票数=30，退票数=7的测试，执行结果如图所示，可以看到在模拟售票30张退票7张时，程序的执行结果正确： 在小规模测试上获得正确结果之后，接下来我将测试级扩大到了10w级别，对于售票数=100000，退票数=99000的测试，程序的结果如下：竟然得到了错误的结果！ 出错分析为了探究出错原因，我将pthread_yield()函数去掉重新执行了代码，这次程序的出了正确的结果： 纠其原因，尽管使用了生产消费者所常用的配套信号量，但仍然不足以克服pthread_yield函数所带来的线程切换。也就是说，尽管通过sem_wait(empty)能控制退票线程Preturn()访问临界区的的入口条件，但即使Preturn()进入了临界区，其也有可能被pthread_yield所强制切换到Psell()售票线程，从而导致临界区被两个线程同时访问，以至于临界资源ticketCount被错误修改！ 所以，为了达到保护临界资源的目的，需要设置互斥信号量！从而保证任意适合只能有一个线程对临界资源进行访问修改。 二次修改修改后的线程逻辑如下： 进而修改线程代码为：123456789101112131415161718192021222324252627282930313233343536373839404142sem_t *mutex = NULL;//互斥信号量//售票void *Psell()&#123; int i=0; for(;i&lt;N_sell;i++)&#123; sem_wait(full); //等待互斥信号 sem_wait(mutex); //售票进程关键代码 temp=ticketCount; //pthread_yield(); temp=temp-1; //pthread_yield(); ticketCount=temp; printf("[Sell - %d]\n",i+1); sem_post(empty); //释放互斥信号 sem_post(mutex); &#125; printf("[Sell end: total sell:%d]\n",i);&#125;//退票进程void *Preturn()&#123; int i=0; for(;i&lt;N_return;i++)&#123; sem_wait(empty); //等待互斥信号 sem_wait(mutex); //退票进程关键代码 temp=ticketCount; pthread_yield(); temp=temp+1; pthread_yield(); ticketCount=temp; printf("&#123;Return + %d&#125;\n",i+1); sem_post(full); //释放互斥信号 sem_post(mutex); &#125; printf("&#123;Return end: total return:%d&#125;\n",i);&#125; 正确执行再次执行上次的测试用例，这次的执行结果为0，即售票-10w,退票+9.9w,初始+0.1w=0，完全正确！ Q3.一个生产者一个消费者线程同步。设置一个线程共享的缓冲区， char buf[10]。一个线程不断从键盘输入字符到buf,一个线程不断的把buf的内容输出到显示器。要求输出的和输入的字符和顺序完全一致。（在输出线程中，每次输出睡眠一秒钟，然后以不同的速度输入测试输出是否正确）。要求多次测试添加同步机制前后的实验效果。 A3.这是一个典型的生产者-消费者问题，思路与第二题相仿，需要两个信号量来辅助实现，信号量的使用情况如下： empty = 5：记录剩余空间 full = 0：记录使用空间 要说明的一点是，为了便于测试debug和结果演示，我将char buf[10]修改为了int buf[5]，一来是缩小规模可以更直观看到演示结果，二来使用int型数组也可以防止回车符的乱入。 由于逻辑与上一题相仿，仅仅是取消了互斥mutex，所以这里不做赘述。 代码实现读入和输出线程的实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041#define N 5int buf[N];//信号量sem_t *empty=NULL,*full=NULL;//T1、T2分别代表输入输出的测试规模int T1=15,T2=15;//in：输入指针，out：输出指针int in=0,out=0;//输入线程void *producer() &#123; int nextp; while(T1--)&#123; sem_wait(empty); printf("%s\n","input: "); scanf("%d",&amp;nextp); buf[in]=nextp; in = (in+1)%N; sem_post(full); &#125; printf("%s\n", "[input]:over"); return NULL;&#125;//输出线程void *consumer() &#123; int nextc; while(T2--)&#123; sem_wait(full); nextc=buf[out]; sleep(1); printf("output:%d\n", nextc); out = (out+1)%N; sem_post(empty); &#125; printf("%s\n", "[output]:over"); return NULL;&#125;empty = sem_open("empty",O_CREAT,0666,5);//记录剩余空间full = sem_open("full",O_CREAT,0666,0);//记录使用空间 测试用例123输入规模：T1=15输出规模：T2=15测试数据：1、2、3...9、0、9、8、7、6、5 正常速度输入对于正常的输入速度，程序的执行结果如下。可以看到，每一个输入下都匹配着正确的输出结果。 快速输入对于快速的输入速度，程序的执行结果如下。可以看到尽管输入提示语句input:看起来有一些“不合位置”，但在两个信号量empty和full的合理使用下，输入输出线程的进入条件会严格受控于缓冲区的剩余空间和已使用空间，十五个数字字符1～0，9～5全被成功输入并得以按顺序依次输出。 去同步机制输入为了测试信号量的作用，这次测试将信号量去掉，重新进行快速输入，结果如下。可以看到对于块长为5的缓冲区，在输入线程的指针in超过输出线程指针out的移动位置后，原先已经被输入但还未来得及输出的字符会被新的输入所覆盖，从而造成输出丢失，进而导致输出持续混乱 Q4.a）通过实验测试，验证共享内存的代码中，receiver能否正确读出sender发送的字符串？如果把其中互斥的代码删除，观察实验结果有何不同？如果在发送和接收进程中打印输出共享内存地址，他们是否相同，为什么？b)有名管道和无名管道通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？c）消息通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？ A4.a) 共享内存功能测试同时开启两个终端，分别启动receiver进程和sender进程，执行操作如下，在sender端键入字符串，且sender端以空格作为一段字符串的分隔标志，可以在receiver段得到sender端所输入的的字符串： 删除互斥在删去信号量后，在接收端会发生输出混乱，具体表现如下：receiver端不会等待sender端的输入情况，其会不加限制的重复输出共享内存中已有的内容： 重新开启进程后，上次程序所写在共享内存区内的字符串仍然会被重复输出： 观察地址重新调回互斥，在sender进程和receiver进程分别添加语句12printf("\n[Sender] address:%p\n", shm_ptr);printf("\n[Receiver] address:%p\n", shm_ptr); 实现打印共享内存的地址，可以观测到如下输出结果，两个进程的共享内存地址并不相同。其原因为：sender进程和receiver进程实现了对共享内存shm_ptr的访问，shm_ptr的物理地址有且唯一，但在程序进程中所查询到的地址并不是shm_ptr的物理地址，而是shm_ptr向进程所映射的虚拟地址，所以这就造成了同一块物理地址在不同的进程中的打印值不同的结果。即：共享内存在每个进程里的映射地址是不同的 b) 管道通信无名管道同步无名管道的代码执行结果如图。无名管道通过定义fd[2]文件描述符数组来实现消息同步：fd[0]描述只读,fd[1]描述只写，从而实现读写同步。但值得注意的是，无名管道是半双工的，就是对于一个管道来讲，只能读，或者写。 无名管道只能在相关的，有共同祖先的进程间使用（即一般用户父子进程），而多进程用同一管道通信容易造成交叉读写的问题。 阻塞在执行open,write,read等操作时会发生阻塞现象。因为管道和文件一样，文件read函数以O_RDONLY方式打开也会阻塞，但是文件数据在本地，读取非常快，感觉不到阻塞，但是管道以O_RDONLY方式打开，会阻塞进程，read()函数会等待管道另一端写入数据，直到另一端关闭文件描述符。更具体的，读写进程的阻塞可归类为下列几类情况： 读进程 写进程 管道无数据 管道有数据 阻塞 return 0 返回数据 阻塞 阻塞等待 读取数据 阻塞 收到SIGPIPE信号，write返回-1 阻塞 写入数据 满则阻塞等待 有名管道同步有名管道的代码执行结果如图。有名管道分别定义了两个进程来实现消息同步：进程fifo_send实现了创建管道、向管道只写数据的功能。进程fifo_rcv实现了查阅管道，从管道中只读数据的功能。通过两个进程对同一管道的只读只写从而实现同步机制。 阻塞有名管道的读写阻塞情况同无名管道。此外，有名管道比无名管道还多一种阻塞情况：通信双方一方不存在则阻塞，如下图所示。 c) 消息队列同步消息队列的代码执行结果如图。消息队列通过server端和client端的配合操作实现消息同步：进程client中创建了两个进程，其中父进程用于接受键盘键入以及发送数据，子进程用于接收server的返回数据并实现输出。进程server中等待接收client端发送的数据，当收到信息后，打印接收到的数据，并原样的返回client端。以上流程通过两个struct msgbuf类型结构体sndBuf,rcvBuf来辅助实现。 阻塞阻塞情况与管道类似，在队列中没有消息时读进程会阻塞，在队列中数据已满时写进程会阻塞。 Q5.阅读Pintos操作系统，找到并阅读进程上下文切换的代码，说明实现的保存和恢复的上下文内容以及进程切换的工作流程。 A5.代码阅读有关关上下文切换的代码位于/threads/switch.h和/threads/switch.S中，这里首先介绍对两个代码的简略阅读。 switch.h头文件代码如下：汇编代码如下： 从CUR（正在运行的线程）切换到NEXT，NEXT也必须运行switch_threads（），在NEXT的上下文中返回CUR。这个函数通过假设我们切换到的线程也在运行switch_threads（）来工作。因此，它所要做的就是在堆栈上保留一些寄存器，然后切换堆栈并恢复寄存器。作为切换堆栈的一部分，我们在CUR的线程结构中记录当前堆栈指针。 线程切换如果一个线程用完了它的时间片，thread_tick就会调用该函数intr_yield_on_return。但是，此时不会产生下一个线程。相反，它修改一个标志，让中断处理程序知道，在从中断返回之前，它应该执行一个上下文切换到另一个线程。 于是，经过thread_tick和timer_interrupt回报，intr_handler将调用thread_yield，它将调用schedule。schedule选择要运行的下一个线程并调用一个函数switch_threads，在x86程序集中实现，带有两个参数:( cur指向thread 当前线程结构的指针，即被抢占next的指针）和（指向下一个thread结构的指针） 线程运行）。 所以，堆栈看起来像这样： 理解switch_threads的关键是要明白，如果切换到另一个线程，那么其他线程switch_threads在被抢占时也必须运行。实际上，一个自愿或非自愿地产生CPU的线程将始终具有类似于以下之一的堆栈： switch_threads后面的所隐含的内容是，要切换到另一个线程，只需要切换堆栈（因为每个线程都保证switch_threads在被抢占的位置运行），我们只需更改esp值就可以做到这一点。 在调用之后switch_threads，堆栈的底部将如下所示： switch_threads堆栈帧（0x0C00）的起始地址是任意的，没有深刻的意义。但是，显示的所有其他值将与从中switch_threads开始的堆栈帧0x0C00一致。 首先，switch_threads需要保存一些寄存器（这是x86架构所要求的）：1234pushl ％ebx pushl ％ebp pushl ％esi pushl ％edi 堆栈结构如下： 接下来，switch.h将SWITCH_CUR和SWITCH_NEXT定义为堆栈帧中的cur和next的偏移量（20和24）。在x86中，表达式SWITCH_CUR(%esp)变为20(%esp)，转换为内存地址esp+20cur。换句话说，这给了我们当前thread（）的地址。类似的，SWITCH_NEXT(%esp)提供了next线程的地址 。 下面一段汇编代码保存当前线程的堆栈指针，并设置esp为指向要运行的下一个线程的（先前保存的）堆栈指针。1234movl SWITCH_CUR （％esp ）， ％eax movl ％esp ， （％eax ，％edx ，1 ）movl SWITCH_NEXT （％esp ）， ％ecx movl （％ecx ，％edx ，1 ）， ％esp 在完成上述操作后，切换线程即完成，剩下的就是恢复之前推入堆栈的寄存器，然后返回switch_threads：12345popl ％edi popl ％esi popl ％ebp popl ％ebx ret 进程切换在理解清楚线程的切换机理后，进程切换也可以类比。 所谓进程切换，其只是线程切换和内核空间与用户空间之间切换的组合。基本上，当一个进程正在运行时，一个定时器中断将控制CPU回到内核，这将导致中断处理过程（最终导致调用thread_tick）。此时，如果我们抢占当前线程（及其关联的进程），我们将切换到不同的内核线程。如果此内核线程与进程关联，我们将切换回用户空间。 主要的区别是，切换到一个新的进程也将涉及调用process_activate从thread_schedule_tail（即运行功能之后switch_threads，但是从中断处理程序返回之前）。process_activate更新CPU的cr3寄存器以指向当前正在运行的进程的页面目录，并将值保存esp到TSS。 其中process_activate源码位于\userprog\process.c,TSS的源码位于\userprog\tss.c，如下所示： 参考文献【1】Linux共享内存实现机制的详解 :https://www.jb51.net/article/118285.htm【2】Linux 进程通信（无名管道）:https://www.cnblogs.com/zhanggaofeng/p/5829801.html【3】Linux进程间通信 – 管道(pipe):https://www.cnblogs.com/Jimmy1988/p/7553069.html【4】Linux进程间通信 – 消息队列:https://www.cnblogs.com/Jimmy1988/p/7699351.html【5】How does thread/process switching work in Pintos?:https://uchicago-cs.github.io/mpcs52030/switch.html]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——无符号数识别]]></title>
    <url>%2F2019%2F04%2F03%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[实现思路无符号数的识别已经在课上做过详细的讲解，其主要实现思想可参考无符号数识别的状态转换图，这里不做赘述。 测试样例程序的测试用例及测试结果如下，可以看到，程序可以正确识别满足格式要求的无符号数，最终以要求格式整数E指数的形式输出。： 代码实现下面来简单列支程序子函数代码 辅助全局变量为了达到识别输入的无符号数的功能，首先需要预设几个全局变量，其变量名及解释如下：1234int w=0;//整数累加器（初值为0）int p=0;//指数累加器（初值为0）int n=0;//十进小数累加器（初值为0）int e=1;//十进指数的符号（初值为1， 遇负号为-1） 子函数：判断是否为无符号数无符号数以string类型变量接收，通过bool isnum(string num)函数来实现判别，即最终状态如果落在1、2、6则为无符号数，函数的实现如下：12345678910111213141516//判断是否为无符号数bool isnum(string num)&#123; int state = 0; int i=0; for(;i&lt;num.size();i++)&#123; char temp = num[i]; state = next_state(state, temp); if(state==-1) return false; &#125; //没有到达终态1、2、6 if(state==3||state==4||state==5) return false; return true;&#125; 子函数：获取下一状态在bool isnum(string num)函数中需要用到另一个辅助函数int next_state(int currentstate,char temp)来求取下一状态，其实现主要依托switch-case架构，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//获取下一个状态及中间量计算结果int next_state(int currentstate,char temp)&#123; int next=-1; switch (currentstate) &#123; case 0:&#123; if(isdigit(temp))&#123; n=0; p=0; e=1; w=(temp-'0'); next=1; &#125; else if(temp=='.')&#123; n=0; p=0; e=1; w=0; next=3; &#125; else next=-1; break; &#125; case 1:&#123; if(isdigit(temp))&#123; w=w*10+(temp-'0'); next=1; &#125; else if(temp=='.')&#123; next=2; &#125; else if(temp=='E'||temp=='e')&#123; next=4; &#125; else next=-1; break; &#125; case 2:&#123; if(isdigit(temp))&#123; w=w*10+(temp-'0'); n=n+1; next=2; &#125; else if(temp=='E'||temp=='e')&#123; next=4; &#125; else next=-1; break; &#125; case 3:&#123; if(isdigit(temp))&#123; n=n+1; w=w*10+(temp-'0'); next=2; &#125; else next=-1; break; &#125; case 4:&#123; if(isdigit(temp))&#123; p=p*10+(temp-'0'); next=6; &#125; else if(temp=='+')&#123; next=5; &#125; else if(temp=='-')&#123; e=-1; next=5; &#125; else next=-1; break; &#125; case 5:&#123; if(isdigit(temp))&#123; p=p*10+(temp-'0'); next=6; &#125; else next=-1; break; &#125; case 6:&#123; if(isdigit(temp))&#123; p=p*10+(temp-'0'); next=2; &#125; else next=-1; break; &#125; &#125; return next;&#125; 主函数至此，无符号数的识别功能全部实现，只需要在主函数中循环接受输入并判断即可。12345678910111213141516171819int main(int argc, const char * argv[]) &#123; while(1)&#123; string num; cout&lt;&lt;"input:"; cin&gt;&gt;num; if(isnum(num))&#123; cout&lt;&lt;"it is an unsigned number～\n"; if(e*p-n!=0&amp;&amp;w!=0) cout&lt;&lt;"the number is:"&lt;&lt;w&lt;&lt;"E"&lt;&lt;e*p-n&lt;&lt;endl&lt;&lt;endl; else cout&lt;&lt;"the number is:"&lt;&lt;w&lt;&lt;endl&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"it isn't an unsigned number!"&lt;&lt;endl&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——初步]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[本次实验全部基于Ubuntu 16.04完成代码托管于GitHub：https://github.com/hnjia00/OS2019/tree/master/Code_Of_project1 系统调用实验Q1.阅读分别运行用API接口函数getpid()直接调用和汇编中断调用两种方式调用Linux操作系统的同一个系统调用getpid的程序: 请问getpid的系统调用号是多少？ Linux系统调用的中断向量号是多少？ A1.执行将两个文件分别命名为getpid_c.c和getpid_assembly.c，首先用gcc编译API接口调用程序，执行结果如下：可以看到程序分别输出了41580、41602、41612，其代表每次执行程序的进程识别码，且进程相互不同。其次用gcc编译汇编中断调用程序，其执行结果如下：程序的执行结果与API调用实现相同，可以实现输出进程的识别码。 系统调用号查阅有关博客，getpid的系统调用号分两个：在 32位系统下为 20，在 64位系统下为 39.本题的代码基于32位系统，所以程序中传入的系统调用号为 0x14，即 20. 中断向量号根据第二段汇编内嵌代码所提供的信息，其通过代码：INT 0x80 进入中断，所以Linux系统调用的中断向量号是 80H。 Q2.上机完成习题1.13 A2.linux系统调用的C函数形式为了实现打印输出“hello world”，这里选用系统调用函数write来实现，通过下面代码即可实现：123456#include &lt;stdio.h&gt;int main()&#123; write(1,"hello world!\n",14); return 0;&#125; 其中write的三个参数分别制定：输出方式、输出内容和输出长度。执行结果如下： 汇编代码通过C语言内嵌汇编的形式来打印“hello word”的方法如下：12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; char* msg = "Hello World!\n\r"; int len = 14; int result = 0; asm volatile("mov %2, %%edx;\n\r" /*传入参数：要显示的字符串长度*/ "mov %1, %%ecx;\n\r" /*传入参赛：文件描述符（stdout）*/ "mov $1, %%ebx;\n\r" /*传入参数：要显示的字符串*/ "mov $4, %%eax;\n\r" /*系统调用号：4 sys_write*/ "int $0x80" /*触发系统调用中断*/ :"=m"(result) :"m"(msg),"r"(len) /*输入部分：绑定字符串和字符串长度变量*/ :"%eax"); return 0;&#125; 程序的执行结果如下： Q3.阅读pintos操作系统源代码，画出系统调用实现的流程图. A3.由于并未实际操作过pintos系统，所以如何定位系统调用的区域或是执行流程是一个很大的问题。为此，我参考了Linux的系统调用流程，将Linux的系统调用思想转移到pintos系统上，下面是我的学习所得。 先拿Linux的系统调用read函数来举个例子，其实现流程如下： 在理解了Linux系统调用后，我尝试对pintos的项目源码进行了研读。Pintos系统调用的相关代码存储在：pintos\src\lib\user下的syscall.c、syscall.h和syscall-nr.h中。其中：syscall-nr.h用于存储系统调用号的声明，syscall.c和syscall.h则编写了系统调用函数的具体实现。还是继续拿read()函数来说明pintos的系统调用流程： 首先用户在用户程序中调用read函数。 接下来进入read函数的封装例程阶段，其对应syscall.c中的代码段： 在C库的read函数中，其返回了一个syscall3 (SYS_READ, fd, buffer, size);的指向，即系统调用处理程序。其中第一个参数SYS_READ即为read函数的系统调用号，该声明位于文件syscall-nr.h中： Syscall3函数的实现也位于syscall.c文件中，其代码如下： 从代码中可以看到，syscall3函数通过 INT $0x30 语句触发了系统的软中断。 承接syscall3的初始化函数位于src/userprog/syscall.c中，通过函数syscall_init调用执行intr_register_int来完成中断的初始化 接下来进入中断服务程序处理过程 中断服务处理程序位于src/threads/interrupt.c和src/threads/interrupt.h文件中，其中：interrupt.h定义了中断堆栈帧的各个寄存器以及中断程序的声明,通过syscall3的参数传入即可识别需要执行的功能： interrupt.c存储了中断服务程序的具体实现，中断的处理主要先依靠函数void intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,intr_handler_func *handler, const char *name)实现相关参数的初始化 进而通过调用函数：void intr_handler (struct intr_frame *frame)来实现：其函数的描述为： 处理所有中断，故障和异常。这个函数由汇编语言中断存根调用使用intr-stubs.S。 FRAME描述了中断和中断线程的寄存器。 通过中断程序的执行，从而得以调用系统调用服务例程。 所以，pintos的系统调用流程 应该为： 并发实验Q1.编译运行该程序（cpu.c），观察输出结果，说明程序功能。(编译命令： gcc -o cpu cpu.c –Wall)（执行命令：./cpu） A1.通过观察，可以得出程序的功能为：每隔一秒打印输入的参数或提示程序的正确输入格式。 Q2.再次按下面的运行并观察结果：执行命令：./cpu A &amp; ./cpu B &amp; ./cpu C &amp; ./cpu D &amp;程序cpu运行了几次？他们运行的顺序有何特点和规律？请结合操作系统的特征进行解释。 A2.观察程序可知，CPU的运行次数取决于while循环的执行次数，如果不强制终止程序，CPU将会一直运行下去。 程序的部分执行结果如下：从上图的执行结果中可以观察到：4个程序在每一轮都会轮流执行，而且执行的打印次序没有固定的顺序。这是因为：对于4个完全相同的程序而言，CPU的优先级是相同的，所以每一轮的执行顺序是随机的，没有特定的规律。 内存分配实验Q1.阅读并编译运行该程序(mem.c)，观察输出结果，说明程序功能。(命令： gcc -o mem mem.c –Wall) A1.程序的执行结果如图：程序首先打印指针p所指向的内存地址：0x19d2010及其对应的进程：41862其次程序每隔一秒打印指针p+1后的相对地址1、2、3… 及其对应的进程：41862 Q2.再次按下面的命令运行并观察结果。两个分别运行的程序分配的内存地址是否相同？是否共享同一块物理内存区域？为什么？命令：./mem &amp;; ./mem &amp; A2.调用两个进程同时执行程序mem.c，其结果如下：从上图可以看到，两个分别运行的程序分配的内存地址不同，两个指针分别指向内存：0x8a2010和0x2337010，因为指针指向的内存单元的地址不同，所以不共享同一块物理内存区域。 在尝试关闭ALSR地址空间随机化后再次运行程序，发现程序有变化： 所以两个分别运行的程序分配的内存地址本可以相同，但正是因为ALSR地址空间随机化后从而导致用户观测到的地址互不相同。 原因： Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存），而且更重要的是，用户程序可使用比实际物理内存更大的地址空间。 共享的问题Q1.阅读并编译运行该程序，观察输出结果，说明程序功能。（编译命令：gcc -o thread thread.c -Wall –pthread）（执行命令1：./thread 1000） A1.程序执行的输出结果如图：阅读代码可知，程序的功能为开启两个线程，同时执行子函数worker，实现对counter变量的loops*2次累加，最后打印counter的初值和累加结果。 Q2.尝试其他输入参数并执行，并总结执行结果的有何规律？你能尝试解释它吗？（例如执行命令2：./thread 100000）（或者其他参数。） A2.更改参数，程序执行的输出结果如图：从输出结果可以发现，counter的final值为输入参数的2倍，初始值恒为0.原因：虽然程序同时创建了两个线程执行worker函数，但两个线程均是对同一个counter变量进行相同次数的累加，所以最终结果总为loops的2倍，即输入参数argc的2倍。 参考文献使用库函数API和C代码中嵌入汇编代码两种方式使用同一个系统调用：https://blog.csdn.net/sunyeyi/article/details/44702575 linux系统调用号查询：https://blog.csdn.net/u012763794/article/details/78777938 Linux内存管理：https://www.cnblogs.com/ralap7/p/9184773.html]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——进程控制]]></title>
    <url>%2F2019%2F03%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[本次实验全部基于Ubuntu 16.04完成代码托管于GitHub: https://github.com/hnjia00/OS2019 最近的课程正在讲述进程有关的知识，老师说进程是面试的时候面试官最喜欢提问的话题，也是区分科班操作系统出身学生的一个标准，所以这部分内容和习题的实践性要远强于第一次。 Q1.打开一个vi进程。通过ps命令以及选择合适的参数，只显示名字为vi的进程。寻找vi进程的父进程，直到init进程为止。记录过程中所有进程的ID和父进程ID。将得到的进程树和由pstree命令的得到的进程树进行比较。 A1.第一题还是以基本操作为主，是一个按部就班的过程，下面就来逐步讲述。 打开vi进程只需在终端直接输入vi，执行结果如下： 接下来启动另一个terminal，通过命令 ps -A 查找 vi 的进程信息，结果如下： 在找到vi的进程号 pid 之后，可以继续从 ppid 处得到进程的父进程id，通过命令ps -l逐步寻找vi的父进程，寻找步骤如下： 在得到vi的进程调用序列之后，通过pstree命令来查看所有的进程树如下图所示，可以发现进程树命令和逐层寻找得到的结果相同，均为如下序列。 1Systemd-&gt;lightdm-&gt;lightdm-&gt;gnome-terminal-&gt;bash-&gt;vi 这里还要额外提一句，使用 Systemd 就不需要再用 init 了。这是因为init进程有两个缺点：启动时间长且启动脚本复杂。Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。 Q2.编写程序，首先使用fork系统调用，创建子进程。在父进程中继续执行空循环操作；在子进程中调用exec打开vi编辑器。然后在另外一个终端中，通过ps–Al命令、ps aux或者top等命令，查看vi进程及其父进程的运行状态，理解每个参数所表达的意义。选择合适的命令参数，对所有进程按照cpu占用率排序。 A2. 首先需要编写一个用于实现题干功能的C语言代码。分析题目可以看到，首先需要使用 fork() 系统调用创建子进程，其次根据fork的返回值相应的在父/子进程中填入对应的功能代码，我的代码具体如下，程序在父进程中执行空循环操作，在子进程中通过系统调用 execlp() 来启动vi进程，执行结果通过在另外的终端中的命令得以查看。 12345678910111213141516171819202122232425#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123; pid_t pid; pid = fork(); //父进程: pid&gt;0 if(pid &gt; 0) while(1); //子进程： pid=0 else if(pid == 0)&#123; int ret; ret = execlp("vi","",NULL); if (ret == -1)&#123; perror ("execl"); printf("excel error\n"); &#125; &#125; else if(pid == -1)&#123; perror("fork"); printf("fork error\n"); &#125; &#125; ps-Al执行 ps -Al命令的执行结果如下：其中，各个参数的解释如下： 参数 说明 F flag S 程序的状态 UID 执行者身份 PID 进程ID PPID 父进程ID C 使用的CPU资源百分比 PRI 进程的执行优先权 NI 进程的nice值 ADDR 内核函数 SZ 占用内存的大小 WCHAN 进程正在睡眠的内核函数名称 TTY 登入者的终端机位置 TIME 使用掉的CPU时间 CMD 下达指令的名称 ps aux执行 ps aux 命令可以打印使进程按如下格式输出：1USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 其中，各个参数的解释如下： 参数 说明 USER 行程拥有者 PID pid %CPU 占用的 CPU 使用率 %MEM 占用的记忆体使用率 VSZ 占用的虚拟记忆体大小 RSS 占用的记忆体大小 TTY 终端的次要装置号码 STAT 该行程的状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) START 行程开始时间 TIME 执行的时间 COMMAND 所执行的指令 执行结果如下：可以看到，./fork-exec进程一直在运行，且占用了97.7%的CPU资源，这应该全部归功于空循环。 toptop命令用于实时显示进程的动态，按照CPU的占有量降序排序，进程信息区统计信息区域的下方显示了各个进程的详细信息，各列的含义如下： 参数 说明 PID 进程id USER 进程所有者的用户名 PR 优先级 NI nice值。负值表示高优先级，正值表示低优先级 VIRT 进程使用的虚拟内存总量，单位kb RES 进程使用的、未被换出的物理内存大小，单位kb SHR 共享内存大小，单位kb S 进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) %CPU 上次更新到现在的CPU时间占用百分比 %MEM 进程使用的物理内存百分比 TIME+ 进程使用的CPU时间总计，单位1/100秒 COMMAND 命令名/命令行 执行结果如下： Q3.使用fork系统调用，创建如下进程树，并使每个进程输出自己的ID和父进程的ID。观察进程的执行顺序和运行状态的变化。 A3.实现进程树需要通过fork系统调用来实现，首先需要熟悉fork的具体作用。 fork在英文中是”分叉”的意思，fork函数启动一个新的进程，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段，子进程复制父进程的堆栈段和数据段。 所以也就是说，执行一次fork函数，有两个返回值。根据返回值的不同可以区别父进程(&gt;0)和子进程(=0)。 根据进程树的结构，p1有两个子进程p2和p3，同时p2也有两个子进程p4和p5，所以我所编写的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdbool.h&gt;#include&lt;sys/types.h&gt;int main(int argc, char *argv) &#123; /* 先打印根节点 */ pid_t p1; printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); if(p1 == 0)&#123; /* 进入进程p1 */ pid_t p3; /* 先创建p3 */ p3 = fork(); if(p3 == 0) /* j进入进程p3 */ printf("p3 pid: %d, ppid: %d\n", getpid(),getppid()); else if(p3 &gt; 0)&#123; /* 进入p3的父进程，也就是p1。 接下来创建进程p2 */ pid_t p2; p2 = fork(); if(p2==0)&#123; /* 进入进程p2,接下来先创建p4 */ printf("p2 pid: %d, ppid: %d\n", getpid(),getppid()); pid_t p4; p4 = fork(); if(p4 == 0)&#123; /* 进入进程p4 */ printf("p4 pid: %d, ppid: %d\n", getpid(),getppid()); &#125; else if(p4 &gt;0)&#123; /* 此处位于p4的父进程，即p2,继续创建p5 */ pid_t p5; p5 = fork(); if(p5==0) printf("p5 pid: %d, ppid: %d\n", getpid(),getppid()); &#125; &#125; &#125; &#125; sleep(1); &#125; 程序的输出结果如下，满足题目的进程树的架构： Q4. 修改上述进程树中的进程，使得所有进程都循环输出自己的ID和父进程的ID。然后终止p2进程(分别采用kill -9 、自己正常退出exit()、段错误退出)，观察p1、p3、p4、p5进程的运行状态和其他相关参数有何改变。 A4. 第四题应该是这几个题中最难的一个，综合了前三个题的知识应用，必须有对进程的充分认识和fork系统调用的理解才能实现这些功能，我的视线具体如下： 代码部分需要在第三题的基础上进行修改，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdbool.h&gt;#include&lt;sys/types.h&gt;int main(int argc, char *argv) &#123; /* 先打印根节点 */ pid_t p1; if(p1 == 0)&#123; /* 进入进程p1 */ int p1pid,p1ppid; p1pid = getpid(); p1ppid = getppid(); //printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); pid_t p3; /* 先创建p3 */ p3 = fork(); if(p3 == 0)&#123; /* j进入进程p3 */ int i; for(i=0;i&lt;10;i++)&#123; printf("p3 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else if(p3 &gt; 0)&#123; /* 进入p3的父进程，也就是p1。 接下来创建进程p2 */ pid_t p2; p2 = fork(); if(p2==0)&#123; /* 进入进程p2,接下来先创建p4 */ pid_t p4; p4 = fork(); if(p4 == 0)&#123; /* 进入进程p4 */ int i; for(i=0;i&lt;10;i++)&#123; printf("p4 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else if(p4 &gt;0)&#123; /* 此处位于p4的父进程，即p2,继续创建p5 */ pid_t p5; p5 = fork(); if(p5==0)&#123; //p5 int i; for(i=0;i&lt;10;i++)&#123; printf("p5 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else&#123; //p2 int i; for(i=0;i&lt;10;i++)&#123; //通过exit()终止p2 if(i==2) exit(1); //段错误 //if(i==5) //&#123; // int *p=NULL; // *p=0; //&#125; printf("p2 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; &#125; &#125; &#125; int i; for(i=0;i&lt;10;i++)&#123; printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; sleep(1); &#125; 即需要在刚进入p1的时候记录p1的pid和ppid以便后续打印输出，p2进程的输出部分需要控制在p5进程的父进程部分，如果在刚进入p2就执行循环输出，p4和p5进程就会因此无法创建。 程序的输出结果如下： 下面分别采用kill -9 、自己正常退出exit()、段错误退出来终止p2进程。 kill -9kill -9属于手动中断进程，通过此命令中断p2的结果如下：在p2被中断之后，其子进程p4和p5的参数ppid的值随即发生改变。 exit()exit()函数属于安放在代码中的正常退出函数，将其放入p2循环打印的代码中，控制其在特定次数后执行便可以达到我们的预期，结果如下：可以看到，由于p2先于其父进程p1结束，随即就变成了僵尸进程defunct状态 段错误所谓段错误，一般是访问了未申请的内存或非法的内存时产生的，概括点说在代码中一般是由指针的不当使用引起的。为了引起段错误，我在代码中设置了如下代码段：其执行结果如下： 参数变化对于每种错误我均使用了ps命令来查看进程参数信息，最后发现三种情况所造成的进程中断所带来的参数变化是一样的，p2进程的参数变化如下：从图中可以看到： 程序的状态由S变为Z，即僵死 占用内存大小变为0 WCHAN由hrtime变为‘-’，进程停止 cmd部分多了僵尸进程标识符 参考文献linux命令ps aux|grep xxx详解 https://www.cnblogs.com/robertoji/p/5555449.html linux的top命令参数详解 https://www.cnblogs.com/LeoBoy/p/7976612.html ps命令执行后各项参数的含义 https://blog.csdn.net/tcpipstack/article/details/8541980]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——存储过程和函数]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本次作业基于Mac OS X系统下的mysql workbench软件完成 存储过程在数据库编程中也是一个重要的角色，其主要的能力在于能被编译好放到服务器中，在使用时直接call即可调用执行，既能简化操作又能节省时间，能在优化层面起到一个很好的作用。 实验内容1、编写存储过程实现下列操作： （1）查询某读者、某段时间的借阅信息。已知读者姓名，查询起始和终止时间，列出其所有借阅信息。 （2）实现简单的图书入库操作（包含主键的少量信息即可）2、编写函数实现下列操作： 输入会员级别，返回该级别会员所借的图书总数量 解决方案编写存储过程（1）查询某读者、某段时间的借阅信息（已知读者姓名，查询起始和终止时间，列出其所有借阅信息 实现代码如下,其中 delimiter 是MySQL中的命令，这个命令与存储过程没什么关系，其作用就是告诉mysql解释器，该段命令是否已经结束了，mysql是否可以执行了。12345678910USE `bookmis`;DROP procedure IF EXISTS `borrow_book`;DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `borrow_book`(in reader_id varchar(5),in starttime date,in endtime date)BEGIN select * from borrows where borrows.reader_id=reader_id and borrows.Date_borrow&gt;=starttime and borrows.Date_return&lt;=endtime;END$$DELIMITER ; 我们用代码1call borrow_book('r001','2016-01-01','2017-01-01') 来进行测试，成功输出了r001在指定时间的借阅信息： （2）实现简单的图书入库操作（包含主键的少量信息即可） 代码如下，插入的参数为 book_id , book_name 和 Quantity_in 三个1234567891011121314DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `entry`(in id varchar(5),in book_name varchar(15),in amount int)BEGIN if id in (select book_id from books) then update books set Quantity_in=Quantity_in+amount where books.book_id=id; else insert into books(book_id,book_name,Quantity_in) values (id,book_name,amount); end if;END$$DELIMITER ; 由于存储过中写到了if条件判断，所以我们分别测试一下插入新书和插入旧书的结果。首先是插入新书，执行代码1call entry('b009','test_book',12) 结果如下：其次是插入旧书，执行代码1call entry('b001','并行计算',20) 结果如下： 编写函数（1）输入会员级别，返回该级别会员所借的图书总数量。 代码如下：123456789101112DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` FUNCTION`show_vipbooks`(vip_level varchar(6)) RETURNS int(11)DETERMINISTICBEGIN declare sum int; set sum = (select count(book_id) from readers,borrows where readers.level=vip_level and readers.reader_id=borrows.reader_id group by readers.level);RETURN sum;END$$DELIMITER ; 我们拿金卡用户做测试，可以观察到金卡用户 r001,r004:r001,r004总共借阅了图书5本，分别是b001,b002,b001,b002,b006: 执行代码：1select show_vipbooks('金卡') 函数执行结果如下： 小结存储过程和函数在课程设计和项目中都是一个比较重要的成分，其中很大一部分原因在于其代码的集成性。运用存储过程可以起到一个很好的简化代码的作用，只需一个入口参数即可实现重复的数据查询或数据定义的功能，比起繁琐的select语句，一个call起到的作用会更大，更何况其执行速度也得到了很好的优化。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——SQL调优]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94SQL%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[SQL调优是一项很重要的技术，实际在使用小数据集时DBMS自身的搜索优化是能满足我们的时间需求的，只有在数据集规模到10w+以后才能在秒级的层面看到SQL代码优化的效果。 本次实验环境如下： 操作系统：Mac OS X 10.13 DBMS：MySQL 8.0 图形化管理界面：MySQL Workbench 表结构本次实验选用了一个待测试表，名为‘pv_train_part1’，其结构如下： 名称 类型 实例 Key int 5 Feature1 double 1.294408418 Feature2 double 1.331507473 Feature3 double 1.279030084 Feature4 double 0.545543622 Feature5 int 64125 Feature6 double 1.738819447 Feature7 double 0.88708635 Feature8 double 28622.91442 label int 0 数据仿真方法此数据集来源于我跟随老师做的项目，从数据实例和分布来看其明显是一个机器学习模型的训练数据样本，大体是一个八参数的分类问题（实则是一个多参数的特征选取和异常数据监测项目）。 本数据取自github上的开源数据集，其链接为：数据集 数据记录数通过MySQL Workbench的‘Table Data Import Wizard’功能，可以实现将外部csv文件导入的功能： 通过执行结果可以观测到数据记录数如下： 优化规则及执行时间优化规则一:建立索引首先我使用的第一条优化规则便是建立索引，这在几乎所有的DBMS上是通用的优化策略。为了便于展示，这里的优化执行结果以执行查询操作来作为反馈。 在没建立索引前，表的设计层面如下：执行查询语句：1select feature3 from pv_train_part1 where pv_train_part1.key=59081; 结果如下： 可以看到该查询的执行时间为： 0.056 second 。 然后我们给key属性添加主键索引，添加完之后设计层面如下： 添加完成之后重新执行相同的查询语句，执行时间如下： 可以看到，在添加完主键索引之后，查询时间变成了 0.00034 second，较未添加索引之间查询效率提高了 163 倍。 优化规则二:查询限制在MySQL中，假如只需要一条查询条件的结果，或者在事先已经知道查询语句仅仅会返回一条结果的情况下，我们可以在查询语句的结尾后添加 “limit 1” 字段以便在查询到结果后中断对剩余表单的检索，对比如下： 首先我们对表执行查询语句：1select feature3 from pv_train_part1 where pv_train_part1.label=3 ; 查询时间如下： 可以看到，通过普通查询语句查询，其执行时间在 0.039 second。 然后对上述sql语句后添加 “limit 1” ，修改为：1select feature3 from pv_train_part1 where pv_train_part1.label=3 limit 1; 查询时间如下：可以看到，在添加limit 1后，其执行时间缩短为了 0.00049 second，相较于优化前的查询，效率提高了 203 倍。 通过这几个案例可以看出，SQL调优可以为数据库的查询操作提高近百倍的效率，是我们在开发大型工程中的必备知识。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——完整性]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AE%8C%E6%95%B4%E6%80%A7%2F</url>
    <content type="text"><![CDATA[数据库的完整性是一块很重要的知识，涉及到表、视图等的各种约束，是保证数据库或项目正常运行的根本保证，也是继SQL语句后的第二块重要的知识点。 完整性主要包括：实体完整性，参照完整性和用户自定义完整性。当然，在dbms下，用户接触最直接的就是用户自定义完整性和外键的参照完整性，所以下面的实验主要以后两者为主。 用户自定义完整性check语句使用check子句定义如下约束条件:• 读者证件只能是“身份证”或“护照”；• 读者手机号是以“1”打头的11位字符,后10位只能是数字。 解决方案 由于mysql不支持check方法，所以为了完成本题的要求，我对各自问题编写了一个触发器以实现所需功能。 Q. 读者证件只能是“身份证”或“护照”A.123456CREATE DEFINER=`root`@`localhost` TRIGGER `readers_BEFORE_INSERT` BEFORE INSERT ON `readers` FOR EACH ROW BEGIN if NEW.Card_name not in ('身份证' ,'护照') then delete from readers where Card_name = new.Card_name; end if;END 执行错误插入（Card_name=’其他’）如下： 触发器功能启动，报错如下： 执行正确插入（Card_name=’护照’）如下： 语句成功执行： 其实用check语句实现很容易，只需要在表的定义语句中加上check Card_name in (&#39;身份证&#39; ,&#39;护照&#39;)即可实现。 Q. 读者手机号是以“1”打头的11位字符,后10位只能是数字A. 由于mobile为varcher型，直接设置 正则 比较即可1234CREATE DEFINER=`root`@`localhost` TRIGGER `readers_BEFORE_INSERT` BEFORE INSERT ON `readers` FOR EACH ROW BEGIN if NEW.mobile not REGEXP '^[1][0-9]&#123;10&#125;$' then delete from readers where mobile = new.mobile; end if;END 执行错误插入（mobile=2…）如下： 触发器功能启动，报错如下： 触发器编写触发器，实现以下约束• 已挂失的借书证不能再借书；• 向借阅表增加一个借书记录后，在图书表里该图书的出借数自动加1。 解决方案Q. 已挂失的借书证不能再借书A. 由题意可知，存在于loss_reporting表中的用户不能再向borrow表中插入数据，所以代码实现如下：12345678CREATE DEFINER=`root`@`localhost` TRIGGER `borrows_BEFORE_INSERT` BEFORE INSERT ON `borrows` FOR EACH ROW BEGIN if exists(select loss_reporting.reader_id from loss_reporting where(loss_reporting.reader_id = new.reader_id)) then delete from borrows where reader_id = new.reader_id; end if;END Q. 向借阅表增加一个借书记录后，在图书表里该图书的出借数自动加1A.12345678CREATE DEFINER=`root`@`localhost` TRIGGER `borrows_AFTER_INSERT` AFTER INSERT ON `borrows` FOR EACH ROW BEGIN if new.book_id in (select book_id from books) then update books set Quantity_out=Quantity_out+1 where books.book_id=new.book_id; end if;END 参照完整性参照完整性决定了外键约束，即在引用表中外键的值只能设置为被引用表中的值或为null 自定义违约处理将读者表的‘会员级别’外键的违约处理策略定义为置默认值“null” 解决方案在删除或更新外键时，子表置空 123456ALTER TABLE `bookmis`.`readers` ADD CONSTRAINT `level` FOREIGN KEY (`level`) REFERENCES `bookmis`.`member_level` (`level`) ON DELETE SET NULL ON UPDATE SET NULL; 在添加外键约束之后，我们将member_level表中的‘普通’删去，然后观察readers表中的数据变化如下： readers表原始数据： readers表执行删除后的结果如下： 可以观察到‘普通’全被置换为了null; 接下来我们将‘银卡’更新为‘白卡’可以看到readers表中的‘银卡’也被修改为了null（这里可能用cascade效果更好）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——安全性练习]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%80%A7%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[登录验证要求能够以2种登录方式登陆（ Windows 身份验证和SQL Server身份验证）。 解决方案 由于我的作业是基于 Mac OS X 系统下，用 mysql workbench 完成，故下面展示如何在Mac上登陆mysql workbench。 首先打开mysql workbench可以看到如下登录界面，选择 loacl instance ，实现Mac OS X系统本地登陆，操作步骤如下： 第二次，打开mysql workbench，选择 nlz 用户登陆，实现mysql workbench身份验证登陆，操作步骤如下: 权限分配新建登陆log1，新建用户u1，新建角色r1，授予角色 r1 对表S的select权限，将角色r1赋给用户u1，验证用户u1只具有表S的select权限，收回用户u1的角色r1，验证用户u1不具有表S的select权限。 要注意的是，角色 role 是 mysql8.0 版本之后才有的，在 mysql5.x 版本里不存在 role 解决方案 新建登陆log1如下： 新建用户u1： 1CREATE USER 'u1'@'localhost'; 新建角色r1: 1CREATE role r1; 授予角色 r1 对表books的select权限： 1grant select on bookmis.books to r1; 将角色r1赋给用户u1： 1grant r1 to 'u1'@'localhost' 激活角色:激活之前，没有角色处于运行状态，状态如下： 1SET DEFAULT ROLE ALL TO 'u1'@'localhost'; 通过执行上述代码实现对u1用户的相关角色的激活操作，激活之后通过代码：SELECT CURRENT_ROLE()查询活动的角色，如下： 验证用户u1只具有表books的select权限： 1SHOW GRANTS FOR 'u1'@'localhost' USING 'r1'; 输出u1具有的权限如下，可以看出，其只具有bookmis.books的select权限. 在u1用户上执行对books执行select操作，查询成功，结果如下： 继续执行查询readers表的操作，查询失败，结果如下： 收回用户u1的角色r1，验证用户u1不具有表books的select权限： 1REVOKE r1 FROM 'u1'@'localhost'; 回收r1之后我们执行代码：SHOW GRANTS FOR &apos;u1&apos;@&apos;localhost&apos; USING &apos;r1&apos;查看u1现在具有的权限，结果如下： 验证r1被回收，所以u1也丧失了相应的权限。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——SQL练习]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94SQL%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[计网的实验差不多整理完毕了，今天开始陆续整理一下数据库的实验吧，大三上最喜欢的课程就是数据库，所以我觉得作业的完成质量还是可以恭维的。 关系模式关系模式使用的是课程给出的图书管理系统，涉及到六个关系模式，包括两个实体和四个联系。先省略，以后有时间补齐。 SQL：数据查询在bookmis数据库中完成下列SQL查询：1、查找借了会员“李红 ”所借的全部图书的会员姓名2、查找没有借科普类图书的会员姓名3、查找借了2本及以上图书的银卡会员的姓名4、将计算机类图书的入库数加15、用insert命令向图书类别表中添加记录（‘ca07’ , ‘儿童’）6、用delete命令从图书类别表中删除类别‘儿童’7、把金卡读者的读者名和性别存入另一个已知基本表vip_readers (Reader_name,sex)中8、建立一个计算机类图书的视图，显示书编号、书名和出版社9、建立一个分组视图，显示每种级别会员的数量10、在（9）建立的分组视图中查询金卡会员的数量11、自己编写并实现一个能成功执行的视图更新任务 查询方案 本次作业基于MAC OS X系统下的mysql workbench软件完成 Q. 查找借了会员“李红 ”所借的全部图书的会员姓名A. 代码：基本思想为逻辑蕴含的转化:1234567891011select reader_name from readerswhere reader_id in (select distinct reader_id from borrow ba where not exists (select * from borrow bb where reader_id=(select reader_id from readers where reader_name='李红') AND not exists (select * from borrow bc where bc.reader_id=ba.reader_id AND bc.book_id=bb.book_id)) AND reader_id&lt;&gt;(select reader_id from readers where reader_name='李红')); Q. 查找没有借科普类图书的会员姓名A. 代码:123456select reader_name from readerswhere reader_id in (select reader_id from borrow,books,b_category where borrow.book_id=books.book_id AND books.category_id=b_category.category_id AND b_category.category&lt;&gt;'科普'); Q. 查找借了2本及以上图书的银卡会员的姓名A.123456select reader_name from readerswhere level='银卡' AND reader_id in( select reader_id from borrow group by reader_id having count(reader_id)&gt;=2); Q. 将计算机类图书的入库数加1A.1234set sql_safe_updates=0; #mysql中必须降低安全等级才能够批量操作update booksset Quantity_in=Quantity_in+1where Quantity_in&gt;=0; Q. 用insert命令向图书类别表中添加记录（‘ca07’ , ‘儿童’）A.123insert #插入指令into b_category(category_id,category)values('ca07','儿童'); Q. 用delete命令从图书类别表中删除类别‘儿童’A.123delete #删除指令from b_categorywhere(category='儿童'); Q. 把金卡读者的读者名和性别存入另一个已知基本表vip_readers (Reader_name,sex)中A.12345678create table vip_readers (Reader_name varchar(50), sex varchar(2) ); #创建表insert into vip_readers(Reader_name,sex) #插入数据select readers.reader_name,readers.sexfrom readerswhere level='金卡'; Q. 建立一个计算机类图书的视图，显示书编号、书名和出版社A.12345create view cs_book(book_id,book_name,publishing) #创建视图asselect book_id,book_name,publishingfrom books,b_categorywhere books.category_id=b_category.category_id AND b_category.category='计算机'; Q. 建立一个分组视图，显示每种级别会员的数量A.12345create view vip_count(level,number)asselect readers.level,count(level)from readersgroup by readers.level; #分组 Q. 在建立的分组视图中查询金卡会员的数量A.123select level,numberfrom vip_countwhere level='金卡'; Q. 自己编写并实现一个能成功执行的视图更新任务A.123update cs_bookset book_name='abc'where book_id='b001'; SQL：数据定义1、新建数据库Student12、在Student1数据库中新建表S1、C1和 SC1 ,指明主外键（结构与S,C,SC相同）3、在表S1中新增一列addr CHAR（20)4、删除表S1中的列addr5、在表SC1的列sno上建立升序索引6、删除表SC1 定义方案Q. 新建数据库Student1A.1create schema student1 Q. 在Student1数据库中新建表S1、C1和 SC1 ,指明主外键（结构与S,C,SC相同）A.1234567891011121314151617181920create table S1( sno char(4) primary key not null,#主键 sname char(8) not null, age int, sex char(1)); #建表S1create table C1( cno char(4) primary key not null,#主键 cname char(8) not null, tname char(10)); #建表C1create table SC1( sno char(4) not null, cno char(4) not null, grade int, primary key(sno,cno),#指定主键 foreign key(sno) references S1(sno),#指定外键 foreign key(cno) references C1(cno),#指定外键 check (grade is null or grade between 0 and 100)); #建表SC1 Q. 在表S1中新增一列addr CHAR（20)A.12alter table S1 add addr CHAR(20); Q. 删除表S1中的列addrA.12alter table S1 drop addr; Q. 在表SC1的列sno上建立升序索引A.12create index sno1 on SC1(sno asc); Q. 删除表SC1A.1drop table SC1; 小结SQL的数据定义和数据查询语句都是基础的语法，也是在后续编程中最常用到的语句，这里的基础一定要打牢，做项目和课程设计是也就是建立在这些基础语法之上的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——交换机VLAN实验]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%9C%BAVLAN%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[实验目的 熟悉 VLAN 的技术背景和原理 熟悉 VLAN 的基本配置方法和配置命令 在交换机上实现 VLAN 的划分 实验拓扑其中PC_A接port1口，PC_C 接port 2口，PC_B接port 1口，PC_D接port 2口， 两台交换机之间接port24口。 实验环境 系统：Windows7软件工具：Cisco Packet Tracer实现途径：软件模拟实现 实验过程本次实验分别从 Packet Tracer 软件模拟以及 实验室实地操作 共同实现： Packet Tracer模拟选择实验仪器利用Packet Tracer选取实验仪器是一件比较容易的事情，仅依靠拖拽功能即可实现布局。 交换机在左下方的控件选择中，我们选中Switches，然后根据实验指导的要求，选中2950T型号的交换机两台，如图所示： PC机根据实验指导书的要求，本次实验需要4台PC机以备测试。继续在控件中找到End Devices，从中找到Generic即为满足实验要求的PC机，如图所示： 构建网络拓扑根据实验指导的要求，PC-A和PC-B分别接两台交换机的port1口，PC-C和PC-D分别接两台交换机的port2口，两条交换机之间接port24相连。利用Packet Tracer建立网络拓扑也是一件比较容易的事情，完成布局如下： 更具体的，我们可以看到交换机的port1、port2和port24被连接挂起： 划分VLAN在连接构建好网络拓扑结构后，我们需要对交换机进行一些配置。在上一个过程中，我们分别连接占用了1、2和24口，所以在这一步我们需要分别对两个交换机的这三个口进行VLAN的划分。分别进入Switch3和Switch4的CLI界面，根据实验指导输入命令用以实现划分，操作如下： 根据实验指导，配置完成之后可以调用命令show vlan和show running-config查看划分情况和配置。 配置PC在配置完交换机后，下一步需要完成对四个PC机的配置，这里的配置实质上是完成对PC机的IP参数的配置，包括IP地址、子网掩码和默认网关等。在PC机的desktop的IP configure界面可以完成上述配置，如图所示： 实验结果完成PC和交换机的配置后，我们可以在PC机的命令行界面执行Ping命令，用以检查是否完成实验要求。按照网络拓扑结构，在我们的测试网络中，PC-A可以Ping通PC-B，但是不能Ping通PC-C和PC-D。 实验室实地操作通过在软件上模拟之后，我对本次实验的具体原理、操作和内容又了进一步的理解。而后在周四的实验上机中，我通过具体的连线和上手操作完成了本次实验的全部要求。 配置交换机实验室的交换机不需要我们再通过超级终端去配置，所以我们只需要对待使用的两台交换机分别划分好vlan和端口即可。 通过两条telnet命令分别连接10007和10008端口进行配置。1telnet 172.31.44.240 10007 1telnet 172.31.44.240 10008 依照实验指导，我们将命令依次输入，实现port24相连，vlan10和vlan20对port1和port2的划分，配置结果如下： PC测试在配置完交换机之后，下一步便该进行PC之间的测试了。依照实验指导的要求，我们需要4台PC分别连接两台交换机的port1和port2。 为了简化实验操作，在实验中我选择了两台PC（分别为192.168.1.2和192.168.1.3）分别连接 &lt; switch1:port1, switch2:port1&gt;&lt; switch1:port1, switch2:port2&gt;&lt; switch1:port2, switch2:port1&gt;&lt; switch1:port2, switch2:port2&gt; 以满足实验要求。 测试结果如下： 接相同端口的情况下可以相互ping通 接不同端口的情况下不可以相互ping通]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——实现路由算法]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 Dijkstra 算法的路由软件。 实验环境 系统：Mac OS X 10.13.1语言：Python 3.6.5平台：pycharm外部库：networkx，matplotlib 实验过程代码设计现Dijkstra算法的方法有很多种，为了在最短的代码内实现最好的效果，我选择了python来实现，借助networkx的有向图类DiGrapg接口实现了图的存储，通过自己实现的Dijkstra算法完成了搜索。 图的构造我们这里借助networkx库里的DiGraph类来构造有向图。DiGraph存储有向图的边的形式为形如(s，d，w)的三元组形式，其中： s: 边的起点；d: 边的终点；w: 边的代价. 考虑到操作的便捷性，我们使用一个path.txt文件来实现图的各个边的三元组的存储，path.txt的格式如下： 定义好边的数据结构之后，我们利用networkx中的函数add_edge()来实现边的输入和图的构建 12345for line in open("path.txt","r"): #按行读取文件 data.append(line.strip('\n')) for row in data: row=row.split(',') #分割三元组 G.add_edge(eval(row[0]), eval(row[1]), weight=eval(row[2]) Dijkstra算法算法实现的流程图如下： 演示部分networkx库同样集成了图的绘制函数，我们通过与matplotlib库的协同操作来完成图的搜索演示。通过以下代码来实现图的分屏：123plt.figure(figsize=(14, 6)) plt.subplot(121)plt.subplot(122) 通过以下代码来实现初始图的绘制：12pos = nx.spring_layout(G)nx.draw_networkx(G, pos,node_size=300,node_color='#FFB5C5') 通过以下代码来实现图上搜索路径的绘制：123456# 绘制非路径上的边 edges_not_in_path = list(set(G.edges()) - set(edges))edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges_not_in_path]nx.draw_networkx_edges(G, pos, edgelist=edges_not_in_path, edge_color='b',width=edgewidth) # 绘制路径上的边 edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges]nx.draw_networkx_edges(G,pos,edgelist=edges,edge_color='r',width=edgewidth) 执行结果我们这里把网络类比为一个有向图，事实上路由的传输方向可以是双向的。其中，图‘Test Graph’即为初始图；对于图‘The shortest path from 0 to 6’： 红色边：通过Dijkstra算法搜索到的最小代价路径；蓝色边：未采纳的边；边的粗细程度：边的权值，越细代表权值越小. 为了验证我们得到的路径是否是正确的答案，我们使用networkx库中标准的函数进行检验，代码如下：answer=nx.dijkstra_path(G,source=start_node,target=end_node)可以得到输出的answer路径如下，与我们的代码所得出的答案相同： 代码附录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import networkx as nx import matplotlib.pyplot as plt #路由算法实现 def Dijkstra(G,start,end): RG = G.reverse() dist = &#123;&#125; previous = &#123;&#125; for v in RG.nodes(): dist[v] = float('inf') previous[v] = 'none' dist[end] = 0 u = end while u!=start: u = min(dist, key=dist.get) distu = dist[u] del dist[u] for u,v in RG.edges(u): if v in dist: alt = distu + RG[u][v]['weight'] if alt &lt; dist[v]: dist[v] = alt previous[v] = u path=(start,) last= start while last != end: nxt = previous[last] path += (nxt,) last = nxt return path #初始化图函数 def init(G): data = [] for line in open("path.txt","r"): #按行读取文件 data.append(line.strip('\n')) for row in data: #分割三元组 row=row.split(',') G.add_edge(eval(row[0]), eval(row[1]), weight=eval(row[2])) return G if __name__=="__main__": #路由算法实现 G=nx.DiGraph() G=init(G) start_node = 0 end_node = 6 path=Dijkstra(G,start_node,end_node) #标准库函数检测 answer=nx.dijkstra_path(G,source=start_node,target=end_node) print("nx.dijkstra_path's path:") for i in range(len(answer)-1): print(str(answer[i])+'-&gt;',end="") print(answer[i+1]) # 构造最小权值边路径 edges=[] for i in range(len(path)-1): edges.append((path[i],path[i+1])) #绘制初始图 plt.figure(figsize=(14, 6)) plt.subplot(121) plt.title("Test Graph") pos = nx.spring_layout(G) nx.draw_networkx(G, pos,node_size=300,node_color='#FFB5C5') #绘制最小路径结果 plt.subplot(122) plt.title("The shortest path from %d to %d" % (start_node, end_node)) nx.draw_networkx_nodes(G, pos=pos, node_size=300,node_color='#FFB5C5') # 绘制非路径上的边 edges_not_in_path = list(set(G.edges()) - set(edges)) edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges_not_in_path] nx.draw_networkx_edges(G, pos, edgelist=edges_not_in_path, edge_color='b',width=edgewidth) # 绘制路径上的边 edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges] nx.draw_networkx_edges(G, pos, edgelist=edges, edge_color='r',width=edgewidth) #显示 plt.show()]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——实现Go-Back-N]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0Go-Back-N%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 Go-Back-N 的可靠数据传输软件。 实验环境 系统：Mac OS X 10.13.1语言：Java开发平台：eclipse内部库：java.net，java.util 实验过程代码设计为了完成本次试验的要求，我编写了两个Java代码文件，分别实现server端功能和client端功能： server端代码流程主要算法流程如下所示，server端实现在一定丢包率范围内接收数据包并且回传ACK： client端代码流程主要的算法流程如下，client端主要实现数据包的传送以及延迟处理： 主机ip获取在启用Go-Back-N之前，我们首先需要获得个人电脑的IP。在Mac OS X系统，使用终端命令ifconfig即可直接查看主机IP，具体如下： 丢包率为0下的测试为了验证代码的正确性，我首先先把丢包率设置为0查看了具体的传输流程，代码执行结果如下： 窗口长度 windowSize = 4；数据包总数 num = 10；超时限制 Timer = 1000ms 执行结果如下： 丢包率为10%下的测试为了继续验证代码的正确性，而后我把丢包率设置为10%查看了具体的传输流程，代码执行结果如下： 小结本次实验中，我们完成了java的网络编程，模拟了GBN算法的运行，对GBN协议有了进一步的了解。在GBN协议中，接收方会丢弃所有失序的分组，尽管丢弃一个正确接收但是失序的分组有点浪费。但是根据GBN的原理。假定当前期望的编号是n，但是n+1提前达到。因为数据必须是有序交付，接收方可能缓存分组n+1，然后在他收到并交付分组n后，再将该分组交付到上层。但是如果n丢失，则n和n+1的分组都会被重发，因此，接收方只需要丢弃分组n+1即可。这种方法的优点是接收方缓存简单，即接收方不需要缓存任何失序分组。对于发送方来说，他只需要维护窗口的下边界和和nextseqnum在窗口中的位置。对于接收方来说，只需要维护下一个按序接收的分组的序号。 代码附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/************************发送方************************/public class Client &#123; //定义流量窗格长度，起始和终止数据包号，计时器 public static int windowSize; public static int start=0, end, num; public static long timerTime = 0; public static void main(String[] args) throws Exception &#123; //建立连接 InetAddress serverAddress = InetAddress.getByName("192.168.1.106"); DatagramSocket clientSocket = new DatagramSocket(9999); byte[] sendData; Timer timer = new Timer(); timer.schedule(new DelayActionListener(clientSocket), 0L, 500L); //通过输入初始化参数 Scanner scanner = new Scanner(System.in); System.out.println("Please enter number of packets: "); num = scanner.nextInt(); System.out.println("Please enter slide window size: "); windowSize = scanner.nextInt(); System.out.println(); end = start + windowSize; //启动计时 Timer[] timers = new Timer[num]; long startTime = System.currentTimeMillis(); //首先发送第一个流量窗内的数据包 System.out.println("&lt;--Client send packets " + start + " - " + (start+windowSize-1)); for (int i=start;i&lt;end;i++)&#123; sendData = (i + "seq").getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, 8888); clientSocket.send(sendPacket); &#125; //循环发送剩余的数据包 while (true)&#123; byte[] recvData = new byte[100]; DatagramPacket recvPacket = new DatagramPacket(recvData, recvData.length); clientSocket.receive(recvPacket); String in = new String(recvPacket.getData()).trim(); int ack_seq = Integer.parseInt(in.substring(3, in.length())); System.out.println("--&gt;Client received ACK: " + (ack_seq-1)); //正常情况 if (ack_seq &gt;= start &amp;&amp; ack_seq &lt; end)&#123; int oldEnd = end; start = ack_seq; end = ack_seq + windowSize; if (end &gt; num) end = num; //发送数据包 for (int i = oldEnd; i &lt; end; i++) &#123; sendData = (i + "seq").getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, 8888); clientSocket.send(sendPacket); System.out.println("&lt;--Client sent packet "+i); &#125; timerTime = System.currentTimeMillis(); &#125; //传到流量窗的右界限 if (ack_seq == end) timerTime = 0; //传输结束 if (ack_seq == num)&#123; timer.cancel(); System.out.println("Success sent all packets"); System.out.println("Time to send " + num + " packets successfully was " + (System.currentTimeMillis() - startTime) + "ms"); return; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/************************接收方************************/public class Server &#123; public static void main(String[] args) throws Exception &#123; //创建套接字，初始化参数 DatagramSocket serverSocket = new DatagramSocket(8888); int endReceive = 0; int missedCtr = 0; System.out.println("\n\n\nServer started.\n"); while (true)&#123; byte[] data = new byte[100]; //接收数据包 DatagramPacket receivePacket = new DatagramPacket(data, data.length); serverSocket.receive(receivePacket); //截取seq String in = new String(receivePacket.getData()).trim(); int seq = Integer.parseInt(in.substring(0, in.length() - 3)); System.out.println("Received packet " + seq+"&lt;--"); //在一定丢包率的范围内操作 if (seq == 0 || Math.random()&lt;=0.9)&#123; //接收数据包并发送ACK if (seq == endReceive)&#123; endReceive++; byte[] ackData = new String("ack"+endReceive).getBytes(); InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); DatagramPacket sendPacket = new DatagramPacket(ackData, ackData.length, clientAddress, clientPort); serverSocket.send(sendPacket); System.out.println("Server sent ACK: " + seq+"--&gt;"); &#125; //有数据包超前到达 else if (endReceive != 0)&#123; if (seq == endReceive + 1) &#123; System.out.println("Packet lost or disordered on way to server: " + endReceive); missedCtr++; System.out.println("Missed: " + missedCtr); &#125; byte[] ackData = new String("ack"+(endReceive)).getBytes(); InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); DatagramPacket sendPacket = new DatagramPacket(ackData, ackData.length, clientAddress, clientPort); serverSocket.send(sendPacket); System.out.println("Server sent ACK: " + (endReceive-1)+"--&gt;"); &#125; &#125; //有数据包丢失 else &#123; System.out.println("Drop packet " + seq); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——用smtp实现Email客户端]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%94%A8smtp%E5%AE%9E%E7%8E%B0Email%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 smtp 协议的 Email 客户端软件。 实验环境 系统：Mac OS X 10.13.1语言：Java连接协议：smtp邮箱主机：smtp.qq.com（qq邮箱）外部jar文件：javax.mail.jar 实验过程代码部分为了完成本次试验的要求，我编写了一个Java代码文件，具体的算法流程如下： 邮箱端配置为了方便起见，我在这里使用qq邮箱作为我的测试邮箱，但是qq邮箱默认是关闭smtp服务的，所以我们需要先开启smtp协议。 首先在qq邮箱的个人账户部分找到如下服务的对应位置（此图为开启之后所截，故显示已经开启）： 配合手机操作操作之后，我们可以得到如下的开通反馈，其中返回的授权码极为重要，其关系到代码中transport.connect（）方法的执行成功与否： 代码测试由查阅可得，qq邮箱的服务器如下，且使用端口为465或587：将服务器（smtp.qq.com）、端口(465)、收件人(835381071@qq.com)发件人邮箱(835381071@qq.com)和标题内容设置好之后，通过授权码执行连接，可以debug测试输出如下： 执行结果最后为了验证我们的执行结果，打开qq邮箱的收件箱，可以看到如下信息： 代码附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package smpt;import java.util.Properties;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;public class SendmailUtil &#123; public static void main(String[] args) throws AddressException, MessagingException &#123; Properties properties = new Properties(); // 使用smtp协议 properties.put("mail.transport.protocol", "smtp"); //qq邮箱的主机名 properties.put("mail.smtp.host", "smtp.qq.com"); //qq邮箱使用465端口 properties.put("mail.smtp.port", 465); // 端口号 //login验证 properties.put("mail.smtp.auth", "true"); //使用ssl安全连接 properties.put("mail.smtp.ssl.enable", "true"); // 设置是否显示debug信息 true 会在控制台显示相关信息 properties.put("mail.debug", "true"); // Session用于收集JavaMail运行过程中的环境信息 Session session = Session.getInstance(properties); // 获取邮件对象 Message message = new MimeMessage(session); // 设置发件人邮箱地址 message.setFrom(new InternetAddress("835381071@qq.com")); // 设置收件人地址 message.setRecipients( RecipientType.TO, new InternetAddress[] &#123; new InternetAddress("835381071@qq.com") &#125;); // 设置邮件标题 message.setSubject("smtp测试邮件"); // 设置邮件内容 message.setText("内容：smtp发送邮件成功！"); // 得到邮差对象 Transport transport = session.getTransport(); // 连接自己的邮箱账户 transport.connect("835381071@qq.com", "sgxclkuvvirtbdfe"); // 发送邮件 transport.sendMessage(message, message.getAllRecipients()); &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——JAVA实现web服务器]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94JAVA%E5%AE%9E%E7%8E%B0web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[趁着这几天刚开学，时间还比较宽裕，决定来整理一下自己的实验报告，先从计网开始。 实验目的 处理一个 http 请求 接收并解析 http 请求 从服务器文件系统中获得被请求的文件 创建一个包括被请求的文件的 http 响应信息 直接发送该信息到客户端 实验环境 系统：Mac OS X 10.13.1 语言：JAVA 浏览器：Google Chrome 实验步骤前期准备为了完成本次试验的要求，我编写了两个java代码文件，分别命名为：“HttpRequest.java”和“WebServer.java”。除此之外，我还编写了两个带跳转的测试网页“index.html”和“next.html”以及其各自包含的图片“first.jpg”和“next.jpg” HttpRequest.java的主要功能为：获取http请求中的套接字的输入流和输出流，即完成“对从服务器端发回的数据流”和“将要发送到服务器端的数据流”的处理和输出。 WebServer.java的主要功能为：创建线程，连续创建套接字以及处理http请求。 文件清单如下： 测试阶段我们使用jdk的javac指令对java代码进行编译，然后启动服务器的默认端口8080（代码中预设），然后在Google Chrome浏览器中对各种情况进行测试和检测输出，具体步骤如下。 首先我们启动终端，进入Java代码所在的文件夹下，然后利用javac命令编译main方法所在的Java文件“WebServer.java”，启动服务器，具体如下： 由于代码中设置的启动端口为8080，如下：所以我们在浏览器中需要输入网址“localhost:8080/index.html”以达到访问该网页的目的，具体如下： 在成功访问该网页之后，我们来观察一下终端的输出情况，发现其请求网页index.html请求成功如下：其请求网页包含的图片first.jpg请求成功如下： 然后点击跳转链接，跳转至next.html，访问下一个网页，同样的，网页跳转成功如下： 在成功打开网页之后，我们来观察一下终端的输出情况。同样的，请求网页“next.html”和“next.jpg”成功，输出如下结果： 当然，除了能成功访问的网页外，我们还需要测试一下错误路径的文件访问结果，于是在浏览器中输入一个错误的网址如“localhost:8080/404.html”，结果如下，提示文件不存在：终端反馈输出对404.html这个不存在的文件的访问结果： 代码附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/***********HttpRequest***************/import java.io.* ;import java.net.* ;import java.util.* ;final class HttpRequest implements Runnable &#123; final static String CRLF = "\r\n"; Socket socket; //构造请求类 public HttpRequest(Socket socket) throws Exception &#123; this.socket = socket; &#125; //启动线程 public void run() &#123; try &#123; processRequest(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; private void processRequest() throws Exception &#123; //获取套接字的输入流，即从服务器端发回的数据流 InputStream is = socket.getInputStream(); //获取套接字的输出流，返回的输出流就是将要发送到服务器端的数据流 DataOutputStream os = new DataOutputStream(socket.getOutputStream()); //缓冲字符输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); // 获取http的request信息 String requestLine = br.readLine(); // 从请求行中提取文件信息 StringTokenizer tokens = new StringTokenizer(requestLine); // 由于token将请求行分解为了单词，我们在这里跳过第一个单词，即“GET” tokens.nextToken(); // GET之后即为文件名 String fileName = tokens.nextToken(); // 为了将文件转化到当前目录下，我们在其之前加一个“.” fileName = "." + fileName ; // 打开文件 FileInputStream fis = null ; boolean fileExists = true ; //判断文件是否查询到 try &#123; fis = new FileInputStream(fileName); &#125; catch (FileNotFoundException e) &#123; fileExists = false ; &#125; //测试输出 System.out.println("\n*************Request**************\n"); System.out.println(requestLine); String headerLine = null; while ((headerLine = br.readLine()).length() != 0) &#123; System.out.println(headerLine); &#125; // 构造response信息 String statusLine = null; String contentTypeLine = null; String entityBody = null; if (fileExists) &#123; //执行成功的话返回“200 OK” statusLine = "HTTP/1.0 200 OK" + CRLF; contentTypeLine = "Content-Type: "+contentType(fileName) + CRLF; &#125; else &#123; //执行失败，文件未找到的时候返回“404 File Not Found” statusLine = "HTTP/1.0 404 File Not Found" + CRLF; contentTypeLine = "Content-Type: text/html" + CRLF; entityBody = "&lt;HTML&gt;" + "&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;" + "&lt;P&gt;File name:&lt;/P&gt;"+fileName+ "&lt;BODY&gt;Not Found&lt;/BODY&gt;&lt;/HTML&gt;"; &#125; // 将上述返回值依次输出 os.writeBytes(statusLine); os.writeBytes(contentTypeLine); os.writeBytes(CRLF); System.out.println("\n*************Response**************\n"); System.out.println(statusLine); //调用文件类型输出方法 if (fileExists) &#123; sendBytes(fis, os); fis.close(); &#125; else &#123; os.writeBytes(entityBody) ; &#125; // 结束关闭 os.close(); br.close(); socket.close(); &#125; private static void sendBytes(FileInputStream fis, OutputStream os) throws Exception &#123; //构造一个1K缓冲区，承接套接字的内容 byte[] buffer = new byte[1024]; int bytes = 0; //将请求的文件复制到套接字的输出流中。 while ((bytes = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, bytes); &#125; &#125; private static String contentType(String fileName) &#123; if(fileName.endsWith(".htm") || fileName.endsWith(".html")) &#123; return "text/html"; &#125; else return "other Content-type" ; &#125;&#125; 12345678910111213141516171819202122232425/***********WebServer***************/import java.io.* ;import java.net.* ;import java.util.* ;public final class WebServer &#123; public static void main(String argv[]) throws Exception &#123; int port=8080; // 建立一个套接字 ServerSocket socket = new ServerSocket(port); while (true) &#123; // 监听一个tcp连接的request. Socket connection = socket.accept(); // 处理HTTP请求消息。 HttpRequest request = new HttpRequest(connection); // 建立一个线程处理请求 Thread thread = new Thread(request); thread.start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次聚会]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%81%9A%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天正月十五，也不能说是闲来无事，毕竟还有那么多前路未卜的事情在等着自己，但是总归还是想写一些清闲的东西。 离开学还有五天，还在家能待三天。 今天去马骁家里聚会了，难得小聚一次，吃够了羊肉也喝够了粗，打够了麻将也赢够了钱。 大家都在为自己的前途开始迷茫了，没有明确的路子可走的人大概就是我们这一批大三的学生吧。 学生生涯还剩一年半，留给自己预备的选择也是众说纷纭。 考研怎么考能考得上哪，保研怎么找老师怎么不亏，出国又该怎么闹。 没有人知道该怎么办，就像有人说zgs的cpp课好一样，每个人都只有自己的路，你没有义务去让所有人都跟着自己的路走。 我也没有能力去辨别谁才是自己的模版。 毕竟这世界上，只有一个独一无二的贾浩男。 大家都好久没踢球了，曾经的前锋马骁也吃撑了一百九的中后卫，曾经的后卫现在也早就离开了操场。 被繁杂的课程，学业和人生压的不知所措。 但是有趣的是，我们每个人仿佛还走在自己自认为正确的道路上，自我感觉良好。 我总是难以定夺自己到底应该，或是值得去做什么。 我喜欢观望，观望才能给我很好的选择正确的机会。 但是观望，观望谁呢，谁有值得观望呢？ 无从所知。 我喜欢在街头看着各种各样的人的走走停停，去看他们的生活。 就像我最喜欢的实用文摘的板块，是社会百态。 在一个社会里，每个人都有着自己独一无二的生活。 品味这些生活，也真是一个有趣的过程。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——评论篇]]></title>
    <url>%2F2019%2F02%2F16%2FHexo%E2%80%94%E2%80%94%E8%AF%84%E8%AE%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天给琳琳看了下内测博客的初版，大体上还比较不错。 为了满足琳琳的需求，方便交流，我决定今天给博客添加评论功能。 网上的博客有很多，还是比较乱七八糟的，所以配好之后自己再总结一下，方便后人乘凉。 来必力在跟帖的插件中我选择了来必力：https://www.livere.com 有这几个原因： 界面UI美观 评论管理方便 支持多个社交账号 不过也有一点不方便，来必力隶属于韩国，在注册使用的时候需要科学上网，在网页加载的时候速度较慢。 下面来讲一下具体布置 注册登陆注册需要科学上网，不然是打不开注册登陆界面的，或者打开很慢？这里不做赘述。 安装选择city版安装就能满足我们的需求，直接安装即可。 安装完之后会以代码形式给出，或者也可以手动进入个人管理界面的 代码管理 查看。 对于NexT主题而言，这里我们主要关注 data-uid 的值。 配置得到用于安装插件的data-uid之后，下一步进入NexT的配置文件 _config.yml 设置data-uid的值。 在_config.yml中找到 livere_uid 的属性字样。 将livere_uid设置为刚刚得到的data-uid的值即可。 部署在上述过程完成之后，部署到博客即可。12$ hexo g$ hexo d 演示完成后的效果如下，支持点赞和折叠评论，支持QQ、微信、微博等多种社交账号： 分析上面的配置过程还是比较容易的，但是如果细看一下我还是有一个疑问的，为什么没有用到来必力提供的安装代码呢，为什么只靠一个data-uid就完成了评论功能？ 在查看了NexT下的相关文件后，我得出了结论。 在 themes/next/layout/_partials 文件夹下，有一个 comments.swig 文件。 在里面可以看到支持多个评论插件的安装脚本，比如Facebook，多说等。 NexT用来加载来必力的安装脚本可以在第45～48行看到，加载脚本为：1234&#123;% elseif theme.livere_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; 这段脚本可以用来必力提供的安装代码替换,作用相同：123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="******"&gt;&lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script');&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 在来必力端可以看到具体的评论情况，包括数据分析和评论管理，功能还是非常强大的。 好了，今天的评论的配置就写这么多。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——bug篇]]></title>
    <url>%2F2019%2F02%2F15%2FHexo%E2%80%94%E2%80%94bug%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天写博客的时候，一套hexo操作行云流水，奈何一个hexo g报错报了几百行，在终端里的错误让人害怕的发抖，先上图为敬。 显然这些带有具体文件路径和出错位置的error很难直接百度到解决方法，在百度了很久之后，我找到一个貌似跟我的bug相关的关键词： YAMLException 这是一个在yaml文件中的报错。 于是怀着一个科班出身的计算机人的心态，我决定自己读报错改bug。 首先找到加载出错的原因： ERROR Theme config load failed. 这大概是主题配置文件加载失败了？？？ 其次是出错的文件： ERROR Process failed: _config.yml 果然是主题配置文件出错了！ 继续找一下出错原因： 12345678910111213141516171819202122232425YAMLException: bad indentation of a mapping entry at line 823, column 3: counter: true ^ at generateError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:165:10) at throwError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:171:9) at readBlockMapping (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1080:7) at composeNode (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1332:12) at readDocument (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1492:3) at loadDocuments (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1548:5) at Object.load (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1569:19) at Hexo.yamlHelper (/Users/jiahaonan/blog/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15) at Hexo.tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Hexo.&lt;anonymous&gt; (/Users/jiahaonan/blog/node_modules/bluebird/js/release/method.js:15:34) at Promise.then.text (/Users/jiahaonan/blog/node_modules/hexo/lib/hexo/render.js:61:21) at tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:694:18) at _drainQueueStep (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:138:12) at _drainQueue (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) 妈耶，一开始看到这些bug我已经准备放弃了，因为这些bug并没有影响我提交博客的相关操作。 但是每次 hexo g 后总跟着几百行报错我看起来很难受啊。 还是继续冷静的分析一下吧。 找到YAMLException的提示位置，第823行。 所以，原来是我多打了一个空格！ 好了，冷静地把空格删掉。 重来一遍hexo g，完美运行～ 这个案例告诉我们，修改文件的时候不要把空格不当回事儿，不然都是bug劝退。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——公式篇]]></title>
    <url>%2F2019%2F02%2F14%2FMarkdown%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[写完语法和配置之后，当然还得补充一项最常用的 公式 的写法了。 在写word的时候一直是无脑公式编辑器，看见琳琳用的 latex 的时候总是一脸崇拜，时至今日也得学习一下latex的公式表达，它也是markdown所支持的公式写法。 由于公式的书写要求和规范太多了，我这里就不做生产者了，老老实实做个搬运工。 贴两篇比较好的博客，方便学习～ https://www.jianshu.com/p/a0aa94ef8ab2https://www.cnblogs.com/q735613050/p/7253073.html]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——配置篇]]></title>
    <url>%2F2019%2F02%2F13%2FMarkdown%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[上一篇讲了Markdown的语法，接下来说一下Markdown的插件。 Markdown的编辑器有很多，知乎一下就可以看到不少开源友好的编辑器，为了更好的整合我电脑上现有的软件（为了省内存），我决定在sublime text上写Markdown。 我电脑的配置如下： Mac OS X 10.13.1Sublime Text Version 3.1.1 虽然sublime text3自身携带许多语言的高亮，但是还没有达到我想要的Markdown的编写环境，自带的Markdown不好看也不好用，所以需要拿一些插件来满足一下需求。 需要安装的插件： Package Control:插件安装管理MarkdownEditing:显示Markdown的语法和高亮 可选的插件： OmniMarkupPreviewer:浏览器/html快捷预览和导出MarkdownLivePreview:sublime text界面实时预览 Package ControlPackage Control是Sublime Text不可或缺的一个插件，许多插件的安装和管理都要用到它。两个月之前我在配置NASM的语法和高亮插件时安装配置了Package Control，才第一次接触到Sublime Text的除了写字板之外的功能，所以这里要强烈安利Package Control这一插件，让我有了对不止于Sublime Text写字板的用户体验。 安装插件 打开Sublime Text的控制台 快捷键：control + ` 手动：View -&gt; Show Console 在控制台输入下面的第一行python代码回车即可。不过里面的 http://packagecontrol.io/ 应该是被墙了，这个年头程序员没个VPN还怪麻烦的。我在一些博客里找到了镜像网站，如果第一段代码无法安装，可以尝试一下第二种方法（未测） 1import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 1import urllib.request,os,hashlib; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://dn-52cik.qbox.me/' + pf.replace(' ', '%20')).read(); open(os.path.join( ipp, pf), 'wb' ).write(by) 使用安装成功之后，可以在 Sublime Text -&gt; Preference 里看到 Package Control 这一选项，也可以通过组合键 command + shift + p 在搜索框里搜索 Package Control 。 在package control里，最主要使用的是 install package 功能，在install package界面，可以根据个人需求安装所需要的插件。 需要注意的是，最近不使用vpn是无法使用install package功能的，会出现如下提示： 在科学上网之后，可以来到install package的界面。注意已经安装过的插件在搜索里不会在出现，所以这里我的搜索里看不到MarkdownEditing的。 MarkdownEditing这一插件是在sublime text上写markdown的必须的插件，其包含了markdown的语法补全和高亮，效果如下： 除此之外，MarkdownEditing还提供了两个快捷代码段分别用于插入图片和链接： mdl + tab键：插入链接 [](link) mdi + tab键：插入图片 ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 下面来谈两款可选的插件 OmniMarkupPreviewer如果说MarkdownEditing满足了编辑markdown的需求，那么接下来就该谈一下预览需求了。OmniMarkupPreviewer 提供了html端的预览，其具有如下的快捷功能： command + option + o ：浏览器预览 command + option + x ：导出html control + option + c ：复制html代码 其浏览器端预览效果如下,我个人比较喜欢这种预览方式： MarkdownLivePreview当然，如果不喜欢在浏览器和编辑界面频繁切换，sublime text中也有一款在软件端满足实时预览功能的插件： MarkdownLivePreview同样是通过install package来下载安装，效果如下：不过比较可惜的是，由于是在sublime text端进行实时更新，在编辑文字时会有明显的卡顿，所以不是很推荐这一款插件的预览功能。 到此，在sublime text端编写和预览markdown的插件和环境就基本搞定了！ 部分参考自：https://www.jianshu.com/p/335b7d1be39e]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——语法篇]]></title>
    <url>%2F2019%2F02%2F11%2FMarkdown%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近一时兴起，想搭一个自己的blog玩一玩。 在子泰学长的引领下，我也选择了hexo这一开发框架，至于hexo在Mac上的配置的这些过程在此先省略不谈，我们来谈谈hexo上支持的文件 markdown 格式的语法总结。 一、标题Markdown的标题语法需要与 # 配合使用，在标题文字之前添加一到六个#即可生成一级标题到六级标题。 使用：123456#一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 演示：一级标题二级标题三级标题四级标题五级标题六级标题二、字体Markdown的可以对字体设置：粗体，斜体，斜体加粗和删除线四种。 使用：1234**粗体** (使用中 * 与 _ 的效果相同) *斜体* ***斜体加粗*** ~~删除线~~（注意这里的波浪线为半角符号） 演示：粗体斜体斜体加粗删除线 三、引用Markdown在使用引用时需要与 &gt; 配合操作，在需要应用的文字之前添加 &gt; 即可。 使用：123&gt;一级引用 &gt;&gt;二级引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;多级引用 演示： 一级引用 二级引用 多级引用 四、分割线Markdown中分割线可以用连续三个或三个以上的 - 或 * 来实现，一级标题和二级标题会自带下划线。我在sublime text3中用livepreviewer实时预览时发现，使用超过三个时预览端会出现乱码，但是在用html预览时一切正常。 使用：123---*** ------- 演示： 五、图片图片是一个比较麻烦的东西，但是sublime text3中的MarkdownEditing提供了生成图片格式的快捷键，通过使用快捷键或代码段可以直接生成。 使用：12快捷键：command+shift+k 代码段：mdi+tab键 演示：![]()![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 语法：1234567891011![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容,title可加可不加。如果要修改图片位置，可以用如下写法：&lt;div align=center/left/right&gt;![Alt text](/path/to/img.jpg &quot;Optional title&quot;)同样的，还可以用img标签来调整图片的大小，写法如下：&lt;img src=&quot;http:...&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt;这些写法与html的写法一致。 六、超链接MarkdownEditing也提供了生成超链接的快捷代码段，同样简化了实际操作。 使用：mdl+tab键 演示：[](link) 语法：12[超链接名](超链接地址 &quot;超链接title&quot;) 其中的title同样可加可不加 示例：12[百度](https://baidu.com) [微博](https://weibo.com) 演示：百度微博 七、列表Markdown中的列表分为无序列表和有序列表两种，MarkdownEditing中提供回车自动补全，列表之间可以相互嵌套。 无序列表语法：1234+、-或* + 空格 + 内容 + 无序列表 - 无序列表 * 无序列表 演示： 无序列表 无序列表 无序列表 有序列表语法：1234数字 + . + 空格 + 内容 1. 有序列表 2. 有序列表 3. 有序列表 演示： 有序列表 有序列表 有序列表 列表嵌套语法：123&apos;+&apos; + 一级标题tab + &apos;+&apos; + 二级标题tab + tab + &apos;+&apos; + 三级标题 演示： 一级列表 二级列表 三级列表 二级列表 八、表格表格的语法稍微复杂一点，不过可以把他理解为一个格式匹配的过程，也有一点在画图的意思。 语法：12345表头1 | 表头2 | 表头3 - | :-: | -: 靠左 | 居中 | 靠右 第二行用来格式匹配，默认为左对齐，:-:可以实现居中效果，-:实现右对齐 演示： 表头1 表头2 表头3 靠左 居中 靠右 九、代码Markdown中的代码可以放置在一对反引号 `` 中，注意反引号是键盘上数字 1 左边的键，并不是引号。 语法：`单行代码` ``` 多行代码 多行代码 ``` 参考自：https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
