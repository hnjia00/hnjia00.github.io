<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统——初步]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%88%9D%E6%AD%A5-1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统——初步]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[本次实验全部基于Ubuntu 16.04完成代码托管于GitHub：https://github.com/hnjia00/OS2019/tree/master/Code_Of_project1 系统调用实验Q1.阅读分别运行用API接口函数getpid()直接调用和汇编中断调用两种方式调用Linux操作系统的同一个系统调用getpid的程序: 请问getpid的系统调用号是多少？ Linux系统调用的中断向量号是多少？ A1.执行将两个文件分别命名为getpid_c.c和getpid_assembly.c，首先用gcc编译API接口调用程序，执行结果如下：可以看到程序分别输出了41580、41602、41612，其代表每次执行程序的进程识别码，且进程相互不同。其次用gcc编译汇编中断调用程序，其执行结果如下：程序的执行结果与API调用实现相同，可以实现输出进程的识别码。 系统调用号查阅有关博客，getpid的系统调用号分两个：在 32位系统下为 20，在 64位系统下为 39.本题的代码基于32位系统，所以程序中传入的系统调用号为 0x14，即 20. 中断向量号根据第二段汇编内嵌代码所提供的信息，其通过代码：INT 0x80 进入中断，所以Linux系统调用的中断向量号是 80H。 Q2.上机完成习题1.13 A2.linux系统调用的C函数形式为了实现打印输出“hello world”，这里选用系统调用函数write来实现，通过下面代码即可实现：123456#include &lt;stdio.h&gt;int main()&#123; write(1,"hello world!\n",14); return 0;&#125; 其中write的三个参数分别制定：输出方式、输出内容和输出长度。执行结果如下： 汇编代码通过C语言内嵌汇编的形式来打印“hello word”的方法如下：12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; char* msg = "Hello World!\n\r"; int len = 14; int result = 0; asm volatile("mov %2, %%edx;\n\r" /*传入参数：要显示的字符串长度*/ "mov %1, %%ecx;\n\r" /*传入参赛：文件描述符（stdout）*/ "mov $1, %%ebx;\n\r" /*传入参数：要显示的字符串*/ "mov $4, %%eax;\n\r" /*系统调用号：4 sys_write*/ "int $0x80" /*触发系统调用中断*/ :"=m"(result) :"m"(msg),"r"(len) /*输入部分：绑定字符串和字符串长度变量*/ :"%eax"); return 0;&#125; 程序的执行结果如下： Q3.阅读pintos操作系统源代码，画出系统调用实现的流程图. A3.由于并未实际操作过pintos系统，所以如何定位系统调用的区域或是执行流程是一个很大的问题。为此，我参考了Linux的系统调用流程，将Linux的系统调用思想转移到pintos系统上，下面是我的学习所得。 先拿Linux的系统调用read函数来举个例子，其实现流程如下： 在理解了Linux系统调用后，我尝试对pintos的项目源码进行了研读。Pintos系统调用的相关代码存储在：pintos\src\lib\user下的syscall.c、syscall.h和syscall-nr.h中。其中：syscall-nr.h用于存储系统调用号的声明，syscall.c和syscall.h则编写了系统调用函数的具体实现。还是继续拿read()函数来说明pintos的系统调用流程： 首先用户在用户程序中调用read函数。 接下来进入read函数的封装例程阶段，其对应syscall.c中的代码段： 在C库的read函数中，其返回了一个syscall3 (SYS_READ, fd, buffer, size);的指向，即系统调用处理程序。其中第一个参数SYS_READ即为read函数的系统调用号，该声明位于文件syscall-nr.h中： Syscall3函数的实现也位于syscall.c文件中，其代码如下： 从代码中可以看到，syscall3函数通过 INT $0x30 语句触发了系统的软中断。 承接syscall3的初始化函数位于src/userprog/syscall.c中，通过函数syscall_init调用执行intr_register_int来完成中断的初始化 接下来进入中断服务程序处理过程 中断服务处理程序位于src/threads/interrupt.c和src/threads/interrupt.h文件中，其中：interrupt.h定义了中断堆栈帧的各个寄存器以及中断程序的声明,通过syscall3的参数传入即可识别需要执行的功能： interrupt.c存储了中断服务程序的具体实现，中断的处理主要先依靠函数void intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,intr_handler_func *handler, const char *name)实现相关参数的初始化 进而通过调用函数：void intr_handler (struct intr_frame *frame)来实现：其函数的描述为： 处理所有中断，故障和异常。这个函数由汇编语言中断存根调用使用intr-stubs.S。 FRAME描述了中断和中断线程的寄存器。 通过中断程序的执行，从而得以调用系统调用服务例程。 所以，pintos的系统调用流程 应该为： 并发实验Q1.编译运行该程序（cpu.c），观察输出结果，说明程序功能。(编译命令： gcc -o cpu cpu.c –Wall)（执行命令：./cpu） A1.通过观察，可以得出程序的功能为：每隔一秒打印输入的参数或提示程序的正确输入格式。 Q2.再次按下面的运行并观察结果：执行命令：./cpu A &amp; ./cpu B &amp; ./cpu C &amp; ./cpu D &amp;程序cpu运行了几次？他们运行的顺序有何特点和规律？请结合操作系统的特征进行解释。 A2.观察程序可知，CPU的运行次数取决于while循环的执行次数，如果不强制终止程序，CPU将会一直运行下去。 程序的部分执行结果如下：从上图的执行结果中可以观察到：4个程序在每一轮都会轮流执行，而且执行的打印次序没有固定的顺序。这是因为：对于4个完全相同的程序而言，CPU的优先级是相同的，所以每一轮的执行顺序是随机的，没有特定的规律。 内存分配实验Q1.阅读并编译运行该程序(mem.c)，观察输出结果，说明程序功能。(命令： gcc -o mem mem.c –Wall) A1.程序的执行结果如图：程序首先打印指针p所指向的内存地址：0x19d2010及其对应的进程：41862其次程序每隔一秒打印指针p+1后的相对地址1、2、3… 及其对应的进程：41862 Q2.再次按下面的命令运行并观察结果。两个分别运行的程序分配的内存地址是否相同？是否共享同一块物理内存区域？为什么？命令：./mem &amp;; ./mem &amp; A2.调用两个进程同时执行程序mem.c，其结果如下：从上图可以看到，两个分别运行的程序分配的内存地址不同，两个指针分别指向内存：0x8a2010和0x2337010，因为指针指向的内存单元的地址不同，所以不共享同一块物理内存区域。 在尝试关闭ALSR地址空间随机化后再次运行程序，发现程序有变化： 所以两个分别运行的程序分配的内存地址本可以相同，但正是因为ALSR地址空间随机化后从而导致用户观测到的地址互不相同。 原因： Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存），而且更重要的是，用户程序可使用比实际物理内存更大的地址空间。 共享的问题Q1.阅读并编译运行该程序，观察输出结果，说明程序功能。（编译命令：gcc -o thread thread.c -Wall –pthread）（执行命令1：./thread 1000） A1.程序执行的输出结果如图：阅读代码可知，程序的功能为开启两个线程，同时执行子函数worker，实现对counter变量的loops*2次累加，最后打印counter的初值和累加结果。 Q2.尝试其他输入参数并执行，并总结执行结果的有何规律？你能尝试解释它吗？（例如执行命令2：./thread 100000）（或者其他参数。） A2.更改参数，程序执行的输出结果如图：从输出结果可以发现，counter的final值为输入参数的2倍，初始值恒为0.原因：虽然程序同时创建了两个线程执行worker函数，但两个线程均是对同一个counter变量进行相同次数的累加，所以最终结果总为loops的2倍，即输入参数argc的2倍。 参考文献使用库函数API和C代码中嵌入汇编代码两种方式使用同一个系统调用：https://blog.csdn.net/sunyeyi/article/details/44702575 linux系统调用号查询：https://blog.csdn.net/u012763794/article/details/78777938 Linux内存管理：https://www.cnblogs.com/ralap7/p/9184773.html]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——进程控制]]></title>
    <url>%2F2019%2F03%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[本次实验全部基于Ubuntu 16.04完成代码托管于GitHub: https://github.com/hnjia00/OS2019 最近的课程正在讲述进程有关的知识，老师说进程是面试的时候面试官最喜欢提问的话题，也是区分科班操作系统出身学生的一个标准，所以这部分内容和习题的实践性要远强于第一次。 Q1.打开一个vi进程。通过ps命令以及选择合适的参数，只显示名字为vi的进程。寻找vi进程的父进程，直到init进程为止。记录过程中所有进程的ID和父进程ID。将得到的进程树和由pstree命令的得到的进程树进行比较。 A1.第一题还是以基本操作为主，是一个按部就班的过程，下面就来逐步讲述。 打开vi进程只需在终端直接输入vi，执行结果如下： 接下来启动另一个terminal，通过命令 ps -A 查找 vi 的进程信息，结果如下： 在找到vi的进程号 pid 之后，可以继续从 ppid 处得到进程的父进程id，通过命令ps -l逐步寻找vi的父进程，寻找步骤如下： 在得到vi的进程调用序列之后，通过pstree命令来查看所有的进程树如下图所示，可以发现进程树命令和逐层寻找得到的结果相同，均为如下序列。 1Systemd-&gt;lightdm-&gt;lightdm-&gt;gnome-terminal-&gt;bash-&gt;vi 这里还要额外提一句，使用 Systemd 就不需要再用 init 了。这是因为init进程有两个缺点：启动时间长且启动脚本复杂。Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。 Q2.编写程序，首先使用fork系统调用，创建子进程。在父进程中继续执行空循环操作；在子进程中调用exec打开vi编辑器。然后在另外一个终端中，通过ps–Al命令、ps aux或者top等命令，查看vi进程及其父进程的运行状态，理解每个参数所表达的意义。选择合适的命令参数，对所有进程按照cpu占用率排序。 A2. 首先需要编写一个用于实现题干功能的C语言代码。分析题目可以看到，首先需要使用 fork() 系统调用创建子进程，其次根据fork的返回值相应的在父/子进程中填入对应的功能代码，我的代码具体如下，程序在父进程中执行空循环操作，在子进程中通过系统调用 execlp() 来启动vi进程，执行结果通过在另外的终端中的命令得以查看。 12345678910111213141516171819202122232425#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123; pid_t pid; pid = fork(); //父进程: pid&gt;0 if(pid &gt; 0) while(1); //子进程： pid=0 else if(pid == 0)&#123; int ret; ret = execlp("vi","",NULL); if (ret == -1)&#123; perror ("execl"); printf("excel error\n"); &#125; &#125; else if(pid == -1)&#123; perror("fork"); printf("fork error\n"); &#125; &#125; ps-Al执行 ps -Al命令的执行结果如下：其中，各个参数的解释如下： 参数 说明 F flag S 程序的状态 UID 执行者身份 PID 进程ID PPID 父进程ID C 使用的CPU资源百分比 PRI 进程的执行优先权 NI 进程的nice值 ADDR 内核函数 SZ 占用内存的大小 WCHAN 进程正在睡眠的内核函数名称 TTY 登入者的终端机位置 TIME 使用掉的CPU时间 CMD 下达指令的名称 ps aux执行 ps aux 命令可以打印使进程按如下格式输出：1USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 其中，各个参数的解释如下： 参数 说明 USER 行程拥有者 PID pid %CPU 占用的 CPU 使用率 %MEM 占用的记忆体使用率 VSZ 占用的虚拟记忆体大小 RSS 占用的记忆体大小 TTY 终端的次要装置号码 STAT 该行程的状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) START 行程开始时间 TIME 执行的时间 COMMAND 所执行的指令 执行结果如下：可以看到，./fork-exec进程一直在运行，且占用了97.7%的CPU资源，这应该全部归功于空循环。 toptop命令用于实时显示进程的动态，按照CPU的占有量降序排序，进程信息区统计信息区域的下方显示了各个进程的详细信息，各列的含义如下： 参数 说明 PID 进程id USER 进程所有者的用户名 PR 优先级 NI nice值。负值表示高优先级，正值表示低优先级 VIRT 进程使用的虚拟内存总量，单位kb RES 进程使用的、未被换出的物理内存大小，单位kb SHR 共享内存大小，单位kb S 进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) %CPU 上次更新到现在的CPU时间占用百分比 %MEM 进程使用的物理内存百分比 TIME+ 进程使用的CPU时间总计，单位1/100秒 COMMAND 命令名/命令行 执行结果如下： Q3.使用fork系统调用，创建如下进程树，并使每个进程输出自己的ID和父进程的ID。观察进程的执行顺序和运行状态的变化。 A3.实现进程树需要通过fork系统调用来实现，首先需要熟悉fork的具体作用。 fork在英文中是”分叉”的意思，fork函数启动一个新的进程，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段，子进程复制父进程的堆栈段和数据段。 所以也就是说，执行一次fork函数，有两个返回值。根据返回值的不同可以区别父进程(&gt;0)和子进程(=0)。 根据进程树的结构，p1有两个子进程p2和p3，同时p2也有两个子进程p4和p5，所以我所编写的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdbool.h&gt;#include&lt;sys/types.h&gt;int main(int argc, char *argv) &#123; /* 先打印根节点 */ pid_t p1; printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); if(p1 == 0)&#123; /* 进入进程p1 */ pid_t p3; /* 先创建p3 */ p3 = fork(); if(p3 == 0) /* j进入进程p3 */ printf("p3 pid: %d, ppid: %d\n", getpid(),getppid()); else if(p3 &gt; 0)&#123; /* 进入p3的父进程，也就是p1。 接下来创建进程p2 */ pid_t p2; p2 = fork(); if(p2==0)&#123; /* 进入进程p2,接下来先创建p4 */ printf("p2 pid: %d, ppid: %d\n", getpid(),getppid()); pid_t p4; p4 = fork(); if(p4 == 0)&#123; /* 进入进程p4 */ printf("p4 pid: %d, ppid: %d\n", getpid(),getppid()); &#125; else if(p4 &gt;0)&#123; /* 此处位于p4的父进程，即p2,继续创建p5 */ pid_t p5; p5 = fork(); if(p5==0) printf("p5 pid: %d, ppid: %d\n", getpid(),getppid()); &#125; &#125; &#125; &#125; sleep(1); &#125; 程序的输出结果如下，满足题目的进程树的架构： Q4. 修改上述进程树中的进程，使得所有进程都循环输出自己的ID和父进程的ID。然后终止p2进程(分别采用kill -9 、自己正常退出exit()、段错误退出)，观察p1、p3、p4、p5进程的运行状态和其他相关参数有何改变。 A4. 第四题应该是这几个题中最难的一个，综合了前三个题的知识应用，必须有对进程的充分认识和fork系统调用的理解才能实现这些功能，我的视线具体如下： 代码部分需要在第三题的基础上进行修改，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdbool.h&gt;#include&lt;sys/types.h&gt;int main(int argc, char *argv) &#123; /* 先打印根节点 */ pid_t p1; if(p1 == 0)&#123; /* 进入进程p1 */ int p1pid,p1ppid; p1pid = getpid(); p1ppid = getppid(); //printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); pid_t p3; /* 先创建p3 */ p3 = fork(); if(p3 == 0)&#123; /* j进入进程p3 */ int i; for(i=0;i&lt;10;i++)&#123; printf("p3 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else if(p3 &gt; 0)&#123; /* 进入p3的父进程，也就是p1。 接下来创建进程p2 */ pid_t p2; p2 = fork(); if(p2==0)&#123; /* 进入进程p2,接下来先创建p4 */ pid_t p4; p4 = fork(); if(p4 == 0)&#123; /* 进入进程p4 */ int i; for(i=0;i&lt;10;i++)&#123; printf("p4 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else if(p4 &gt;0)&#123; /* 此处位于p4的父进程，即p2,继续创建p5 */ pid_t p5; p5 = fork(); if(p5==0)&#123; //p5 int i; for(i=0;i&lt;10;i++)&#123; printf("p5 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else&#123; //p2 int i; for(i=0;i&lt;10;i++)&#123; //通过exit()终止p2 if(i==2) exit(1); //段错误 //if(i==5) //&#123; // int *p=NULL; // *p=0; //&#125; printf("p2 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; &#125; &#125; &#125; int i; for(i=0;i&lt;10;i++)&#123; printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; sleep(1); &#125; 即需要在刚进入p1的时候记录p1的pid和ppid以便后续打印输出，p2进程的输出部分需要控制在p5进程的父进程部分，如果在刚进入p2就执行循环输出，p4和p5进程就会因此无法创建。 程序的输出结果如下： 下面分别采用kill -9 、自己正常退出exit()、段错误退出来终止p2进程。 kill -9kill -9属于手动中断进程，通过此命令中断p2的结果如下：在p2被中断之后，其子进程p4和p5的参数ppid的值随即发生改变。 exit()exit()函数属于安放在代码中的正常退出函数，将其放入p2循环打印的代码中，控制其在特定次数后执行便可以达到我们的预期，结果如下：可以看到，由于p2先于其父进程p1结束，随即就变成了僵尸进程defunct状态 段错误所谓段错误，一般是访问了未申请的内存或非法的内存时产生的，概括点说在代码中一般是由指针的不当使用引起的。为了引起段错误，我在代码中设置了如下代码段：其执行结果如下： 参数变化对于每种错误我均使用了ps命令来查看进程参数信息，最后发现三种情况所造成的进程中断所带来的参数变化是一样的，p2进程的参数变化如下：从图中可以看到： 程序的状态由S变为Z，即僵死 占用内存大小变为0 WCHAN由hrtime变为‘-’，进程停止 cmd部分多了僵尸进程标识符 参考文献linux命令ps aux|grep xxx详解 https://www.cnblogs.com/robertoji/p/5555449.html linux的top命令参数详解 https://www.cnblogs.com/LeoBoy/p/7976612.html ps命令执行后各项参数的含义 https://blog.csdn.net/tcpipstack/article/details/8541980]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——存储过程和函数]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本次作业基于Mac OS X系统下的mysql workbench软件完成 存储过程在数据库编程中也是一个重要的角色，其主要的能力在于能被编译好放到服务器中，在使用时直接call即可调用执行，既能简化操作又能节省时间，能在优化层面起到一个很好的作用。 实验内容1、编写存储过程实现下列操作： （1）查询某读者、某段时间的借阅信息。已知读者姓名，查询起始和终止时间，列出其所有借阅信息。 （2）实现简单的图书入库操作（包含主键的少量信息即可）2、编写函数实现下列操作： 输入会员级别，返回该级别会员所借的图书总数量 解决方案编写存储过程（1）查询某读者、某段时间的借阅信息（已知读者姓名，查询起始和终止时间，列出其所有借阅信息 实现代码如下,其中 delimiter 是MySQL中的命令，这个命令与存储过程没什么关系，其作用就是告诉mysql解释器，该段命令是否已经结束了，mysql是否可以执行了。12345678910USE `bookmis`;DROP procedure IF EXISTS `borrow_book`;DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `borrow_book`(in reader_id varchar(5),in starttime date,in endtime date)BEGIN select * from borrows where borrows.reader_id=reader_id and borrows.Date_borrow&gt;=starttime and borrows.Date_return&lt;=endtime;END$$DELIMITER ; 我们用代码1call borrow_book('r001','2016-01-01','2017-01-01') 来进行测试，成功输出了r001在指定时间的借阅信息： （2）实现简单的图书入库操作（包含主键的少量信息即可） 代码如下，插入的参数为 book_id , book_name 和 Quantity_in 三个1234567891011121314DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `entry`(in id varchar(5),in book_name varchar(15),in amount int)BEGIN if id in (select book_id from books) then update books set Quantity_in=Quantity_in+amount where books.book_id=id; else insert into books(book_id,book_name,Quantity_in) values (id,book_name,amount); end if;END$$DELIMITER ; 由于存储过中写到了if条件判断，所以我们分别测试一下插入新书和插入旧书的结果。首先是插入新书，执行代码1call entry('b009','test_book',12) 结果如下：其次是插入旧书，执行代码1call entry('b001','并行计算',20) 结果如下： 编写函数（1）输入会员级别，返回该级别会员所借的图书总数量。 代码如下：123456789101112DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` FUNCTION`show_vipbooks`(vip_level varchar(6)) RETURNS int(11)DETERMINISTICBEGIN declare sum int; set sum = (select count(book_id) from readers,borrows where readers.level=vip_level and readers.reader_id=borrows.reader_id group by readers.level);RETURN sum;END$$DELIMITER ; 我们拿金卡用户做测试，可以观察到金卡用户 r001,r004:r001,r004总共借阅了图书5本，分别是b001,b002,b001,b002,b006: 执行代码：1select show_vipbooks('金卡') 函数执行结果如下： 小结存储过程和函数在课程设计和项目中都是一个比较重要的成分，其中很大一部分原因在于其代码的集成性。运用存储过程可以起到一个很好的简化代码的作用，只需一个入口参数即可实现重复的数据查询或数据定义的功能，比起繁琐的select语句，一个call起到的作用会更大，更何况其执行速度也得到了很好的优化。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——SQL调优]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94SQL%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[SQL调优是一项很重要的技术，实际在使用小数据集时DBMS自身的搜索优化是能满足我们的时间需求的，只有在数据集规模到10w+以后才能在秒级的层面看到SQL代码优化的效果。 本次实验环境如下： 操作系统：Mac OS X 10.13 DBMS：MySQL 8.0 图形化管理界面：MySQL Workbench 表结构本次实验选用了一个待测试表，名为‘pv_train_part1’，其结构如下： 名称 类型 实例 Key int 5 Feature1 double 1.294408418 Feature2 double 1.331507473 Feature3 double 1.279030084 Feature4 double 0.545543622 Feature5 int 64125 Feature6 double 1.738819447 Feature7 double 0.88708635 Feature8 double 28622.91442 label int 0 数据仿真方法此数据集来源于我跟随老师做的项目，从数据实例和分布来看其明显是一个机器学习模型的训练数据样本，大体是一个八参数的分类问题（实则是一个多参数的特征选取和异常数据监测项目）。 本数据取自github上的开源数据集，其链接为：数据集 数据记录数通过MySQL Workbench的‘Table Data Import Wizard’功能，可以实现将外部csv文件导入的功能： 通过执行结果可以观测到数据记录数如下： 优化规则及执行时间优化规则一:建立索引首先我使用的第一条优化规则便是建立索引，这在几乎所有的DBMS上是通用的优化策略。为了便于展示，这里的优化执行结果以执行查询操作来作为反馈。 在没建立索引前，表的设计层面如下：执行查询语句：1select feature3 from pv_train_part1 where pv_train_part1.key=59081; 结果如下： 可以看到该查询的执行时间为： 0.056 second 。 然后我们给key属性添加主键索引，添加完之后设计层面如下： 添加完成之后重新执行相同的查询语句，执行时间如下： 可以看到，在添加完主键索引之后，查询时间变成了 0.00034 second，较未添加索引之间查询效率提高了 163 倍。 优化规则二:查询限制在MySQL中，假如只需要一条查询条件的结果，或者在事先已经知道查询语句仅仅会返回一条结果的情况下，我们可以在查询语句的结尾后添加 “limit 1” 字段以便在查询到结果后中断对剩余表单的检索，对比如下： 首先我们对表执行查询语句：1select feature3 from pv_train_part1 where pv_train_part1.label=3 ; 查询时间如下： 可以看到，通过普通查询语句查询，其执行时间在 0.039 second。 然后对上述sql语句后添加 “limit 1” ，修改为：1select feature3 from pv_train_part1 where pv_train_part1.label=3 limit 1; 查询时间如下：可以看到，在添加limit 1后，其执行时间缩短为了 0.00049 second，相较于优化前的查询，效率提高了 203 倍。 通过这几个案例可以看出，SQL调优可以为数据库的查询操作提高近百倍的效率，是我们在开发大型工程中的必备知识。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——完整性]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AE%8C%E6%95%B4%E6%80%A7%2F</url>
    <content type="text"><![CDATA[数据库的完整性是一块很重要的知识，涉及到表、视图等的各种约束，是保证数据库或项目正常运行的根本保证，也是继SQL语句后的第二块重要的知识点。 完整性主要包括：实体完整性，参照完整性和用户自定义完整性。当然，在dbms下，用户接触最直接的就是用户自定义完整性和外键的参照完整性，所以下面的实验主要以后两者为主。 用户自定义完整性check语句使用check子句定义如下约束条件:• 读者证件只能是“身份证”或“护照”；• 读者手机号是以“1”打头的11位字符,后10位只能是数字。 解决方案 由于mysql不支持check方法，所以为了完成本题的要求，我对各自问题编写了一个触发器以实现所需功能。 Q. 读者证件只能是“身份证”或“护照”A.123456CREATE DEFINER=`root`@`localhost` TRIGGER `readers_BEFORE_INSERT` BEFORE INSERT ON `readers` FOR EACH ROW BEGIN if NEW.Card_name not in ('身份证' ,'护照') then delete from readers where Card_name = new.Card_name; end if;END 执行错误插入（Card_name=’其他’）如下： 触发器功能启动，报错如下： 执行正确插入（Card_name=’护照’）如下： 语句成功执行： 其实用check语句实现很容易，只需要在表的定义语句中加上check Card_name in (&#39;身份证&#39; ,&#39;护照&#39;)即可实现。 Q. 读者手机号是以“1”打头的11位字符,后10位只能是数字A. 由于mobile为varcher型，直接设置 正则 比较即可1234CREATE DEFINER=`root`@`localhost` TRIGGER `readers_BEFORE_INSERT` BEFORE INSERT ON `readers` FOR EACH ROW BEGIN if NEW.mobile not REGEXP '^[1][0-9]&#123;10&#125;$' then delete from readers where mobile = new.mobile; end if;END 执行错误插入（mobile=2…）如下： 触发器功能启动，报错如下： 触发器编写触发器，实现以下约束• 已挂失的借书证不能再借书；• 向借阅表增加一个借书记录后，在图书表里该图书的出借数自动加1。 解决方案Q. 已挂失的借书证不能再借书A. 由题意可知，存在于loss_reporting表中的用户不能再向borrow表中插入数据，所以代码实现如下：12345678CREATE DEFINER=`root`@`localhost` TRIGGER `borrows_BEFORE_INSERT` BEFORE INSERT ON `borrows` FOR EACH ROW BEGIN if exists(select loss_reporting.reader_id from loss_reporting where(loss_reporting.reader_id = new.reader_id)) then delete from borrows where reader_id = new.reader_id; end if;END Q. 向借阅表增加一个借书记录后，在图书表里该图书的出借数自动加1A.12345678CREATE DEFINER=`root`@`localhost` TRIGGER `borrows_AFTER_INSERT` AFTER INSERT ON `borrows` FOR EACH ROW BEGIN if new.book_id in (select book_id from books) then update books set Quantity_out=Quantity_out+1 where books.book_id=new.book_id; end if;END 参照完整性参照完整性决定了外键约束，即在引用表中外键的值只能设置为被引用表中的值或为null 自定义违约处理将读者表的‘会员级别’外键的违约处理策略定义为置默认值“null” 解决方案在删除或更新外键时，子表置空 123456ALTER TABLE `bookmis`.`readers` ADD CONSTRAINT `level` FOREIGN KEY (`level`) REFERENCES `bookmis`.`member_level` (`level`) ON DELETE SET NULL ON UPDATE SET NULL; 在添加外键约束之后，我们将member_level表中的‘普通’删去，然后观察readers表中的数据变化如下： readers表原始数据： readers表执行删除后的结果如下： 可以观察到‘普通’全被置换为了null; 接下来我们将‘银卡’更新为‘白卡’可以看到readers表中的‘银卡’也被修改为了null（这里可能用cascade效果更好）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——安全性练习]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%80%A7%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[登录验证要求能够以2种登录方式登陆（ Windows 身份验证和SQL Server身份验证）。 解决方案 由于我的作业是基于 Mac OS X 系统下，用 mysql workbench 完成，故下面展示如何在Mac上登陆mysql workbench。 首先打开mysql workbench可以看到如下登录界面，选择 loacl instance ，实现Mac OS X系统本地登陆，操作步骤如下： 第二次，打开mysql workbench，选择 nlz 用户登陆，实现mysql workbench身份验证登陆，操作步骤如下: 权限分配新建登陆log1，新建用户u1，新建角色r1，授予角色 r1 对表S的select权限，将角色r1赋给用户u1，验证用户u1只具有表S的select权限，收回用户u1的角色r1，验证用户u1不具有表S的select权限。 要注意的是，角色 role 是 mysql8.0 版本之后才有的，在 mysql5.x 版本里不存在 role 解决方案 新建登陆log1如下： 新建用户u1： 1CREATE USER 'u1'@'localhost'; 新建角色r1: 1CREATE role r1; 授予角色 r1 对表books的select权限： 1grant select on bookmis.books to r1; 将角色r1赋给用户u1： 1grant r1 to 'u1'@'localhost' 激活角色:激活之前，没有角色处于运行状态，状态如下： 1SET DEFAULT ROLE ALL TO 'u1'@'localhost'; 通过执行上述代码实现对u1用户的相关角色的激活操作，激活之后通过代码：SELECT CURRENT_ROLE()查询活动的角色，如下： 验证用户u1只具有表books的select权限： 1SHOW GRANTS FOR 'u1'@'localhost' USING 'r1'; 输出u1具有的权限如下，可以看出，其只具有bookmis.books的select权限. 在u1用户上执行对books执行select操作，查询成功，结果如下： 继续执行查询readers表的操作，查询失败，结果如下： 收回用户u1的角色r1，验证用户u1不具有表books的select权限： 1REVOKE r1 FROM 'u1'@'localhost'; 回收r1之后我们执行代码：SHOW GRANTS FOR &apos;u1&apos;@&apos;localhost&apos; USING &apos;r1&apos;查看u1现在具有的权限，结果如下： 验证r1被回收，所以u1也丧失了相应的权限。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——SQL练习]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94SQL%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[计网的实验差不多整理完毕了，今天开始陆续整理一下数据库的实验吧，大三上最喜欢的课程就是数据库，所以我觉得作业的完成质量还是可以恭维的。 关系模式关系模式使用的是课程给出的图书管理系统，涉及到六个关系模式，包括两个实体和四个联系。先省略，以后有时间补齐。 SQL：数据查询在bookmis数据库中完成下列SQL查询：1、查找借了会员“李红 ”所借的全部图书的会员姓名2、查找没有借科普类图书的会员姓名3、查找借了2本及以上图书的银卡会员的姓名4、将计算机类图书的入库数加15、用insert命令向图书类别表中添加记录（‘ca07’ , ‘儿童’）6、用delete命令从图书类别表中删除类别‘儿童’7、把金卡读者的读者名和性别存入另一个已知基本表vip_readers (Reader_name,sex)中8、建立一个计算机类图书的视图，显示书编号、书名和出版社9、建立一个分组视图，显示每种级别会员的数量10、在（9）建立的分组视图中查询金卡会员的数量11、自己编写并实现一个能成功执行的视图更新任务 查询方案 本次作业基于MAC OS X系统下的mysql workbench软件完成 Q. 查找借了会员“李红 ”所借的全部图书的会员姓名A. 代码：基本思想为逻辑蕴含的转化:1234567891011select reader_name from readerswhere reader_id in (select distinct reader_id from borrow ba where not exists (select * from borrow bb where reader_id=(select reader_id from readers where reader_name='李红') AND not exists (select * from borrow bc where bc.reader_id=ba.reader_id AND bc.book_id=bb.book_id)) AND reader_id&lt;&gt;(select reader_id from readers where reader_name='李红')); Q. 查找没有借科普类图书的会员姓名A. 代码:123456select reader_name from readerswhere reader_id in (select reader_id from borrow,books,b_category where borrow.book_id=books.book_id AND books.category_id=b_category.category_id AND b_category.category&lt;&gt;'科普'); Q. 查找借了2本及以上图书的银卡会员的姓名A.123456select reader_name from readerswhere level='银卡' AND reader_id in( select reader_id from borrow group by reader_id having count(reader_id)&gt;=2); Q. 将计算机类图书的入库数加1A.1234set sql_safe_updates=0; #mysql中必须降低安全等级才能够批量操作update booksset Quantity_in=Quantity_in+1where Quantity_in&gt;=0; Q. 用insert命令向图书类别表中添加记录（‘ca07’ , ‘儿童’）A.123insert #插入指令into b_category(category_id,category)values('ca07','儿童'); Q. 用delete命令从图书类别表中删除类别‘儿童’A.123delete #删除指令from b_categorywhere(category='儿童'); Q. 把金卡读者的读者名和性别存入另一个已知基本表vip_readers (Reader_name,sex)中A.12345678create table vip_readers (Reader_name varchar(50), sex varchar(2) ); #创建表insert into vip_readers(Reader_name,sex) #插入数据select readers.reader_name,readers.sexfrom readerswhere level='金卡'; Q. 建立一个计算机类图书的视图，显示书编号、书名和出版社A.12345create view cs_book(book_id,book_name,publishing) #创建视图asselect book_id,book_name,publishingfrom books,b_categorywhere books.category_id=b_category.category_id AND b_category.category='计算机'; Q. 建立一个分组视图，显示每种级别会员的数量A.12345create view vip_count(level,number)asselect readers.level,count(level)from readersgroup by readers.level; #分组 Q. 在建立的分组视图中查询金卡会员的数量A.123select level,numberfrom vip_countwhere level='金卡'; Q. 自己编写并实现一个能成功执行的视图更新任务A.123update cs_bookset book_name='abc'where book_id='b001'; SQL：数据定义1、新建数据库Student12、在Student1数据库中新建表S1、C1和 SC1 ,指明主外键（结构与S,C,SC相同）3、在表S1中新增一列addr CHAR（20)4、删除表S1中的列addr5、在表SC1的列sno上建立升序索引6、删除表SC1 定义方案Q. 新建数据库Student1A.1create schema student1 Q. 在Student1数据库中新建表S1、C1和 SC1 ,指明主外键（结构与S,C,SC相同）A.1234567891011121314151617181920create table S1( sno char(4) primary key not null,#主键 sname char(8) not null, age int, sex char(1)); #建表S1create table C1( cno char(4) primary key not null,#主键 cname char(8) not null, tname char(10)); #建表C1create table SC1( sno char(4) not null, cno char(4) not null, grade int, primary key(sno,cno),#指定主键 foreign key(sno) references S1(sno),#指定外键 foreign key(cno) references C1(cno),#指定外键 check (grade is null or grade between 0 and 100)); #建表SC1 Q. 在表S1中新增一列addr CHAR（20)A.12alter table S1 add addr CHAR(20); Q. 删除表S1中的列addrA.12alter table S1 drop addr; Q. 在表SC1的列sno上建立升序索引A.12create index sno1 on SC1(sno asc); Q. 删除表SC1A.1drop table SC1; 小结SQL的数据定义和数据查询语句都是基础的语法，也是在后续编程中最常用到的语句，这里的基础一定要打牢，做项目和课程设计是也就是建立在这些基础语法之上的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——交换机VLAN实验]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%9C%BAVLAN%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[实验目的 熟悉 VLAN 的技术背景和原理 熟悉 VLAN 的基本配置方法和配置命令 在交换机上实现 VLAN 的划分 实验拓扑其中PC_A接port1口，PC_C 接port 2口，PC_B接port 1口，PC_D接port 2口， 两台交换机之间接port24口。 实验环境 系统：Windows7软件工具：Cisco Packet Tracer实现途径：软件模拟实现 实验过程本次实验分别从 Packet Tracer 软件模拟以及 实验室实地操作 共同实现： Packet Tracer模拟选择实验仪器利用Packet Tracer选取实验仪器是一件比较容易的事情，仅依靠拖拽功能即可实现布局。 交换机在左下方的控件选择中，我们选中Switches，然后根据实验指导的要求，选中2950T型号的交换机两台，如图所示： PC机根据实验指导书的要求，本次实验需要4台PC机以备测试。继续在控件中找到End Devices，从中找到Generic即为满足实验要求的PC机，如图所示： 构建网络拓扑根据实验指导的要求，PC-A和PC-B分别接两台交换机的port1口，PC-C和PC-D分别接两台交换机的port2口，两条交换机之间接port24相连。利用Packet Tracer建立网络拓扑也是一件比较容易的事情，完成布局如下： 更具体的，我们可以看到交换机的port1、port2和port24被连接挂起： 划分VLAN在连接构建好网络拓扑结构后，我们需要对交换机进行一些配置。在上一个过程中，我们分别连接占用了1、2和24口，所以在这一步我们需要分别对两个交换机的这三个口进行VLAN的划分。分别进入Switch3和Switch4的CLI界面，根据实验指导输入命令用以实现划分，操作如下： 根据实验指导，配置完成之后可以调用命令show vlan和show running-config查看划分情况和配置。 配置PC在配置完交换机后，下一步需要完成对四个PC机的配置，这里的配置实质上是完成对PC机的IP参数的配置，包括IP地址、子网掩码和默认网关等。在PC机的desktop的IP configure界面可以完成上述配置，如图所示： 实验结果完成PC和交换机的配置后，我们可以在PC机的命令行界面执行Ping命令，用以检查是否完成实验要求。按照网络拓扑结构，在我们的测试网络中，PC-A可以Ping通PC-B，但是不能Ping通PC-C和PC-D。 实验室实地操作通过在软件上模拟之后，我对本次实验的具体原理、操作和内容又了进一步的理解。而后在周四的实验上机中，我通过具体的连线和上手操作完成了本次实验的全部要求。 配置交换机实验室的交换机不需要我们再通过超级终端去配置，所以我们只需要对待使用的两台交换机分别划分好vlan和端口即可。 通过两条telnet命令分别连接10007和10008端口进行配置。1telnet 172.31.44.240 10007 1telnet 172.31.44.240 10008 依照实验指导，我们将命令依次输入，实现port24相连，vlan10和vlan20对port1和port2的划分，配置结果如下： PC测试在配置完交换机之后，下一步便该进行PC之间的测试了。依照实验指导的要求，我们需要4台PC分别连接两台交换机的port1和port2。 为了简化实验操作，在实验中我选择了两台PC（分别为192.168.1.2和192.168.1.3）分别连接 &lt; switch1:port1, switch2:port1&gt;&lt; switch1:port1, switch2:port2&gt;&lt; switch1:port2, switch2:port1&gt;&lt; switch1:port2, switch2:port2&gt; 以满足实验要求。 测试结果如下： 接相同端口的情况下可以相互ping通 接不同端口的情况下不可以相互ping通]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——实现路由算法]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 Dijkstra 算法的路由软件。 实验环境 系统：Mac OS X 10.13.1语言：Python 3.6.5平台：pycharm外部库：networkx，matplotlib 实验过程代码设计现Dijkstra算法的方法有很多种，为了在最短的代码内实现最好的效果，我选择了python来实现，借助networkx的有向图类DiGrapg接口实现了图的存储，通过自己实现的Dijkstra算法完成了搜索。 图的构造我们这里借助networkx库里的DiGraph类来构造有向图。DiGraph存储有向图的边的形式为形如(s，d，w)的三元组形式，其中： s: 边的起点；d: 边的终点；w: 边的代价. 考虑到操作的便捷性，我们使用一个path.txt文件来实现图的各个边的三元组的存储，path.txt的格式如下： 定义好边的数据结构之后，我们利用networkx中的函数add_edge()来实现边的输入和图的构建 12345for line in open("path.txt","r"): #按行读取文件 data.append(line.strip('\n')) for row in data: row=row.split(',') #分割三元组 G.add_edge(eval(row[0]), eval(row[1]), weight=eval(row[2]) Dijkstra算法算法实现的流程图如下： 演示部分networkx库同样集成了图的绘制函数，我们通过与matplotlib库的协同操作来完成图的搜索演示。通过以下代码来实现图的分屏：123plt.figure(figsize=(14, 6)) plt.subplot(121)plt.subplot(122) 通过以下代码来实现初始图的绘制：12pos = nx.spring_layout(G)nx.draw_networkx(G, pos,node_size=300,node_color='#FFB5C5') 通过以下代码来实现图上搜索路径的绘制：123456# 绘制非路径上的边 edges_not_in_path = list(set(G.edges()) - set(edges))edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges_not_in_path]nx.draw_networkx_edges(G, pos, edgelist=edges_not_in_path, edge_color='b',width=edgewidth) # 绘制路径上的边 edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges]nx.draw_networkx_edges(G,pos,edgelist=edges,edge_color='r',width=edgewidth) 执行结果我们这里把网络类比为一个有向图，事实上路由的传输方向可以是双向的。其中，图‘Test Graph’即为初始图；对于图‘The shortest path from 0 to 6’： 红色边：通过Dijkstra算法搜索到的最小代价路径；蓝色边：未采纳的边；边的粗细程度：边的权值，越细代表权值越小. 为了验证我们得到的路径是否是正确的答案，我们使用networkx库中标准的函数进行检验，代码如下：answer=nx.dijkstra_path(G,source=start_node,target=end_node)可以得到输出的answer路径如下，与我们的代码所得出的答案相同： 代码附录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import networkx as nx import matplotlib.pyplot as plt #路由算法实现 def Dijkstra(G,start,end): RG = G.reverse() dist = &#123;&#125; previous = &#123;&#125; for v in RG.nodes(): dist[v] = float('inf') previous[v] = 'none' dist[end] = 0 u = end while u!=start: u = min(dist, key=dist.get) distu = dist[u] del dist[u] for u,v in RG.edges(u): if v in dist: alt = distu + RG[u][v]['weight'] if alt &lt; dist[v]: dist[v] = alt previous[v] = u path=(start,) last= start while last != end: nxt = previous[last] path += (nxt,) last = nxt return path #初始化图函数 def init(G): data = [] for line in open("path.txt","r"): #按行读取文件 data.append(line.strip('\n')) for row in data: #分割三元组 row=row.split(',') G.add_edge(eval(row[0]), eval(row[1]), weight=eval(row[2])) return G if __name__=="__main__": #路由算法实现 G=nx.DiGraph() G=init(G) start_node = 0 end_node = 6 path=Dijkstra(G,start_node,end_node) #标准库函数检测 answer=nx.dijkstra_path(G,source=start_node,target=end_node) print("nx.dijkstra_path's path:") for i in range(len(answer)-1): print(str(answer[i])+'-&gt;',end="") print(answer[i+1]) # 构造最小权值边路径 edges=[] for i in range(len(path)-1): edges.append((path[i],path[i+1])) #绘制初始图 plt.figure(figsize=(14, 6)) plt.subplot(121) plt.title("Test Graph") pos = nx.spring_layout(G) nx.draw_networkx(G, pos,node_size=300,node_color='#FFB5C5') #绘制最小路径结果 plt.subplot(122) plt.title("The shortest path from %d to %d" % (start_node, end_node)) nx.draw_networkx_nodes(G, pos=pos, node_size=300,node_color='#FFB5C5') # 绘制非路径上的边 edges_not_in_path = list(set(G.edges()) - set(edges)) edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges_not_in_path] nx.draw_networkx_edges(G, pos, edgelist=edges_not_in_path, edge_color='b',width=edgewidth) # 绘制路径上的边 edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges] nx.draw_networkx_edges(G, pos, edgelist=edges, edge_color='r',width=edgewidth) #显示 plt.show()]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——实现Go-Back-N]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0Go-Back-N%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 Go-Back-N 的可靠数据传输软件。 实验环境 系统：Mac OS X 10.13.1语言：Java开发平台：eclipse内部库：java.net，java.util 实验过程代码设计为了完成本次试验的要求，我编写了两个Java代码文件，分别实现server端功能和client端功能： server端代码流程主要算法流程如下所示，server端实现在一定丢包率范围内接收数据包并且回传ACK： client端代码流程主要的算法流程如下，client端主要实现数据包的传送以及延迟处理： 主机ip获取在启用Go-Back-N之前，我们首先需要获得个人电脑的IP。在Mac OS X系统，使用终端命令ifconfig即可直接查看主机IP，具体如下： 丢包率为0下的测试为了验证代码的正确性，我首先先把丢包率设置为0查看了具体的传输流程，代码执行结果如下： 窗口长度 windowSize = 4；数据包总数 num = 10；超时限制 Timer = 1000ms 执行结果如下： 丢包率为10%下的测试为了继续验证代码的正确性，而后我把丢包率设置为10%查看了具体的传输流程，代码执行结果如下： 小结本次实验中，我们完成了java的网络编程，模拟了GBN算法的运行，对GBN协议有了进一步的了解。在GBN协议中，接收方会丢弃所有失序的分组，尽管丢弃一个正确接收但是失序的分组有点浪费。但是根据GBN的原理。假定当前期望的编号是n，但是n+1提前达到。因为数据必须是有序交付，接收方可能缓存分组n+1，然后在他收到并交付分组n后，再将该分组交付到上层。但是如果n丢失，则n和n+1的分组都会被重发，因此，接收方只需要丢弃分组n+1即可。这种方法的优点是接收方缓存简单，即接收方不需要缓存任何失序分组。对于发送方来说，他只需要维护窗口的下边界和和nextseqnum在窗口中的位置。对于接收方来说，只需要维护下一个按序接收的分组的序号。 代码附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/************************发送方************************/public class Client &#123; //定义流量窗格长度，起始和终止数据包号，计时器 public static int windowSize; public static int start=0, end, num; public static long timerTime = 0; public static void main(String[] args) throws Exception &#123; //建立连接 InetAddress serverAddress = InetAddress.getByName("192.168.1.106"); DatagramSocket clientSocket = new DatagramSocket(9999); byte[] sendData; Timer timer = new Timer(); timer.schedule(new DelayActionListener(clientSocket), 0L, 500L); //通过输入初始化参数 Scanner scanner = new Scanner(System.in); System.out.println("Please enter number of packets: "); num = scanner.nextInt(); System.out.println("Please enter slide window size: "); windowSize = scanner.nextInt(); System.out.println(); end = start + windowSize; //启动计时 Timer[] timers = new Timer[num]; long startTime = System.currentTimeMillis(); //首先发送第一个流量窗内的数据包 System.out.println("&lt;--Client send packets " + start + " - " + (start+windowSize-1)); for (int i=start;i&lt;end;i++)&#123; sendData = (i + "seq").getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, 8888); clientSocket.send(sendPacket); &#125; //循环发送剩余的数据包 while (true)&#123; byte[] recvData = new byte[100]; DatagramPacket recvPacket = new DatagramPacket(recvData, recvData.length); clientSocket.receive(recvPacket); String in = new String(recvPacket.getData()).trim(); int ack_seq = Integer.parseInt(in.substring(3, in.length())); System.out.println("--&gt;Client received ACK: " + (ack_seq-1)); //正常情况 if (ack_seq &gt;= start &amp;&amp; ack_seq &lt; end)&#123; int oldEnd = end; start = ack_seq; end = ack_seq + windowSize; if (end &gt; num) end = num; //发送数据包 for (int i = oldEnd; i &lt; end; i++) &#123; sendData = (i + "seq").getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, 8888); clientSocket.send(sendPacket); System.out.println("&lt;--Client sent packet "+i); &#125; timerTime = System.currentTimeMillis(); &#125; //传到流量窗的右界限 if (ack_seq == end) timerTime = 0; //传输结束 if (ack_seq == num)&#123; timer.cancel(); System.out.println("Success sent all packets"); System.out.println("Time to send " + num + " packets successfully was " + (System.currentTimeMillis() - startTime) + "ms"); return; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/************************接收方************************/public class Server &#123; public static void main(String[] args) throws Exception &#123; //创建套接字，初始化参数 DatagramSocket serverSocket = new DatagramSocket(8888); int endReceive = 0; int missedCtr = 0; System.out.println("\n\n\nServer started.\n"); while (true)&#123; byte[] data = new byte[100]; //接收数据包 DatagramPacket receivePacket = new DatagramPacket(data, data.length); serverSocket.receive(receivePacket); //截取seq String in = new String(receivePacket.getData()).trim(); int seq = Integer.parseInt(in.substring(0, in.length() - 3)); System.out.println("Received packet " + seq+"&lt;--"); //在一定丢包率的范围内操作 if (seq == 0 || Math.random()&lt;=0.9)&#123; //接收数据包并发送ACK if (seq == endReceive)&#123; endReceive++; byte[] ackData = new String("ack"+endReceive).getBytes(); InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); DatagramPacket sendPacket = new DatagramPacket(ackData, ackData.length, clientAddress, clientPort); serverSocket.send(sendPacket); System.out.println("Server sent ACK: " + seq+"--&gt;"); &#125; //有数据包超前到达 else if (endReceive != 0)&#123; if (seq == endReceive + 1) &#123; System.out.println("Packet lost or disordered on way to server: " + endReceive); missedCtr++; System.out.println("Missed: " + missedCtr); &#125; byte[] ackData = new String("ack"+(endReceive)).getBytes(); InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); DatagramPacket sendPacket = new DatagramPacket(ackData, ackData.length, clientAddress, clientPort); serverSocket.send(sendPacket); System.out.println("Server sent ACK: " + (endReceive-1)+"--&gt;"); &#125; &#125; //有数据包丢失 else &#123; System.out.println("Drop packet " + seq); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——用smtp实现Email客户端]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%94%A8smtp%E5%AE%9E%E7%8E%B0Email%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 smtp 协议的 Email 客户端软件。 实验环境 系统：Mac OS X 10.13.1语言：Java连接协议：smtp邮箱主机：smtp.qq.com（qq邮箱）外部jar文件：javax.mail.jar 实验过程代码部分为了完成本次试验的要求，我编写了一个Java代码文件，具体的算法流程如下： 邮箱端配置为了方便起见，我在这里使用qq邮箱作为我的测试邮箱，但是qq邮箱默认是关闭smtp服务的，所以我们需要先开启smtp协议。 首先在qq邮箱的个人账户部分找到如下服务的对应位置（此图为开启之后所截，故显示已经开启）： 配合手机操作操作之后，我们可以得到如下的开通反馈，其中返回的授权码极为重要，其关系到代码中transport.connect（）方法的执行成功与否： 代码测试由查阅可得，qq邮箱的服务器如下，且使用端口为465或587：将服务器（smtp.qq.com）、端口(465)、收件人(835381071@qq.com)发件人邮箱(835381071@qq.com)和标题内容设置好之后，通过授权码执行连接，可以debug测试输出如下： 执行结果最后为了验证我们的执行结果，打开qq邮箱的收件箱，可以看到如下信息： 代码附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package smpt;import java.util.Properties;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;public class SendmailUtil &#123; public static void main(String[] args) throws AddressException, MessagingException &#123; Properties properties = new Properties(); // 使用smtp协议 properties.put("mail.transport.protocol", "smtp"); //qq邮箱的主机名 properties.put("mail.smtp.host", "smtp.qq.com"); //qq邮箱使用465端口 properties.put("mail.smtp.port", 465); // 端口号 //login验证 properties.put("mail.smtp.auth", "true"); //使用ssl安全连接 properties.put("mail.smtp.ssl.enable", "true"); // 设置是否显示debug信息 true 会在控制台显示相关信息 properties.put("mail.debug", "true"); // Session用于收集JavaMail运行过程中的环境信息 Session session = Session.getInstance(properties); // 获取邮件对象 Message message = new MimeMessage(session); // 设置发件人邮箱地址 message.setFrom(new InternetAddress("835381071@qq.com")); // 设置收件人地址 message.setRecipients( RecipientType.TO, new InternetAddress[] &#123; new InternetAddress("835381071@qq.com") &#125;); // 设置邮件标题 message.setSubject("smtp测试邮件"); // 设置邮件内容 message.setText("内容：smtp发送邮件成功！"); // 得到邮差对象 Transport transport = session.getTransport(); // 连接自己的邮箱账户 transport.connect("835381071@qq.com", "sgxclkuvvirtbdfe"); // 发送邮件 transport.sendMessage(message, message.getAllRecipients()); &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——JAVA实现web服务器]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94JAVA%E5%AE%9E%E7%8E%B0web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[趁着这几天刚开学，时间还比较宽裕，决定来整理一下自己的实验报告，先从计网开始。 实验目的 处理一个 http 请求 接收并解析 http 请求 从服务器文件系统中获得被请求的文件 创建一个包括被请求的文件的 http 响应信息 直接发送该信息到客户端 实验环境 系统：Mac OS X 10.13.1 语言：JAVA 浏览器：Google Chrome 实验步骤前期准备为了完成本次试验的要求，我编写了两个java代码文件，分别命名为：“HttpRequest.java”和“WebServer.java”。除此之外，我还编写了两个带跳转的测试网页“index.html”和“next.html”以及其各自包含的图片“first.jpg”和“next.jpg” HttpRequest.java的主要功能为：获取http请求中的套接字的输入流和输出流，即完成“对从服务器端发回的数据流”和“将要发送到服务器端的数据流”的处理和输出。 WebServer.java的主要功能为：创建线程，连续创建套接字以及处理http请求。 文件清单如下： 测试阶段我们使用jdk的javac指令对java代码进行编译，然后启动服务器的默认端口8080（代码中预设），然后在Google Chrome浏览器中对各种情况进行测试和检测输出，具体步骤如下。 首先我们启动终端，进入Java代码所在的文件夹下，然后利用javac命令编译main方法所在的Java文件“WebServer.java”，启动服务器，具体如下： 由于代码中设置的启动端口为8080，如下：所以我们在浏览器中需要输入网址“localhost:8080/index.html”以达到访问该网页的目的，具体如下： 在成功访问该网页之后，我们来观察一下终端的输出情况，发现其请求网页index.html请求成功如下：其请求网页包含的图片first.jpg请求成功如下： 然后点击跳转链接，跳转至next.html，访问下一个网页，同样的，网页跳转成功如下： 在成功打开网页之后，我们来观察一下终端的输出情况。同样的，请求网页“next.html”和“next.jpg”成功，输出如下结果： 当然，除了能成功访问的网页外，我们还需要测试一下错误路径的文件访问结果，于是在浏览器中输入一个错误的网址如“localhost:8080/404.html”，结果如下，提示文件不存在：终端反馈输出对404.html这个不存在的文件的访问结果： 代码附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/***********HttpRequest***************/import java.io.* ;import java.net.* ;import java.util.* ;final class HttpRequest implements Runnable &#123; final static String CRLF = "\r\n"; Socket socket; //构造请求类 public HttpRequest(Socket socket) throws Exception &#123; this.socket = socket; &#125; //启动线程 public void run() &#123; try &#123; processRequest(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; private void processRequest() throws Exception &#123; //获取套接字的输入流，即从服务器端发回的数据流 InputStream is = socket.getInputStream(); //获取套接字的输出流，返回的输出流就是将要发送到服务器端的数据流 DataOutputStream os = new DataOutputStream(socket.getOutputStream()); //缓冲字符输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); // 获取http的request信息 String requestLine = br.readLine(); // 从请求行中提取文件信息 StringTokenizer tokens = new StringTokenizer(requestLine); // 由于token将请求行分解为了单词，我们在这里跳过第一个单词，即“GET” tokens.nextToken(); // GET之后即为文件名 String fileName = tokens.nextToken(); // 为了将文件转化到当前目录下，我们在其之前加一个“.” fileName = "." + fileName ; // 打开文件 FileInputStream fis = null ; boolean fileExists = true ; //判断文件是否查询到 try &#123; fis = new FileInputStream(fileName); &#125; catch (FileNotFoundException e) &#123; fileExists = false ; &#125; //测试输出 System.out.println("\n*************Request**************\n"); System.out.println(requestLine); String headerLine = null; while ((headerLine = br.readLine()).length() != 0) &#123; System.out.println(headerLine); &#125; // 构造response信息 String statusLine = null; String contentTypeLine = null; String entityBody = null; if (fileExists) &#123; //执行成功的话返回“200 OK” statusLine = "HTTP/1.0 200 OK" + CRLF; contentTypeLine = "Content-Type: "+contentType(fileName) + CRLF; &#125; else &#123; //执行失败，文件未找到的时候返回“404 File Not Found” statusLine = "HTTP/1.0 404 File Not Found" + CRLF; contentTypeLine = "Content-Type: text/html" + CRLF; entityBody = "&lt;HTML&gt;" + "&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;" + "&lt;P&gt;File name:&lt;/P&gt;"+fileName+ "&lt;BODY&gt;Not Found&lt;/BODY&gt;&lt;/HTML&gt;"; &#125; // 将上述返回值依次输出 os.writeBytes(statusLine); os.writeBytes(contentTypeLine); os.writeBytes(CRLF); System.out.println("\n*************Response**************\n"); System.out.println(statusLine); //调用文件类型输出方法 if (fileExists) &#123; sendBytes(fis, os); fis.close(); &#125; else &#123; os.writeBytes(entityBody) ; &#125; // 结束关闭 os.close(); br.close(); socket.close(); &#125; private static void sendBytes(FileInputStream fis, OutputStream os) throws Exception &#123; //构造一个1K缓冲区，承接套接字的内容 byte[] buffer = new byte[1024]; int bytes = 0; //将请求的文件复制到套接字的输出流中。 while ((bytes = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, bytes); &#125; &#125; private static String contentType(String fileName) &#123; if(fileName.endsWith(".htm") || fileName.endsWith(".html")) &#123; return "text/html"; &#125; else return "other Content-type" ; &#125;&#125; 12345678910111213141516171819202122232425/***********WebServer***************/import java.io.* ;import java.net.* ;import java.util.* ;public final class WebServer &#123; public static void main(String argv[]) throws Exception &#123; int port=8080; // 建立一个套接字 ServerSocket socket = new ServerSocket(port); while (true) &#123; // 监听一个tcp连接的request. Socket connection = socket.accept(); // 处理HTTP请求消息。 HttpRequest request = new HttpRequest(connection); // 建立一个线程处理请求 Thread thread = new Thread(request); thread.start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次聚会]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%81%9A%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天正月十五，也不能说是闲来无事，毕竟还有那么多前路未卜的事情在等着自己，但是总归还是想写一些清闲的东西。 离开学还有五天，还在家能待三天。 今天去马骁家里聚会了，难得小聚一次，吃够了羊肉也喝够了粗，打够了麻将也赢够了钱。 大家都在为自己的前途开始迷茫了，没有明确的路子可走的人大概就是我们这一批大三的学生吧。 学生生涯还剩一年半，留给自己预备的选择也是众说纷纭。 考研怎么考能考得上哪，保研怎么找老师怎么不亏，出国又该怎么闹。 没有人知道该怎么办，就像有人说zgs的cpp课好一样，每个人都只有自己的路，你没有义务去让所有人都跟着自己的路走。 我也没有能力去辨别谁才是自己的模版。 毕竟这世界上，只有一个独一无二的贾浩男。 大家都好久没踢球了，曾经的前锋马骁也吃撑了一百九的中后卫，曾经的后卫现在也早就离开了操场。 被繁杂的课程，学业和人生压的不知所措。 但是有趣的是，我们每个人仿佛还走在自己自认为正确的道路上，自我感觉良好。 我总是难以定夺自己到底应该，或是值得去做什么。 我喜欢观望，观望才能给我很好的选择正确的机会。 但是观望，观望谁呢，谁有值得观望呢？ 无从所知。 我喜欢在街头看着各种各样的人的走走停停，去看他们的生活。 就像我最喜欢的实用文摘的板块，是社会百态。 在一个社会里，每个人都有着自己独一无二的生活。 品味这些生活，也真是一个有趣的过程。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——评论篇]]></title>
    <url>%2F2019%2F02%2F16%2FHexo%E2%80%94%E2%80%94%E8%AF%84%E8%AE%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天给琳琳看了下内测博客的初版，大体上还比较不错。 为了满足琳琳的需求，方便交流，我决定今天给博客添加评论功能。 网上的博客有很多，还是比较乱七八糟的，所以配好之后自己再总结一下，方便后人乘凉。 来必力在跟帖的插件中我选择了来必力：https://www.livere.com 有这几个原因： 界面UI美观 评论管理方便 支持多个社交账号 不过也有一点不方便，来必力隶属于韩国，在注册使用的时候需要科学上网，在网页加载的时候速度较慢。 下面来讲一下具体布置 注册登陆注册需要科学上网，不然是打不开注册登陆界面的，或者打开很慢？这里不做赘述。 安装选择city版安装就能满足我们的需求，直接安装即可。 安装完之后会以代码形式给出，或者也可以手动进入个人管理界面的 代码管理 查看。 对于NexT主题而言，这里我们主要关注 data-uid 的值。 配置得到用于安装插件的data-uid之后，下一步进入NexT的配置文件 _config.yml 设置data-uid的值。 在_config.yml中找到 livere_uid 的属性字样。 将livere_uid设置为刚刚得到的data-uid的值即可。 部署在上述过程完成之后，部署到博客即可。12$ hexo g$ hexo d 演示完成后的效果如下，支持点赞和折叠评论，支持QQ、微信、微博等多种社交账号： 分析上面的配置过程还是比较容易的，但是如果细看一下我还是有一个疑问的，为什么没有用到来必力提供的安装代码呢，为什么只靠一个data-uid就完成了评论功能？ 在查看了NexT下的相关文件后，我得出了结论。 在 themes/next/layout/_partials 文件夹下，有一个 comments.swig 文件。 在里面可以看到支持多个评论插件的安装脚本，比如Facebook，多说等。 NexT用来加载来必力的安装脚本可以在第45～48行看到，加载脚本为：1234&#123;% elseif theme.livere_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; 这段脚本可以用来必力提供的安装代码替换,作用相同：123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="******"&gt;&lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script');&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 在来必力端可以看到具体的评论情况，包括数据分析和评论管理，功能还是非常强大的。 好了，今天的评论的配置就写这么多。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——bug篇]]></title>
    <url>%2F2019%2F02%2F15%2FHexo%E2%80%94%E2%80%94bug%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天写博客的时候，一套hexo操作行云流水，奈何一个hexo g报错报了几百行，在终端里的错误让人害怕的发抖，先上图为敬。 显然这些带有具体文件路径和出错位置的error很难直接百度到解决方法，在百度了很久之后，我找到一个貌似跟我的bug相关的关键词： YAMLException 这是一个在yaml文件中的报错。 于是怀着一个科班出身的计算机人的心态，我决定自己读报错改bug。 首先找到加载出错的原因： ERROR Theme config load failed. 这大概是主题配置文件加载失败了？？？ 其次是出错的文件： ERROR Process failed: _config.yml 果然是主题配置文件出错了！ 继续找一下出错原因： 12345678910111213141516171819202122232425YAMLException: bad indentation of a mapping entry at line 823, column 3: counter: true ^ at generateError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:165:10) at throwError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:171:9) at readBlockMapping (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1080:7) at composeNode (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1332:12) at readDocument (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1492:3) at loadDocuments (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1548:5) at Object.load (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1569:19) at Hexo.yamlHelper (/Users/jiahaonan/blog/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15) at Hexo.tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Hexo.&lt;anonymous&gt; (/Users/jiahaonan/blog/node_modules/bluebird/js/release/method.js:15:34) at Promise.then.text (/Users/jiahaonan/blog/node_modules/hexo/lib/hexo/render.js:61:21) at tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:694:18) at _drainQueueStep (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:138:12) at _drainQueue (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) 妈耶，一开始看到这些bug我已经准备放弃了，因为这些bug并没有影响我提交博客的相关操作。 但是每次 hexo g 后总跟着几百行报错我看起来很难受啊。 还是继续冷静的分析一下吧。 找到YAMLException的提示位置，第823行。 所以，原来是我多打了一个空格！ 好了，冷静地把空格删掉。 重来一遍hexo g，完美运行～ 这个案例告诉我们，修改文件的时候不要把空格不当回事儿，不然都是bug劝退。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——公式篇]]></title>
    <url>%2F2019%2F02%2F14%2FMarkdown%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[写完语法和配置之后，当然还得补充一项最常用的 公式 的写法了。 在写word的时候一直是无脑公式编辑器，看见琳琳用的 latex 的时候总是一脸崇拜，时至今日也得学习一下latex的公式表达，它也是markdown所支持的公式写法。 由于公式的书写要求和规范太多了，我这里就不做生产者了，老老实实做个搬运工。 贴两篇比较好的博客，方便学习～ https://www.jianshu.com/p/a0aa94ef8ab2https://www.cnblogs.com/q735613050/p/7253073.html]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——配置篇]]></title>
    <url>%2F2019%2F02%2F13%2FMarkdown%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[上一篇讲了Markdown的语法，接下来说一下Markdown的插件。 Markdown的编辑器有很多，知乎一下就可以看到不少开源友好的编辑器，为了更好的整合我电脑上现有的软件（为了省内存），我决定在sublime text上写Markdown。 我电脑的配置如下： Mac OS X 10.13.1Sublime Text Version 3.1.1 虽然sublime text3自身携带许多语言的高亮，但是还没有达到我想要的Markdown的编写环境，自带的Markdown不好看也不好用，所以需要拿一些插件来满足一下需求。 需要安装的插件： Package Control:插件安装管理MarkdownEditing:显示Markdown的语法和高亮 可选的插件： OmniMarkupPreviewer:浏览器/html快捷预览和导出MarkdownLivePreview:sublime text界面实时预览 Package ControlPackage Control是Sublime Text不可或缺的一个插件，许多插件的安装和管理都要用到它。两个月之前我在配置NASM的语法和高亮插件时安装配置了Package Control，才第一次接触到Sublime Text的除了写字板之外的功能，所以这里要强烈安利Package Control这一插件，让我有了对不止于Sublime Text写字板的用户体验。 安装插件 打开Sublime Text的控制台 快捷键：control + ` 手动：View -&gt; Show Console 在控制台输入下面的第一行python代码回车即可。不过里面的 http://packagecontrol.io/ 应该是被墙了，这个年头程序员没个VPN还怪麻烦的。我在一些博客里找到了镜像网站，如果第一段代码无法安装，可以尝试一下第二种方法（未测） 1import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 1import urllib.request,os,hashlib; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://dn-52cik.qbox.me/' + pf.replace(' ', '%20')).read(); open(os.path.join( ipp, pf), 'wb' ).write(by) 使用安装成功之后，可以在 Sublime Text -&gt; Preference 里看到 Package Control 这一选项，也可以通过组合键 command + shift + p 在搜索框里搜索 Package Control 。 在package control里，最主要使用的是 install package 功能，在install package界面，可以根据个人需求安装所需要的插件。 需要注意的是，最近不使用vpn是无法使用install package功能的，会出现如下提示： 在科学上网之后，可以来到install package的界面。注意已经安装过的插件在搜索里不会在出现，所以这里我的搜索里看不到MarkdownEditing的。 MarkdownEditing这一插件是在sublime text上写markdown的必须的插件，其包含了markdown的语法补全和高亮，效果如下： 除此之外，MarkdownEditing还提供了两个快捷代码段分别用于插入图片和链接： mdl + tab键：插入链接 [](link) mdi + tab键：插入图片 ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 下面来谈两款可选的插件 OmniMarkupPreviewer如果说MarkdownEditing满足了编辑markdown的需求，那么接下来就该谈一下预览需求了。OmniMarkupPreviewer 提供了html端的预览，其具有如下的快捷功能： command + option + o ：浏览器预览 command + option + x ：导出html control + option + c ：复制html代码 其浏览器端预览效果如下,我个人比较喜欢这种预览方式： MarkdownLivePreview当然，如果不喜欢在浏览器和编辑界面频繁切换，sublime text中也有一款在软件端满足实时预览功能的插件： MarkdownLivePreview同样是通过install package来下载安装，效果如下：不过比较可惜的是，由于是在sublime text端进行实时更新，在编辑文字时会有明显的卡顿，所以不是很推荐这一款插件的预览功能。 到此，在sublime text端编写和预览markdown的插件和环境就基本搞定了！ 部分参考自：https://www.jianshu.com/p/335b7d1be39e]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——语法篇]]></title>
    <url>%2F2019%2F02%2F11%2FMarkdown%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近一时兴起，想搭一个自己的blog玩一玩。 在子泰学长的引领下，我也选择了hexo这一开发框架，至于hexo在Mac上的配置的这些过程在此先省略不谈，我们来谈谈hexo上支持的文件 markdown 格式的语法总结。 一、标题Markdown的标题语法需要与 # 配合使用，在标题文字之前添加一到六个#即可生成一级标题到六级标题。 使用：123456#一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 演示：一级标题二级标题三级标题四级标题五级标题六级标题二、字体Markdown的可以对字体设置：粗体，斜体，斜体加粗和删除线四种。 使用：1234**粗体** (使用中 * 与 _ 的效果相同) *斜体* ***斜体加粗*** ~~删除线~~（注意这里的波浪线为半角符号） 演示：粗体斜体斜体加粗删除线 三、引用Markdown在使用引用时需要与 &gt; 配合操作，在需要应用的文字之前添加 &gt; 即可。 使用：123&gt;一级引用 &gt;&gt;二级引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;多级引用 演示： 一级引用 二级引用 多级引用 四、分割线Markdown中分割线可以用连续三个或三个以上的 - 或 * 来实现，一级标题和二级标题会自带下划线。我在sublime text3中用livepreviewer实时预览时发现，使用超过三个时预览端会出现乱码，但是在用html预览时一切正常。 使用：123---*** ------- 演示： 五、图片图片是一个比较麻烦的东西，但是sublime text3中的MarkdownEditing提供了生成图片格式的快捷键，通过使用快捷键或代码段可以直接生成。 使用：12快捷键：command+shift+k 代码段：mdi+tab键 演示：![]()![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 语法：1234567891011![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容,title可加可不加。如果要修改图片位置，可以用如下写法：&lt;div align=center/left/right&gt;![Alt text](/path/to/img.jpg &quot;Optional title&quot;)同样的，还可以用img标签来调整图片的大小，写法如下：&lt;img src=&quot;http:...&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt;这些写法与html的写法一致。 六、超链接MarkdownEditing也提供了生成超链接的快捷代码段，同样简化了实际操作。 使用：mdl+tab键 演示：[](link) 语法：12[超链接名](超链接地址 &quot;超链接title&quot;) 其中的title同样可加可不加 示例：12[百度](https://baidu.com) [微博](https://weibo.com) 演示：百度微博 七、列表Markdown中的列表分为无序列表和有序列表两种，MarkdownEditing中提供回车自动补全，列表之间可以相互嵌套。 无序列表语法：1234+、-或* + 空格 + 内容 + 无序列表 - 无序列表 * 无序列表 演示： 无序列表 无序列表 无序列表 有序列表语法：1234数字 + . + 空格 + 内容 1. 有序列表 2. 有序列表 3. 有序列表 演示： 有序列表 有序列表 有序列表 列表嵌套语法：123&apos;+&apos; + 一级标题tab + &apos;+&apos; + 二级标题tab + tab + &apos;+&apos; + 三级标题 演示： 一级列表 二级列表 三级列表 二级列表 八、表格表格的语法稍微复杂一点，不过可以把他理解为一个格式匹配的过程，也有一点在画图的意思。 语法：12345表头1 | 表头2 | 表头3 - | :-: | -: 靠左 | 居中 | 靠右 第二行用来格式匹配，默认为左对齐，:-:可以实现居中效果，-:实现右对齐 演示： 表头1 表头2 表头3 靠左 居中 靠右 九、代码Markdown中的代码可以放置在一对反引号 `` 中，注意反引号是键盘上数字 1 左边的键，并不是引号。 语法：`单行代码` ``` 多行代码 多行代码 ``` 参考自：https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
