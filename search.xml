<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[编译原理——编译器前端]]></title>
    <url>%2F2019%2F06%2F05%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[写在前面终于写完了最后一个必做实验，编译原理课程也几乎要告一段落了，在最后一次实验完成之际，我想简单陈述一下我个人对于这门课程的感悟和想法。 之前我常常疑惑，计科和别的专业的区别是什么，为什么小专业学我们学过的课，也学我们不学的课呢，这么看来计科怎么都好像是他们的一个“子集”。 到大三下，我发现了一个“不合群”的课程——编译原理。这是一个只有计科的才有植入的专业核心课，也是计科专业区别于其他专业的唯一标准。 于是责任心鞭策着我要认真对待这门课。争取课代表、每节课坐前排、手写作业认真完成、课程实验撰写博客、选做题积极响应等是我对这门课的态度。 课程涵盖了文法定义、词法分析、符号表处理、各式各样的语法分析、到最后的目标代码生成，从内而外的介绍了编程语言被编译识别的过程，也让我体会到了计算机程序语言被机器所识别的内涵和精髓，这种上下文无关语言的识别过程为我探索自然语言处理等上下文有关语言的研究铺垫了道路，不论是知识开荒还是兴趣培养，这门课对我来说受益匪浅。 最后引用一句实验指导书的片头语： 编译原理课程中蕴含着计算机科学中解决问题的思路、抽象问题和解决问题的方法，其内容可让计算机专业学生“享用一辈子”。 这门课的知识应该是一个计科专业的人贯穿自始至终的课程。 目标任务实验项目将词法分析程序设计原理与实现（专题1）和基于SLR(1)分析法的语法制导翻译及中间代码生成程序设计原理与实现（专题5）形成一个程序，即程序的输入为符号串源程序，输出为中间代码四元式序列。 设计要求（1）词法分析的输入为符号串，词法分析的输出为二元式形式的中间文件；（2）语法制导翻译读取二元式形式的中间文件并生成中间代码四元式形式的中间文件；（3）设计两个测试用例（尽可能完备），并给出程序执行结果。 实验1&amp;5封装由于我的实验一采用了C++所编写，所以首要解决的一个问题就是： 如何利用python调用C++程序？ 词法分析器输出重定向因为需要将词法分析器与SLR语法分析器链接成一个整体，所以需要首先修改词法分析器的输出中间文件，即通过一定方法令词法分析器实现输出重定向功能。 由于词法分析器的输出全部由函数out(int c,string tok)所控制，函数实现如下：1234567891011121314151617void out(int c,string tok)&#123; // 保留字只输出编码 if(tok == "reserved") cout&lt;&lt;c&lt;&lt;" "&lt;&lt;reserved.at(c)&lt;&lt;endl; //ID和int输出 else if(c==10||c==11)&#123; cout&lt;&lt;"i"&lt;&lt;" "&lt;&lt;tok&lt;&lt;endl; &#125; //注释(不)输出 else if(c==25)&#123; return; //cout&lt;&lt;"COMMENT "&lt;&lt;tok&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;tok&lt;&lt;endl; &#125;&#125; 所以只需要针对其修改输出定向即可，实现语句如下：1FILE *fp1 = freopen("/Users/jiahaonan/Desktop/大三下/编译原理/前端展示/out.txt", "w+", stdout); 再此执行词法分析器，可以观察到词法分析器的输出结果均被定向至out.txt文件中 封装词法分析器由于不是同一语言，解决输出重定向问题后，在保证词法分析器功能无误的前提下，需要对词法分析器进行功能封装，即转变为可执行程序。 可以通过通过终端下的g++编译器实现，指令如下：1g++ -o word_analyse main.cpp 将编译生成的可执行文件word_analyse放入与SLR语法分析类相同目录的文件夹下。 到此，词法分析器的修改封装已成功完成。 若需要在python中调用此可执行文件，需要使用如下代码：123import osos.system("word_analyse") 语法分析器由于实验5在设计时采用了面向对象的思想，故在实验6中通过如下代码可以直接引入SLR类来使用，无需修改！ 123import SLRSLR.test() 这里的test即为实验5中的主测试函数，代码如下：1234567891011121314151617181920212223242526def test(): # 终结符号集/非终结符号集 Vn = ['A', 'V', 'E', 'T', 'F'] Vt = ['+', '-', '*', '/', '(', ')', 'i', '='] # 规则集合 rule = &#123; 'A': ["V=E"], 'E': ["E+T", "E-T", "T"], 'T': ["T*F", "T/F", "F"], 'F': ["(E)", "i"], 'V': ["i"] &#125; slr = SLR(start='A', Vt=Vt, Vn=Vn, rule=rule) test_words = "" test_symbol = "" f = open("out.txt", 'r') while (True): t = f.readline().strip('\n') if (t == ''): break test_symbol += t[0] test_words += t[-1] slr.compile(symbol=test_symbol, word=test_words, log=True) 数据流在封装好词法分析器后、引入语法分析器后，下一步需要做的就是如何设计文件I/O流，以衔接词法分析器和SLR语法分析器。 我的设计思想如下： 总体来说，共需要使用到3个操作文件： in.txt：词法分析器的接受输入文件 out.txt：词法分析器的二元组输出文件，同时供语法分析器输入 out1.txt：语法分析器的语法制导翻译过程输出文件 文件的预览如下： 需要说明的是，out1文件为了观测的直观性输出了一些辅助性信息，可以通过控制输出来取消，无大影响。 图形化前端设计虽然本次实验的前端含义不代表web/图形化前端，但既然已经将工程转移到python下了，就一不做二不休。 根据题目的需求，前端应该具有如下功能： 接受待分析的代码输入 对代码进行词法分析，并输出二元式中间文件 对二元组中间文件进行语法分析，并输出四元式中间文件 这里通过tkinter库来依次完成以上需求。 接受输入通过一个Entry类型的控件实现输入功能，代码如下：12345tip = Label(root,text="你可以在此输入代码",font=("手扎体-简",18))tip.place(x=100,y=110)code = Entry(root,width=18)code.place(x=100,y=135) 如果要调用code控件的输入内容，只需使用如下函数即可：1code.get() 词法分析对输入的代码进行词法分析应该属于功能选择类，所以我们需要通过两个Button类型的控件实现选择并打印，通过一个Text类型的控件实现词法分析结果的输出 代码如下：12345678910111213141516171819202122232425262728293031# 选择词法分析def compile_confirm(event): if(len(code.get())==0): a = messagebox.showinfo("","您没有输入任何语句") return f = open("in.txt", 'w') var = code.get() f.write(code.get()) f.write('\n')word_show = Text(root,height=6,width=30)word_show.place(x=75,y=235)# 选择打印结果def print_confirm1(event): word_ans = "" os.system("word_analyse") with open("out.txt",'r') as f: word_ans += f.read() word_show.delete('1.0', 'end') word_show.insert(INSERT,word_ans)btn_compile = Button(root, text=" 词法分析 ")btn_compile.place(x=140,y=180)btn_compile.bind("&lt;Button-1&gt;",compile_confirm)btn_print1 = Button(root, text=" 打印结果 ")btn_print1.place(x=140,y=205)btn_print1.bind("&lt;Button-1&gt;",print_confirm1) 执行效果如下： 语法分析词法分析成功之后，接下来实现语法分析功能。 语法分析的实现机理与词法分析类似，需要通过一个Button类型的控件实现语法分析功能选择，通过一个Text类型的控件实现语法分析结果的输出 代码如下；1234567891011121314langu_show = Text(root,height=10,width=30)langu_show.place(x=75,y=365)def print_confirm2(event): langu_ans = "" SLR.test() with open("out1.txt",'r') as f: langu_ans += f.read() langu_show.delete('1.0', 'end') langu_show.insert(INSERT,langu_ans)btn_compile1 = Button(root, text=" 语法分析 ")btn_compile1.place(x=140,y=335)btn_compile1.bind("&lt;Button-1&gt;",print_confirm2) 执行效果如下： 到此，前端的设计圆满成功！ 附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import osfrom tkinter import *from tkinter import messageboximport SLRroot = Tk()root.title("前端展示")root.geometry('400x600')title = Label(root,text="编译前端",font=("手扎体-简",30))title.place(x=120,y=30)tip = Label(root,text="你可以在此输入代码",font=("手扎体-简",18))tip.place(x=100,y=110)code = Entry(root,width=18)code.place(x=100,y=135)def compile_confirm(event): if(len(code.get())==0): a = messagebox.showinfo("","您没有输入任何语句") return f = open("in.txt", 'w') var = code.get() f.write(code.get()) f.write('\n')word_show = Text(root,height=6,width=30)word_show.place(x=75,y=235)def print_confirm1(event): word_ans = "" os.system("word_analyse") with open("out.txt",'r') as f: word_ans += f.read() word_show.delete('1.0', 'end') word_show.insert(INSERT,word_ans)langu_show = Text(root,height=10,width=30)langu_show.place(x=75,y=365)def print_confirm2(event): langu_ans = "" SLR.test() with open("out1.txt",'r') as f: langu_ans += f.read() langu_show.delete('1.0', 'end') langu_show.insert(INSERT,langu_ans)btn_compile = Button(root, text=" 词法分析 ")btn_compile.place(x=140,y=180)btn_compile.bind("&lt;Button-1&gt;",compile_confirm)btn_print1 = Button(root, text=" 打印结果 ")btn_print1.place(x=140,y=205)btn_print1.bind("&lt;Button-1&gt;",print_confirm1)btn_compile1 = Button(root, text=" 语法分析 ")btn_compile1.place(x=140,y=335)btn_compile1.bind("&lt;Button-1&gt;",print_confirm2)root.mainloop()]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——基于SLR1的语法制导翻译及中间代码生成]]></title>
    <url>%2F2019%2F06%2F03%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ESLR1%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[目标任务实验项目完成以下描述赋值语句SLR(1)文法语法制导生成中间代码四元式的过程。12345G[A]: A→V=E E→E+T∣E-T∣T T→T*F∣T/F∣F F→(E)∣i V→i 设计说明终结符号i为用户定义的简单变量，即标识符的定义。 设计要求（1）构造文法的SLR(1)分析表，设计语法制导翻译过程，给出每一产生式对应的语义动作；（2）设计中间代码四元式的结构；（3）输入串应是词法分析的输出二元式序列，即某赋值语句“专题1”的输出结果，输出为赋值语句的四元式序列中间文件；（4）设计两个测试用例（尽可能完备），并给出程序执行结果四元式序列。 实验过程数据结构在明确好编程思想后，首先需要确定下来的就是如何组织类及类成员，如何存储数据。下面给出算符优先语法分析类class SLR的成员变量/函数及其设计说明： 类成员变量 成员变量 类型 备注 start str 文法开始符号 Vt set() 终结符号集合 Vn set() 非终结符号集合 V set() 文法全部符号集合，用于构造SLR分析表 rule dict{str: list[str]} 文法产生式规则 point str 即符号‘.’，用于构造项目集 first set() 文法的first集，用于构造follow集 follow set() 文法的follow集，用于解决冲突项目 C dict{int: dict{str:list[str]}} 记录有效项目集规范族 r dict{int: dict{str:str}}} 记录产生式序号，辅助生成action表中的r项 action dict{(int,str):str} 记录SLR分析表中的action动作，包括‘S’和‘r’ goto dict{(int,str):int} 记录SLR分析表中的goto动作，即记录待跳转的下一个项目集序号 类成员函数 成员函数 备注 init(self, start, Vn, Vt, rule) 类的构造函数，通过输入文法的开始符号、非终结符/终结符号集、产生式规则从而构造并返回SLR类 get_first(self) 构造first集合 get_follow(self) 构造follow集合 op_start(self) 构造有效项目集的第一步动作，即加入：‘.’+开始符号产生式 op_closure(self,c_j) 求c_j项目集的闭包 op_go(self,i,x) 实现Go(Ci ,x)函数功能 judge(self,i) 判断C[i]是否为终态，辅助构造有效项目集C get_C(self) 生成有效项目集规范族C get_r(self) 生成带序号的产生式，用于生成action表中的r部分 get_action(self) 构造分析表的action部分 get_goto(self) 构造分析表的goto部分 compile(self, symbol, word, log) 对输入语句进行语法分析，其中 symbol: 符号语句；word: 真实语句；log: 是否打印四元式 本次实验的重点在于下面几个成员函数的实现： 求c_j项目集的闭包get_C(self): 自动生成有效项目集规范族Cget_action(self): 构造分析表的action部分get_goto(self): 构造分析表的goto部分compile(self, symbol, word, log): 对输入语句进行语法分析 求C[j]项目集的闭包求C[j]项目集闭包，即实现closure(Cj)的功能，其算法如下： $$① C_i 的任何项目均属于closure(C_i)$$ $$② （重复）若A → α·X β(X∈V_n) ∈ closure(C_i) ,则X → ·λ ∈ closure(C_i)$$ $$③ C_i = closure(C_i)$$ 代码实现如下，上面三步在代码中有详细注释：12345678910111213141516171819202122232425def op_closure(self,c_j): #① C_i 的任何项目均属于closure(C_i) closure_i = c_j #② （重复）若A → α·X β(X∈V_n) ∈ closure(C_i) ,则X → ·λ ∈ closure(C_i) while(True): closure_i1=closure_i.copy() key_list = list(closure_i.keys()) for A in key_list: for aXb in closure_i[A]: for j in range(len(aXb)-1): if(aXb[j]==self.point and aXb[j+1] in self.Vn): # 如何没有则新建一个key if(aXb[j+1] not in closure_i.keys()): closure_i.update(&#123;aXb[j + 1]:[]&#125;) key_list.append(aXb[j + 1]) for l in rule[aXb[j+1]]: temp = self.point+l if(temp not in closure_i[aXb[j+1]]): closure_i[aXb[j+1]].append(temp) # 重复,直至 closure(Ci)不再增大. if(closure_i != closure_i1): closure_i1 = closure_i.copy() else: # ③ C_i = closure(C_i) return closure_i 自动生成有效项目集规范族C在SLR(1)分析过程中，前期准备中最重要的就是构建SLR(1)的有效项目集规范族C 根据生成算法，我们来对代码进行逐步实现 1.拓广文法,保证唯一初态. 1234# 拓广文法self.rule['S'] = start + "#"self.Vn.append('S')self.start = 'S' 2.生成C0={S→ ·δ} ∪{S→ ·δ的闭包操作} 1234# 生成C0=&#123;S→ ·δ&#125;self.op_start()# ∪ &#123;S→ ·δ的闭包操作&#125;self.C[0]=self.op_closure(self.C[0]) 3.重复以下过程,直至C不再增大为止. Ci读操作,生成Cj1,Cj2,…….CjnCj1,Cj2,…….Cjn闭包操作(若其中某项目集已经存在就略去) 123456789101112131415161718192021222324i = 0j = 1while(True): # 判断C[i]是否为终态 if (i == j): break if(self.judge(i)==True): self.tC.append(i) i=i+1 continue for v in self.V: c_j = self.op_go(i,v) if(len(c_j)!=0): closure_j = self.op_closure(c_j) flag = True if self.check_in_C(closure_j): flag=False if flag: self.C[j]=closure_j j = j + 1 if (i&lt;j): i=i+1 else: break 到此，该文法下的有效项目集规范族已被完全构建，看一下预览：可以看到，拓广文法后产生的21个项目完全正确 构造分析表的action部分SLR(1)文法的分析表包括action和Goto两个部分，这里先谈第一部分，即action部分的实现 action动作的添加主要分为三种情况： 1.若GO(Ci, a)=Cj a∈Vt, 置ACTION(i,a)=Sj Sj:移进,把下一状态j和现输入符号a移入栈 2.若S→δ· ∈ Ck , (S为拓广文法开始符号) 置ACTION(k,#)=acc acc:接受 3.若A→α·∈Ci , 且 a∈FOLLOW(A) , a∈Vt 置ACTION(i,a)=rj (A → α为第 j个产生式) rj:归约,按第j产生式归约 所以我们的目的是，遍历文法Vt中的所有终结符号在构造好的项目集C中找到对应情况下的（项目，符号）组合，为该组合添加对应动作 代码实现如下：12345678910111213141516171819202122232425262728293031# 构造分析表的action部分 def get_action(self): # 若GO(Ci, a)=Cj a∈Vt, 置ACTION(i,a)=Sj for i in self.C.keys(): for a in self.Vt: j = self.GO(i,a) if(j!=-1): self.action[(i,a)]='S'+str(j) # 若A→α·∈Ci , 且 a∈FOLLOW(A) # a∈Vt 置ACTION(i,a)=rj (A → α为第 j个产生式) for i in self.C: for A in self.C[i].keys(): for item in self.C[i][A]: # 项目最后一个为点 '·' if(item[-1] == self.point): for a in self.follow[A]: # 找到对应的规约产生式 for j in self.r.keys(): temp = &#123;A:item[:-1]&#125; if(self.r[j] == temp): self.action[(i,a)]='r'+str(j) # 若S→δ·∈ Ck ,(S为拓广文法开始符号） # 置ACTION(k,#)=acc omiga = rule[self.start]+self.point for k in self.C: for key in self.C[k].keys(): if(key==self.start and omiga in self.C[k][key]): self.action[(k,'#')]="acc" 构造分析表的Goto部分Goto部分是在遍历文法Vn中的所有非终结符号时产生的动作，即状态S面临文法符号x时下一状态 Goto动作的添加仅对应一种情况： 若GO(Ci,A)=Cj , A∈Vn ,置GOTO(i,A)=j 代码实现如下：12345678# 构造分析表的goto部分def get_goto(self): # 若GO(Ci, A)=Cj A∈Vn, 置GOTO(i,A)=j for i in self.C.keys(): for A in self.Vn: j = self.GO(i, A) if (j != -1): self.goto[(i, A)] = j 到此，我们已经构造好了SLR(1)分析表的所有部分，对于该题文法下的分析表，预览如下： 可对比上面生成的项目集，结果完全正确！ 语法分析在SLR类构建完毕之后，下面我们便可以通过接收输入来进行语法分析过程。 控制输入根据题干要求，输入参数应为词法分析器所输出的二元组，所以这里对分析函数的参数列表构建如下，其中，word代表真实符号，symbol代表根据真实符号所转化的定义符号：1def compile(self, symbol, word, log) 举个例子，对于输入语句：X = A*(B+C)+D而言：12symbol : i=i*(i+i)+iword : X=A*(B+C)+D 可以看出，symbol的作用在于进行语法分析，而word的作用在于生成四元式。 当然，这实现起来很简单，只需要在读如文件时控制读如组合即可，代码如下：12345678test_words = ""test_symbol = ""f = open("in2.0.txt",'r')while(True): t = f.readline().strip('\n') if(t == ''): break test_symbol += t[0] test_words += t[-1] 对于如下格式的二元组输入： 可以看到这样的拼接结果： SLR(1)分析SLR(1)的分析过程与LR(0)相同，需要两个栈来辅助分析，分别是：状态栈、符号栈分析过程如图： 代码实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# SLR（1）法分析# symbol: 符号语句 word: 真实语句def compile(self, symbol, word, log): # 补充# symbol+="##" # 状态栈 state = ['0'] # 符号栈 charater = ['#'] #输入串下标 k=0 while(True): state_now = eval(state[len(state)-1]) input_ch = symbol[k] if ((state_now,input_ch) in self.action.keys()): action = self.action[(state_now, input_ch)] else: action='-1' if(action[0]=='S'): #if(input_ch != '#'): k = k+1 charater.append(input_ch) state.append(action[1:]) continue elif(action[0]=='r'): # 规约动作r r = &#123;&#125; r = self.r[eval(action[1])] # 规约长度 lenth = 0 # 规约终结符 substitude = '' r_rule='' for left in r.keys(): substitude = left for right in r[left]: r_rule+=right for i in range(len(r_rule)): charater.pop() state.pop() # 新规约终结符进符号栈 charater.append(substitude) new_state = self.goto[(eval(state[len(state)-1]),substitude)] state.append(str(new_state)) elif(action=='acc'): return True else: return False 其中，substitute和r_rule记录了每次规约时所选用的产生式substitute -&gt; r_rule所以根据此，我们可以去匹配生成对应的四元式组。 由课上所学可知，运算赋值语句文法每次规约时产生的对应动作如下： 用代码实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 根据规约规则r_rule决定执行动作, log为分析开关 # 预定义.PLACE变量 if log == True: E_place = [] F_place = [] V_place = [] T_place = [] t = 0 #temp计数器 # 添加至上段中的while(True)中 if log==True: # ② A →V=E if (substitude == 'A' and r_rule == "V=E"): print("( =, "+E_place.pop()+", ,"+V_place.pop()+" )") # ③ E(1)→E(2)+T elif (substitude == 'E' and r_rule == "E+T"): E1_place = "temp"+str(t) t=t+1 print("( +, "+E_place.pop()+", "+T_place.pop()+", "+E1_place+" )") E_place.append(E1_place) # ④ E → T elif (substitude == 'E' and r_rule == "T"): E_place.append(T_place.pop()) # ⑤ T(1)→ T(2)*F elif (substitude == 'T' and r_rule == "T*F"): T1_place = "temp"+str(t) t=t+1 print("( *, "+T_place.pop()+", "+F_place.pop()+", "+T1_place+" )") T_place.append(T1_place) # ⑥ T → F elif (substitude == 'T' and r_rule == "F"): T_place.append(F_place.pop()) # ⑦ F →(E) elif (substitude == 'F' and r_rule == "(E)"): F_place.append(E_place.pop()) # ⑧ F → i elif (substitude == 'F' and r_rule == "i"): F_place.append(word[k-1]) # ⑨ V →i elif (substitude == 'V' and r_rule == "i"): V_place.append(word[k-1]) 这里需要注意的一点是如何区分诸如E(1)→E(2)+T规则中的（1）和（2）我的解决方法为：用栈结构来存储各个place变量。根据运算赋值文法的特点，后产生的E一定会被先规约用掉，所以用栈来模拟可以保证先产生的E不被后续的E所覆盖。 到此，本次实验的SLR类已经被完全构建完毕。 SLR类分析测试我们以语句：X=A*(B+C)+D为例对其进行词法分析，首先得到二元组结果文件如下： 经过文件组织拼接后，调用函数1slr.compile(symbol=test_symbol,word=test_words,log=True) 得到输出结果如下： 为了详细分析，通过适当调整输出来观测状态栈、符号栈的变化，结果如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 /Users/jiahaonan/Desktop/大三下/编译原理/算符优先/SLR.py[状态栈]:[&apos;0&apos;][符号栈]:[&apos;#&apos;][状态栈]:[&apos;0&apos;, &apos;3&apos;][符号栈]:[&apos;#&apos;, &apos;i&apos;][1]: V -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;10&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;i&apos;][2]: F -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;8&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;F&apos;][3]: T -&gt; F[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;10&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;i&apos;][4]: F -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;8&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;F&apos;][5]: T -&gt; F[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;7&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;T&apos;][6]: E -&gt; T[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;11&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;+&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;11&apos;, &apos;10&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;+&apos;, &apos;i&apos;][7]: F -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;11&apos;, &apos;8&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;+&apos;, &apos;F&apos;][8]: T -&gt; F[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;11&apos;, &apos;16&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;+&apos;, &apos;T&apos;][9]: E -&gt; E+T( +, B, C, temp0 )[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;9&apos;, &apos;15&apos;, &apos;20&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;(&apos;, &apos;E&apos;, &apos;)&apos;][10]: F -&gt; (E)[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;, &apos;13&apos;, &apos;18&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;, &apos;*&apos;, &apos;F&apos;][11]: T -&gt; T*F( *, A, temp0, temp1 )[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;7&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;T&apos;][12]: E -&gt; T[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;, &apos;11&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;, &apos;+&apos;][状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;, &apos;11&apos;, &apos;10&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;, &apos;+&apos;, &apos;i&apos;][13]: F -&gt; i[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;, &apos;11&apos;, &apos;8&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;, &apos;+&apos;, &apos;F&apos;][14]: T -&gt; F[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;, &apos;11&apos;, &apos;16&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;, &apos;+&apos;, &apos;T&apos;][15]: E -&gt; E+T( +, temp1, D, temp2 )[状态栈]:[&apos;0&apos;, &apos;2&apos;, &apos;5&apos;, &apos;6&apos;][符号栈]:[&apos;#&apos;, &apos;V&apos;, &apos;=&apos;, &apos;E&apos;][16]: A -&gt; V=E( =, temp2, ,X )[状态栈]:[&apos;0&apos;, &apos;1&apos;][符号栈]:[&apos;#&apos;, &apos;A&apos;][状态栈]:[&apos;0&apos;, &apos;1&apos;, &apos;4&apos;][符号栈]:[&apos;#&apos;, &apos;A&apos;, &apos;#&apos;]TrueProcess finished with exit code 0 分析过程及四元式产生结果完全正确！ 优势 本次代码编写采用了面向对象的编程思想，保证了SLR类的泛用性 只需要改变输入的符号集合及文法规则，即可对不同的满足SLR1文法的语句进行语法分析 程序能给出每一步的精确分析过程，并产生对应四元组 附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469class SLR: def __init__(self, start, Vn, Vt, rule): # 初始化类元素 self.start = start self.Vt = Vt self.Vt.append('#') self.Vn = Vn self.rule = rule self.point = '.' self.V = Vn + Vt # 拓广文法 self.rule['S'] = start + "#" self.Vn.append('S') self.start = 'S' # 获得first集 self.first = &#123;vn:set() for vn in self.Vn&#125; self.get_first() # 获得follow集 self.follow = &#123;vn: set() for vn in self.Vn&#125; self.get_follow() # 生成有效项目集 #self.C = &#123;k : dict() for k in range(12)&#125; self.C = &#123;&#125; self.tC = [] # 终态项目集 self.get_C() # 生成action表 self.r = &#123;&#125; # 记录规约序号，辅助生成action表中的r项 self.get_r() self.action = dict() self.get_action() # 生成Goto表 self.goto = dict() self.get_goto() def get_first(self): rule1 = self.rule.copy() item = rule1[self.start] rule1[self.start] = [item] ''' 若X∈Vn 有X→aα , (a ∈Vt )或/和X→ε 则 a或 /和ε ∈ FIRST(x) ''' for left in rule1.keys(): for right in rule1[left]: if(right[0] in self.Vt): self.first[left].add(right[0]) ''' 对X→Y1Y2.......Yk(且Y1 ∈Vn), 反复使用以下 直到每一个FIRST(X)不再增大为止. i 若Y1 ∈Vn 则把FIRST(Y1 )\&#123;ε&#125;元素加入FIRST(X)中 ii 若Y1、Y2、......Y i-1 ∈Vn (2≤i ≤k) 且ε ∈FIRST(Y j) (1≤j ≤i-1) 则把FIRST(Yi )\&#123;ε&#125;元素加入FIRST(x)中 iii 若Y1、Y2、......Yk ∈Vn 且ε ∈FIRST(Y j) (1≤j ≤k) 则把ε元素加入FIRST(x)中 ''' size1 = 0 size2 = 0 for key in self.first: for item in self.first[key]: size1 += len(item) while(True): for left in rule1.keys(): for right in rule1[left]: Y1 = right[0] if(Y1 in self.Vn): set1 = self.first[Y1] for item in set1: self.first[left].add(item) for key in self.first: for item in self.first[key]: size2 += len(item) if(size1 != size2): size1=size2 size2=0 continue else: break def get_follow(self): rule1 = self.rule.copy() item = rule1[self.start] rule1[self.start] = [item] # 1. 令# ∈FOLLOW(S) S为文法开始符号 self.follow[self.start].add('#') # 2. 对A→ αBβ, 且β ≠ ε 则将 FIRST(β)\&#123;ε&#125;加入FOLLOW(B)中 for left in rule1.keys(): for right in rule1[left]: for k in range(len(right)-1): # B:right[k] if(right[k] in self.Vn): # B下一个字符是终结符，则直接加入B的follow集 if(right[k+1] in self.Vt): self.follow[right[k]].add(right[k+1]) # B下一个字符不是终结符，则将FIRST(β)加入B的follow集 elif(right[k+1] in self.Vn): set1 = self.first[right[k+1]] for item in set1: self.follow[right[k]].add(item) # 3.反复, 直至每一个FOLLOW(A)不再增大 # 对A→ αB或A→ αBβ(且ε ∈ FIRST(β)) # 则FOLLOW(A)中的全部元素加入FOLLOW(B) size1=0 size2=0 for key in self.follow: for item in self.follow[key]: size1 += len(item) while(True): for left in rule1.keys(): for right in rule1[left]: # B:right[-1] 对A→ αB if(right[-1] in self.Vn): set1 = self.follow[left] for item in set1: self.follow[right[-1]].add(item) for key in self.follow: for item in self.follow[key]: size2 += len(item) if (size1 != size2): size1=size2 size2=0 continue else: break ''' 开始操作:S为开始符号, S→δ 则 S→·δ ∈ C0 ''' def op_start(self): self.C[0]= &#123;'S':[self.point+self.rule['S']]&#125; ''' 闭包操作:closure(Ci) Ci的闭包 ① Ci 的任何项目均属于closure(Ci) ② 若A → α·X β且X∈Vn属于closure(Ci) 则X → ·λ 属于closure(Ci) 重复,直至 closure(Ci)不再增大. ③ Ci = closure(Ci) ''' def op_closure(self,c_j): #closure_i = self.C[i] #dict类型 closure_i = c_j while(True): closure_i1=closure_i.copy() key_list = list(closure_i.keys()) for A in key_list: for aXb in closure_i[A]: for j in range(len(aXb)-1): if(aXb[j]==self.point and aXb[j+1] in self.Vn): # 如何没有则新建一个key if(aXb[j+1] not in closure_i.keys()): closure_i.update(&#123;aXb[j + 1]:[]&#125;) key_list.append(aXb[j + 1]) for l in rule[aXb[j+1]]: temp = self.point+l if(temp not in closure_i[aXb[j+1]]): closure_i[aXb[j+1]].append(temp) # 重复,直至 closure(Ci)不再增大. if(closure_i != closure_i1): closure_i1 = closure_i.copy() else: return closure_i ''' 读操作: Go(Ci ,x ) x∈V Go(Ci ,x )=Cj 其中: Cj=&#123;A→αx·β∣ A→α·x β∈Ci&#125; ''' def op_go(self,i,x): c_j = dict() dict_j = self.C[i] for A in dict_j.keys(): for aXb in dict_j[A]: for j in range(len(aXb) - 1): if(aXb[j] == self.point and aXb[j+1] == x): if(A not in c_j.keys()): c_j.update(&#123;A:[]&#125;) c_j[A].append(aXb[:j]+aXb[j+1]+self.point+aXb[j+2:]) return c_j # 判断C[i]是否为终态 def judge(self,i): dict_i = self.C[i] for key in dict_i.keys(): for value in dict_i[key]: if(value[-1]!=self.point): return False return True def check_in_C(self,closure_j): for i in self.C.keys(): if closure_j == self.C[i]: return True return False def get_C(self): # 生成C0=&#123;S→ ·δ&#125; self.op_start() # ∪ &#123;S→ ·δ的闭包操作&#125; self.C[0]=self.op_closure(self.C[0]) ''' 重复以下过程,直至C不再增大为止. Ci读操作,生成Cj1,Cj2,…….Cjn Cj1,Cj2,…….Cjn闭包操作 (若其中某项目集已经存在就略去) ''' i = 0 j = 1 while(True): # 判断C[i]是否为终态 if (i == j): break if(self.judge(i)==True): self.tC.append(i) i=i+1 continue for v in self.V: c_j = self.op_go(i,v) if(len(c_j)!=0): #self.C[j] = c_j closure_j = self.op_closure(c_j) flag = True # for key in self.C.keys(): # if(closure_j == self.C[key]): # flag = False if self.check_in_C(closure_j): flag=False if flag: self.C[j]=closure_j j = j + 1 if (i&lt;j): i=i+1 else: break # 用于建分析表的Go函数返回状态集的编号 def GO(self,i,x): c_j = dict() dict_j = self.C[i] for A in dict_j.keys(): for aXb in dict_j[A]: for j in range(len(aXb) - 1): if (aXb[j] == self.point and aXb[j + 1] == x): if (A not in c_j.keys()): c_j.update(&#123;A: []&#125;) c_j[A].append(aXb[:j] + aXb[j + 1] + self.point + aXb[j + 2:]) # 别忘了闭包 c_j = self.op_closure(c_j) for key in self.C.keys(): if self.C[key]==c_j: return key return -1 # 生成辅助规约映射self.r def get_r(self): rule1 = self.rule.copy() item = rule1[self.start] rule1[self.start]=[item] i = 0 for left in rule1.keys(): for right in list(rule1[left]): self.r[i] = &#123;left: right&#125; i = i+1 # 构造分析表的action部分 def get_action(self): # 若GO(Ci, a)=Cj a∈Vt, 置ACTION(i,a)=Sj for i in self.C.keys(): for a in self.Vt: j = self.GO(i,a) if(j!=-1): self.action[(i,a)]='S'+str(j) # 若A→α·∈Ci , 且 a∈FOLLOW(A) # a∈Vt 置ACTION(i,a)=rj (A → α为第 j个产生式) for i in self.C: for A in self.C[i].keys(): for item in self.C[i][A]: # 项目最后一个为点 '·' if(item[-1] == self.point): for a in self.follow[A]: # 找到对应的规约产生式 for j in self.r.keys(): temp = &#123;A:item[:-1]&#125; if(self.r[j] == temp): self.action[(i,a)]='r'+str(j) # 若S→δ·∈ Ck ,(S为拓广文法开始符号） # 置ACTION(k,#)=acc omiga = rule[self.start]+self.point for k in self.C: for key in self.C[k].keys(): if(key==self.start and omiga in self.C[k][key]): self.action[(k,'#')]="acc" # 构造分析表的goto部分 def get_goto(self): # 若GO(Ci, A)=Cj A∈Vn, 置GOTO(i,A)=j for i in self.C.keys(): for A in self.Vn: j = self.GO(i, A) if (j != -1): self.goto[(i, A)] = j # SLR（1）法分析 # symbol: 符号语句 word: 真实语句 def compile(self, symbol, word, log): # 预定义.PLACE变量 if log == True: E_place = [] F_place = [] V_place = [] T_place = [] t = 0 #temp计数器 kk = 1#log计数器 # 补充# symbol+="##" # 状态栈 state = ['0'] # 符号栈 charater = ['#'] #输入串下标 k=0 while(True): state_now = eval(state[len(state)-1]) input_ch = symbol[k] if ((state_now,input_ch) in self.action.keys()): action = self.action[(state_now, input_ch)] else: action='-1' if(action[0]=='S'): #if(input_ch != '#'): k = k+1 charater.append(input_ch) state.append(action[1:]) continue elif(action[0]=='r'): # 规约动作r r = &#123;&#125; r = self.r[eval(action[1])] # 规约长度 lenth = 0 # 规约终结符 substitude = '' r_rule='' for left in r.keys(): substitude = left for right in r[left]: r_rule+=right for i in range(len(r_rule)): charater.pop() state.pop() # 根据规约规则r_rule决定执行动作, log为分析开关 if log==True: print("["+str(kk)+"]: "+substitude+" -&gt; "+r_rule) kk = kk+1 # ② A →V=E if (substitude == 'A' and r_rule == "V=E"): print("( =, "+E_place.pop()+", ,"+V_place.pop()+" )") # ③ E(1)→E(2)+T elif (substitude == 'E' and r_rule == "E+T"): E1_place = "temp"+str(t) t=t+1 print("( +, "+E_place.pop()+", "+T_place.pop()+", "+E1_place+" )") E_place.append(E1_place) # ④ E → T elif (substitude == 'E' and r_rule == "T"): E_place.append(T_place.pop()) # ⑤ T(1)→ T(2)*F elif (substitude == 'T' and r_rule == "T*F"): T1_place = "temp"+str(t) t=t+1 print("( *, "+T_place.pop()+", "+F_place.pop()+", "+T1_place+" )") T_place.append(T1_place) # ⑥ T → F elif (substitude == 'T' and r_rule == "F"): T_place.append(F_place.pop()) # ⑦ F →(E) elif (substitude == 'F' and r_rule == "(E)"): F_place.append(E_place.pop()) # ⑧ F → i elif (substitude == 'F' and r_rule == "i"): F_place.append(word[k-1]) # ⑨ V →i elif (substitude == 'V' and r_rule == "i"): V_place.append(word[k-1]) # 新规约终结符进符号栈 charater.append(substitude) new_state = self.goto[(eval(state[len(state)-1]),substitude)] state.append(str(new_state)) elif(action=='acc'): return True else: return Falseif __name__ == "__main__": # 终结符号集/非终结符号集 Vn = ['A', 'V', 'E', 'T', 'F'] Vt = ['+', '-', '*', '/', '(', ')', 'i' , '='] # 规则集合 rule = &#123; 'A': ["V=E"], 'E': ["E+T","E-T","T"], 'T': ["T*F", "T/F", "F"], 'F': ["(E)","i"], 'V': ["i"] &#125; slr = SLR(start='A',Vt=Vt,Vn=Vn,rule=rule) test_words = "" test_symbol = "" f = open("in2.0.txt",'r') while(True): t = f.readline().strip('\n') if(t == ''): break test_symbol += t[0] test_words += t[-1] print(slr.compile(symbol=test_symbol,word=test_words,log=True))]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——页面置换算法]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实验目的设计和实现最佳置换算法、先进先出置换算法、最近最久未使用置换算法、改进型Clock置换算法、页面缓冲置换算法；通过页面访问序列随机发生器实现对上述算法的测试及性能比较。 前提假设 页表用整数数组或结构数组来表示 页面访问序列串是一个整数序列，整数的取值范围为0到N-1。页面访问序列串中的每个元素p表示对页面p的一次访问 实验设计全局变量为了便于对不同算法的统一设计，在代码中设计了一些全局变量，作如下说明： 变量名 类型 备注 req typedef struct { int request;bool lack=false; int modify=0;} 记录一个页面请求。request：请求页号；lack：该请求是否缺页；modify：请求页是否被修改。 re vector&lt;req> 数组记录，re[i]代表第i个时刻进来的页面请求结构体。 bar int [M][N] 记录物理块情况。M个块、N个请求。 access int [M] 记录M个块所存页号的访问位 modify int [M] 记录M个块所存页号的修改位 FIFOFIFO即first in first out该算法的替换策略为： 每次发生缺页时总是替换出最早进入物理块的页号，即最先进来的就最先出去。 所以整个算法总共分为三步： 页号预装(注：预装页号默认为不会重复，下同) 1234567891011//没个块，n个请求double FIFO(int m,int n)&#123; memset(bar, -1, sizeof(bar)); //初始化前0〜m-1个序列 //i: 周期 for(int i=0;i&lt;m;i++)&#123; //j: 块 for(int j=0;j&lt;=i;j++)&#123; bar[j][i] = re[j].request; &#125; &#125; 检查所到请求是否存在于物理块中 123456789101112131415161718//装载第i: m〜n-1个序列for(int i=m;i&lt;n;i++)&#123; //对j：0〜m块，首先把第i-1时段各块的情况拷贝给第i的时段 for(int j=0;j&lt;m;j++)&#123; bar[j][i] = bar[j][i-1]; &#125; //记录第i个请求 int now_req=re[i].request; //判断现在内存中有无该请求页号 bool has=false; for(int j=0;j&lt;m;j++)&#123; if(bar[j][i]==now_req)&#123; has=true; break; &#125; &#125; //有的话直接下一个 if(has) continue; 如果不存在，则将最早进入物理块的页号替换出去 123456789101112131415161718192021222324252627// 没有的话要考虑把谁替换掉 // 先记录缺页 re[i].lack=true; // 考察序列范围：第i+1个到第n-1个 // 对m个块中个字各自装载的页号考察 // 需要向前检查bar[j][i]，即bar[j]目前内存中的页号装载了几个周期 int long_m=-1;//记录待了最久的bar[j]的次数 int long_j=-1;//记录待了最久的bar[j]的下标j for(int j=0;j&lt;m;j++)&#123; int temp_m=0; int temp_no=bar[j][i]; for(int k=i-1;k&gt;0;k--)&#123; if(temp_no==bar[j][k]) temp_m++; else break; &#125; if(temp_m&gt;long_m)&#123; long_m=temp_m; long_j=j; &#125; &#125; //替换 bar[long_j][i]=now_req;&#125; OPT最佳页面置换算法OPT，即optimal page replacement该算法的替换策略为： 选择永不使用或是在最长时间内不再被访问（即距现在最长时间才会被访问）的页面淘汰出内存 所以在遇到缺页时，需要根据物理块中现有的页号向后考察请求队列，将最晚出现或者从未出现的页号替换出内存整个算法总共分为三步： 页号预装 1234567891011//最佳置换: m个块，n个周期序列double OPT(int m,int n)&#123; memset(bar, -1, sizeof(bar)); //初始化前0〜m-1个序列 //i: 周期 for(int i=0;i&lt;m;i++)&#123; //j: 块 for(int j=0;j&lt;=i;j++)&#123; bar[j][i] = re[j].request; &#125; &#125; 检查所到请求是否存在于物理块中 123456789101112131415161718//装载第i: m〜n-1个序列for(int i=m;i&lt;n;i++)&#123; //对j：0〜m块，首先把第i-1时段各块的情况拷贝给第i的时段 for(int j=0;j&lt;m;j++)&#123; bar[j][i] = bar[j][i-1]; &#125; //记录第i个请求 int now_req=re[i].request; //判断现在内存中有无该请求页号 bool has=false; for(int j=0;j&lt;m;j++)&#123; if(bar[j][i]==now_req)&#123; has=true; break; &#125; &#125; //有的话直接下一个 if(has) continue; 如果不存在，则将未来最长时间内不再被请求的页号替换出去 123456789101112131415161718192021222324252627282930313233343536// 没有的话要考虑把谁替换掉 // 先记录缺页 re[i].lack=true; // 考察序列范围：第i+1个到第n-1个 // 对m个块中个字各自装载的页号考察 bool find=false; int far_no=-1,far_m=-1;//记录最远出现的页号和其所在块 for(int j=0;j&lt;m;j++)&#123; int temp_no=bar[j][i]; int temp_m=-1; int k=i+1; for(;k&lt;n;k++)&#123; //在未来的请求序列中找到了temp_no if(re[k].request==temp_no)&#123; temp_m=k; find=true; break; &#125; &#125; //记录距离最大的 if(temp_m&gt;far_m)&#123; far_m=temp_m; far_no=j; &#125; //未来请求中没有，则肯定替换这个 if(k==n)&#123; find=false; bar[j][i]=now_req; break; &#125; &#125; //找到了一个未来中最大的 if(find)&#123; bar[far_no][i]=now_req; &#125; LRU最近最久未使用置换算法LRU，即Least Recently Used该算法的替换策略为： 以“最近的过去”作为“最近的将来”的近似，选择最近一段时间最长时间未被访问的页面淘汰出内存 该算法的思想与OPT类似，但搜索方向相反，每次在遇到缺页时其总是根据物理块中现有的页号向前考察请求队列，将最早出现的请求页号替换出内存整个算法总共分为三步： 页号预装 12345678910double LRU(int m,int n)&#123; memset(bar, -1, sizeof(bar)); //初始化前0〜m-1个序列 //i: 周期 for(int i=0;i&lt;m;i++)&#123; //j: 块 for(int j=0;j&lt;=i;j++)&#123; bar[j][i] = re[j].request; &#125; &#125; 检查所到请求是否存在于物理块中 123456789101112131415161718//装载第i: m〜n-1个序列for(int i=m;i&lt;n;i++)&#123; //对j：0〜m块，首先把第i-1时段各块的情况拷贝给第i的时段 for(int j=0;j&lt;m;j++)&#123; bar[j][i] = bar[j][i-1]; &#125; //记录第i个请求 int now_req=re[i].request; //判断现在内存中有无该请求页号 bool has=false; for(int j=0;j&lt;m;j++)&#123; if(bar[j][i]==now_req)&#123; has=true; break; &#125; &#125; //有的话直接下一个 if(has) continue; 如果不存在，则将此时刻之前最久没有被请求过的页号替换出去 12345678910111213141516171819202122232425262728293031// 没有的话要考虑把谁替换掉 // 先记录缺页 re[i].lack=true; // 考察序列范围：第i-1个到第0个 // 对m个块中个字各自装载的页号考察 bool find=false; int far_no=-1,far_m=0xff;//记录最远出现的页号和其所在块 for(int j=0;j&lt;m;j++)&#123; int temp_no=bar[j][i]; int temp_m=-1; int k=i-1; for(;k&gt;0;k--)&#123; //在过去的请求序列中找到了temp_no if(re[k].request==temp_no)&#123; temp_m=k; find=true; break; &#125; &#125; //记录距离最大的 if(temp_m&lt;far_m)&#123; far_m=temp_m; far_no=j; &#125; &#125; //找到了一个过去中最远出现的 if(find)&#123; bar[far_no][i]=now_req; &#125;&#125; new clock改进型Clock置换算法与上面三个有所不同，其需要用到页面的访问位和修改位，即在全局变量部分的access和modify数组。算法的思想如下： ① 从查寻指针当前位置起扫描内存分页循环队列，选择A=0且M=0的第一个页面淘汰；若未找到，转②② 开始第二轮扫描，选择A=0且M=1的第一个页面淘汰，同时将经过的所有页面访问位置0；若不能找到，转① 所以在算法执行时主要考察两类物理块，即 1类(A =0, M = 0)：表示该页面最近既未被访问，又未被修改，是最佳淘汰页。 2类(A =0, M = 1)：表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。 算法的设计需要五步： 页号预装、变量初始化 12345678910111213double new_clock(int m,int n)&#123; memset(bar, -1, sizeof(bar)); //初始化前0〜m-1个序列 //i: 周期 for(int i=0;i&lt;m;i++)&#123; //j: 块 for(int j=0;j&lt;=i;j++)&#123; bar[j][i] = re[j].request; access[j] = 1;//被访问 modify[j] = re[j].modify;//被修改过 &#125; &#125; int p=0;//充当指针 检查所到请求是否存在于物理块中 1234567891011121314151617181920212223//装载第i: m〜n-1个序列for(int i=m;i&lt;n;i++)&#123; //对j：0〜m块，首先把第i-1时段各块的情况拷贝给第i的时段 for(int j=0;j&lt;m;j++)&#123; bar[j][i] = bar[j][i-1]; &#125; //记录第i个请求 int now_req=re[i].request; int now_modify=re[i].modify; //判断现在内存中有无该请求页号 bool has=false; for(int j=0;j&lt;m;j++)&#123; if(bar[p][i]==now_req)&#123; has=true; access[p]=1; modify[p]=now_modify; p = (p+1)%m; break; &#125; p = (p+1)%m; &#125; //有的话直接下一个 if(has) continue; 如果不存在，则先找第一类 access=0 &amp;&amp; modify==0 123456789101112131415161718192021222324// 没有的话要考虑把谁替换掉 // 先记录缺页 re[i].lack=true; do&#123; //先找第一类 access=0 &amp;&amp; modify==0 bool first=false; //从指针所指位置开始 for(int j=0;j&lt;m;j++)&#123; if(access[p]==0 &amp;&amp; modify[p]==0)&#123; bar[p][i] = now_req;//找到则替换 access[p] = 1;//被访问 modify[p] = now_modify; p = (p+1)%m; first=true; break; &#125; p = (p+1)%m; &#125; if(first)&#123; break; &#125; 如果第一类不存在，则找第二类 access=0 &amp;&amp; modify==1 12345678910111213141516171819202122//第一类失败//再第二类 access=0 &amp;&amp; modify==1bool second=false;for(int j=0;j&lt;m;j++)&#123; if(access[p]==0 &amp;&amp; modify[p]==1)&#123; bar[p][i] = now_req;//找到则替换 access[p] = 1;//被访问 modify[p] = now_modify; p = (p+1)%m; second=true; break; &#125; else&#123; access[p]=0;//访问位均改为0 p = (p+1)%m; &#125;&#125;if(second)&#123; break;&#125; 如果第二类也不存在，则转回第三步 12345678//第二类失败 //指针返回开始位置 p=0; //将所有的访问位复0 for(int j=0;j&lt;m;j++)&#123; access[j]=0; &#125;&#125;while(1); PBA页面缓冲算法PBA，即Page Buffering Algorithm该算法与前面提到的四个算法有着很大的差别，简单来说，该算法需要额外创建一个空闲页面链表，该链表的作用好比额外提供了一定数目的空闲物理块，挂在空闲链表上的页号仍然存在于内存中，只是不在现有的驻留集中，即存在位==0。每当请求页号不在现有的驻留集中时，需要先考察链表上是否挂有请求页号，如果有则将其摘下俩表重新填回驻留集中，如果没有则将填入链首所指向的物理块中。被替换的页号可以采用上面四种中的任意一种方法决定，在该实验中我选取的替换策略为FIFO。 实现PBA需要额外引入一些新的变量，并且需要重新修改物理块的定义：1234567891011121314//PBA:基于先进先出: m个块，n个周期序列，k个空闲块// 空闲页面链表typedef struct &#123; int what;//块内容 int which;//块号&#125;idle_bar;list&lt;idle_bar&gt; idle;// 物理块typedef struct &#123; int flag=0;//存在位 int No=-1;//块号 int time=-1;//time时进入块，用于辅助先进先出判断&#125;NODE;NODE node[M+K]; 算法的设计需要五步： 页号预装、空闲页面链表初始化 1234567891011121314151617double PBA(int m,int n,int k)&#123; //初始化前0〜m-1个序列 //i: 周期 printf("预设:\n"); for(int i=0;i&lt;m;i++)&#123; node[i].No=re[i].request; node[i].flag=1; node[i].time=i; &#125; //idle装入k个空闲物理块 for(int i=0;i&lt;k;i++)&#123; idle_bar temp; temp.what=-1; temp.which=m+i; idle.push_back(temp); &#125; 检查所到请求是否存在于物理块中且在当前驻留集中 1234567891011121314151617181920212223//装载第i: m〜n-1个序列 for(int i=m;i&lt;n;i++)&#123; int now_req=re[i].request; //先在物理块中寻找有没有 int has=-2; for(int j=0;j&lt;m+k;j++)&#123; //存在位为0，说明是挂在idle上的块 if(node[j].flag==0&amp;&amp;node[j].No==now_req)&#123; //has记录在哪个块中 has=j; break; &#125; if(node[j].flag==1&amp;&amp;node[j].No==now_req)&#123; has=-1; break; &#125; &#125; //在内存中且在驻留集中 if(has==-1)&#123; printf("[%d]: 在驻留集中\n",now_req); continue; &#125; 请求存在于物理块中，但不在当前驻留集中 123456789101112131415161718192021222324252627282930313233//在内存中但不在驻留集中 if(has&gt;-1)&#123; printf("[%d]: 在空闲链表上\n",now_req); //要把其拿回到驻留集中 for(list&lt;idle_bar&gt;::iterator it=idle.begin();it!=idle.end();it++)&#123; if(it-&gt;what==now_req)&#123; //fifo替换准则 int mintime=n,minjj=-1; for(int jj=0;jj&lt;m+k;jj++)&#123; if(node[jj].flag==0)//只能替换存在的 continue; if(node[jj].time&lt;mintime)&#123; mintime=node[jj].time; minjj=jj; &#125; &#125; node[minjj].flag=0; node[has].flag=1;//更新为存在 node[has].time=i;//更新时间 //在链表上删除掉，并把替换下来的minjj放入idle中 idle.erase(it); idle_bar temp; temp.what=node[minjj].No; temp.which=minjj; idle.push_back(temp); break; &#125; &#125; for(int ii=0;ii&lt;m+k;ii++) if(node[ii].flag==1)printf("%d ",node[ii].No); cout&lt;&lt;endl; continue; &#125; 请求不在于物理块中，但当前空闲链表中存在空物理块 123456789101112131415161718192021222324252627282930313233343536373839404142//如果不在物理块(内存)中 if(has==-2)&#123; printf("[%d]: 不在物理块中\n",now_req); re[i].lack=true;//缺页 //基于fifo替换 int mintime=n,minjj=-1; for(int jj=0;jj&lt;m+k;jj++)&#123; if(node[jj].flag==0)//只能替换存在的 continue; if(node[jj].time&lt;mintime)&#123; mintime=node[jj].time; minjj=jj; &#125; &#125; //决定了要被替换的为node[minjj] //先看idle中的空闲块没用满的情况 //则新来的直接进空闲块 int flag1=-1; for(list&lt;idle_bar&gt;::iterator it=idle.begin();it!=idle.end();it++)&#123; //空闲块 if(it-&gt;what==-1)&#123; node[it-&gt;which].flag=1; node[it-&gt;which].No=now_req; node[it-&gt;which].time=i; idle.erase(it);//idle链表上删去这个空闲块 idle_bar temp; temp.what=node[minjj].No; temp.which=minjj; idle.push_back(temp);//被替换下来的进idle node[minjj].flag=0; flag1=1; break; &#125; &#125; if(flag1==1)&#123; for(int ii=0;ii&lt;m+k;ii++) if(node[ii].flag==1)printf("%d ",node[ii].No); cout&lt;&lt;endl; continue;//空闲替换成功 &#125; 请求不在于物理块中，当前空闲链表中不存在空物理块 1234567891011121314151617181920//idle中已经没有空闲块的情况 //需要替换链首块的内容 //将now_req放入此时idle链首的块里，原来链首的内容被彻底移出内存块 //根据fifo提出新的块放入idle中 int head=idle.begin()-&gt;which; node[head].flag=1; node[head].time=i; node[head].No=now_req; idle.pop_front();//移出队首 idle_bar temp; temp.what=node[minjj].No; temp.which=minjj; idle.push_back(temp);//被替换下来的进idle node[minjj].flag=0; for(int ii=0;ii&lt;m+k;ii++) if(node[ii].flag==1)printf("%d ",node[ii].No); cout&lt;&lt;endl;&#125; 在所有页面置换算法实现之后，现在来构建页面访问序列随机生成函数。 随机生成算法根据实验的要求，符合局部访问特性的随机生成算法执行步骤如下： 确定虚拟内存的尺寸N，工作集的起始位置p，工作集中包含的页数e，工作集移动率m（每处理m个页面访问则将起始位置p +1），以及一个范围在0和1之间的值t； 生成m个取值范围在p和p + e间的随机数，并记录到页面访问序列串中； 生成一个随机数r，0 ≤ r ≤ 1； 如果r &lt; t，则为p生成一个新值，否则p = (p + 1) mod N； 如果想继续加大页面访问序列串的长度，请返回第2步，否则结束。 根据以上思想，可以编写如下生成函数：123456789101112131415161718192021222324252627282930313233343536373839// 页面访问序列随机生成/* 虚拟内存大小：16位=64K 工作集的起始位置p， 工作集中包含的页数e， 工作集移动率m（每处理m个页面访问则将起始位置p +1）， 以及一个范围在0和1之间的值t； */void init()&#123; int p = rand() % 64; int m = 8, e = 4; int i, j; double t; t = rand() % 10 / 10.0; for (i = 0; i &lt; 4; i++) &#123; //生成m个取值范围在p和p + e间的随机数，并记录到页面访问序列串中； for (j = i * m; j &lt; (i + 1) *m; j++) &#123; req temp; temp.request = (p + rand() % e) % 64; temp.modify = rand()%2;//被随机修改，只针对clock算法 re.push_back(temp); &#125; //生成一个随机数r，0 ≤ r ≤ 1； double r = (rand() % 10) / 10.0; //如果r &lt; t，则为p生成一个新值，否则p = (p + 1) mod N if (r&lt;t) &#123; p=rand()%64; &#125; else &#123; p=(p+1)%64; &#125; &#125;&#125; 测试在准备工作都完毕后，这一节将对各个算法进行测试。 注：1.下列测试均认为预设页面不算做缺页2.‘X’代表当前请求产生缺页中断3.应用PBA算法时，既不在驻留集也不在空闲链表上时才认为缺页 生成访问序列首先调用init()函数，生成符合局部访问特性的随机序列123序列1:42 44 43 42 42 42 45 43 45 46 46 45 45 43 44 44 46 45 45 44 46 47 44 44 48 47 47 45 45 48 48 45序列2:54 56 55 55 54 56 57 55 55 56 56 57 56 58 56 56 59 56 57 56 56 56 59 56 59 57 59 59 60 59 58 57序列3:21 24 22 22 21 23 23 22 23 22 24 24 24 24 24 25 23 26 25 25 24 25 24 24 46 49 48 48 47 47 49 47 下面所有测试均取参数为：12m = 3 // 3个物理块n = 32 // 32个页号请求 FIFO针对序列1，调用FIFO(m,n)，可得到如下执行结果 OPT针对序列1，调用OPT(m,n)，可得到如下执行结果 LRU针对序列1，调用LRU(m,n)，可得到如下执行结果 new clock针对序列1，调用new_clock(m,n)，可得到如下执行结果 PBAPBA的测试与上述四种略有不同，由于其新增了一个空闲链表，故输出格式采用按时间序列输出。 本次测试采用k=2作为参数，即空闲链表上挂有两个空闲物理块。 针对序列1，调用PBA(m,n,k)，可得到如下执行结果 汇总针对序列2和序列3的测试结果此处不作详细展示下面对基于序列1、2、3应用五种算法的结果作一个汇总 序列1 算法 缺页率 FIFO 0.1875 OPT 0.15625 LRU 0.25 new clock 0.25 PBA 0.125 序列2 算法 缺页率 FIFO 0.21875 OPT 0.15625 LRU 0.28125 new clock 0.3125 PBA 0.125 序列3 算法 缺页率 FIFO 0.25 OPT 0.21875 LRU 0.3125 new clock 0.375 PBA 0.21875 平均缺页率 算法 缺页率 FIFO 0.21875 OPT 0.17708 LRU 0.28125 new clock 0.3125 PBA 0.15625 可以看到，相较之下缺页率最低的页面置换算法为PBA，这也符合实际情况。 另外需要说明的是，在应用new clock算法时，需要人为附加每个请求页的修改位标记，即modify，而另外四种算法则均忽略了修改位，所以单凭该试验结果，并不能说明表现最差的算法为改进型Clock置换算法，只能说明表现较好的算法为PBA和OPT算法。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pintos_project1]]></title>
    <url>%2F2019%2F05%2F16%2Fpintos-project1%2F</url>
    <content type="text"><![CDATA[本次博客将详细解释pintos project1的mission2部分。 首先来回顾一下pintos project1 mission1：在mission1里，我们的主要任务是实现了timer_sleep函数唤醒机制。这里需要说明的是，经过mission1之后，我们应该明白，pintos操作系统并不是一个空白的系统：它要求我们做的东西，大部分都已经实现了。就比如timer_sleep函数，在我们对其做更为优化的实现时，实际上该函数原本就有一套实现的原理：系统原本是使用busy wait实现的，即线程不停地循环，直到时间片耗尽。 （1）pintos project1 mission2的主要任务是在Pintos中实现优先级调度，需要解决的问题有如下两个，我们将分别对其进行实现。具体的思路为：先看这一部分的test要求我们做什么，然后按照test的内容去做我们的实现。这样的做法是比较高效的。（2）先看除去donation以外的测试。第一个测试priority-fifo的源代码如下。这个测试创建了一个优先级PRI_DEFAULT+2的主线程，并用这个线程创建了16个优先级PRI_DEFAULT+1的子线程，然后把主线程的优先级设置为优先级PRI_DEFAULT，所以现在pintos内有16个优先级PRI_DEFAULT+1的线程和1个优先级PRI_DEFAULT的线程在跑，测试需要把16个线程跑完再结束那一个线程。（3）注意OS中线程是并行执行的，有可能最开始的一个线程在设置完优先级之后立刻结束了，而此时其他线程并未结束，即注释。在线程设置完优先级之后应该立刻重新调度，因此只需要在thread_set_priority()函数里添加thread_yield()函数即可。（4）priority-fifo解决：（5）再看测试priority-preempt。该测试样例创建了一个新的高优先级线程抢占当前线程。需要解决的问题是高优先级对于低优先级的中断和抢占。（6）解决：如果新线程的优先级高于当前线程优先级，调用thread_yield()函数。（7）此时可发现priority-change也过了，查看此测试。这个测试创建了一个新线程并要这个线程立刻调用，然后在降低优先级之后它就不应该继续执行了，这正好对应于之前修改的两处，所以自然能通过测试。（8）上述三个测试解决之后的结果。 （9）接下来的两个测试都是线程同步问题。首先来看priority-seme测试：这个测试创建了10个优先级不等的线程，并且每个线程调用sema_down函数，其他得不到信号量的线程都得阻塞。而每次运行的线程释放信号量时必须确保优先级最高的线程继续执行。（10）解决：显然我们需要修改sema_up。查看semaphore结构体【位置：～/pintos/src/threads/synch.h】，结构体中有一waiters为阻塞队列，而pintos的sema_up设计：只是把waiters最前面的线程取出来加入到ready_list。那么修改方法就是在waiters中取出优先级最高的thread，并yield()。（11）priority-condvar测试：和前面的信号量机制类似，条件变量也维护了一个waiters用于存储等待接受条件变量的线程，那么就修改cond_signal（）函数唤醒优先级最高的线程即可，和priority-sema类似。实质：condition的waiters队列是优先级队列。（12）线程同步问题的阶段结果。 （13）剩下的测试都是有关于优先级捐赠的问题。那么什么是优先级捐赠问题？举例来说：线程A,B,C分别具有1,2,3优先级(数字越大说明优先级越高), 线程A,B目前在就绪队列中等待调度,线程A对一个互斥资源拥有线程锁。而此时,高优先级的线程C也想要访问这个互斥资源,线程C只好在这个资源上等待,不能进入就绪队列。当调度器开始调度时,它只能从A和B中进行选择,根据优先级调度原理,线程B将会首先运行。这时就产生了一个问题, 即本来线程C优先级比线程B高,但是线程B却先运行了,从而产生了优先级翻转问题。（14）怎么解决这个问题？ 当发现高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。对于优先级捐赠的这几个测试来说，有两个关键的问题，一是优先级嵌套，另一是因为互斥锁而导致的线程阻塞。并且这一系列的问题的解决并不是独立的。（15）接下来重点讲两个测试的原理。首先是测试priority-donte-multiple：original_thread是优先级为PRI_DEFAULT的线程，然后创建2个锁，接着创建优先级为PRI_DEFAULT+1的线程a，把锁a丢给这个线程的执行函数。这时候线程a抢占式地调用a_thread_func，获取了a这个锁，阻塞。然后original_thread输出线程优先级的msg。然后再创建一个线程优先级为PRI_DEFAULT+2的线程b， 和a一样做同样的操作。好， 然后original_thread释放掉了锁b，此时线程b被唤醒，抢占式执行b_thread_func。然后original再输出msg，a同上。实现思路是：释放一个锁的时候，将该锁的拥有者改为该线程被捐赠的第二优先级，若没有其余捐赠者， 则恢复原始优先级。那么我们的线程必然需要一个数据结构来记录所有对这个线程有捐赠行为的线程。（16）接下来是测试priority-donate-chain：这个测试其实就是一个链式优先级捐赠，本质测试的还是多层优先级捐赠逻辑的正确性。（17）donate的所有测试逻辑整合。（18）接下来是这部分测试的整体实现流程。 （19）最终结果如下。至此，我们实现了mission2里的全部内容。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——算符优先语法分析]]></title>
    <url>%2F2019%2F05%2F12%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面人们常说，对于同一个工程的代码量而言：1C/C++ : JAVA : python = 1000:100:10 前三次在C/C++为主导下创作的作业，代码量明显是一个逐次递增的过程，甚至到实验三的时候，代码量已经破了500大关！我寻思这可不是一个好的趋势，于是赶紧投笔从戎，放下C刀，从军python 人生苦短，我用python！ 目标任务实验项目实现算符优先分析算法，完成以下描述算术表达式的算符优先文法的算符优先分析过程。123G[E]:E→E+T∣E-T∣T T→T*F∣T/F∣F F→(E)∣i 设计说明终结符号i为用户定义的简单变量,即标识符的定义。 设计要求（1）构造该算符优先文法的优先关系矩阵或优先函数；（2）输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果。（3）算符优先分析过程应能发现输入串出错。（4）设计两个测试用例（尽可能完备，正确和出错），并给出测试结果；（5）考虑编写程序根据算符优先文法构造算符优先关系矩阵，并添加到你的算符优先分析程序中。 实验过程由于本次实验切换到了python下，虽然python的语法规范宽泛，没有严格的句式要求，但是为了保证结果的泛用性，我决定采用面向对象编程的方法来组织此次作业。 数据结构在明确好编程思想后，首先需要确定下来的就是如何组织类及类成员，如何存储数据。下面给出算符优先语法分析类class OPG的成员变量/函数及其设计说明： 成员变量 类型 备注 start str 记录文法开始符号 Vt list[str] 记录文法非终结符号集 Vn list[str] 记录文法终结符号集 rule dict{str: list[str]} 记录文法产生式 rule1 dict{str: list[str]} 用N替换rule产生式中的非终结符号，辅助判断最左素短语能否被规约 firstVt dict{str: set()} 记录非终结符号str对应的firstVt集 lastVt dict{str: set()} 记录非终结符号str对应的lastVt集 matrix dict{(str,str): str} 记录优先关系矩阵 成员函数 类型 备注 __init__(self,start,Vn,Vt,rule) class OPG 类的构造函数，通过输入文法的开始符号、非终结符/终结符号集、产生式规则从而构造并返回OPG类 get_firstVt(self) void 自动生成所有非终结符对应的firstVt集 get_lastVt(self) void 自动生成所有非终结符对应的lastVt集 get_matrix(self) void 自动生成优先关系矩阵 get_assistrule(self) void 生成辅助规则集合rule1 can_statute(self,test) bool 判断字符串test能否被规约 compile(self,test) bool 判断输入程序是否满足算符优先文法 自动生成firstVt生成firstVt由函数get_firstVt(self)实现，算法流程如下：其实现代码如下，注释均详细对应上述流程图1234567891011121314151617181920212223242526272829303132333435363738394041424344def get_firstVt(self): # 初始化firstVt self.firstVt = &#123;Vn: set() for Vn in self.Vn&#125; # 初始化辅助栈 stack = [] # 初始化辅助布尔判断函数 F = dict() # 根据原则①：若有规则U→b…, 或U→Vb…,则b∈FIRSTVT(U) # first -&gt; right for left in self.firstVt: for right in self.rule[left]: # U→b… if(right[0] in self.Vt): self.firstVt[left].add(right[0]) stack.append((left, right[0])) F[(left,right[0])] = True # U→Vb… elif(len(right)&gt;1 and right[0] in self.Vn and right[1] in self.Vt): self.firstVt[left].add(right[1]) stack.append((left, right[1])) F[(left, right[1])] = True # 根据原则②：若有规则U→V…,且b ∈FIRSTVT(V)，则b ∈FIRSTVT(U) while(len(stack)&gt;0): # 弹出栈顶元素,记(V,b) V,b = stack.pop() for left in self.Vn: for right in self.rule[left]: # 对每一个形如U→V…的规则 # U即left if(right[0]==V): # 若F(U,b) 为假,变为真, 进STACK栈 if((left,b) not in F.keys()): F[(left, b)]=True stack.append((left,b)) # 若F(U,b)为真,再循环 if(F[(left,b)]==True): continue # FIRSTVT(U)=&#123;b∣F(U,b)=TRUE&#125; for key in F: self.firstVt[key[0]].add(key[1]) 执行程序的结果如下，可以看出get_firstVt函数已正确执行： 自动生成lastVt生成lastVt由函数get_lastVt(self)实现，流程与生成firstvt几乎相同，只是在规则①和②的地方改为了寻找最后一个或倒数两个字符，算法流程如下：其实现代码如下，注释均详细对应上述流程图1234567891011121314151617181920212223242526272829303132333435363738394041424344def get_lastVt(self):# 初始化lastVtself.lastVt = &#123;Vn: set() for Vn in self.Vn&#125;# 初始化辅助栈stack = []# 初始化辅助布尔判断函数F1 = dict()# 根据原则①：若有规则U→…b, 或U→…bV,则b∈LASTVT(U)# first -&gt; rightfor left in self.firstVt: for right in self.rule[left]: # U→…b if(right[-1] in self.Vt): self.lastVt[left].add(right[-1]) stack.append((left, right[-1])) F1[(left,right[-1])] = True # U→…Vb elif(len(right)&gt;1 and right[-1] in self.Vn and right[-2] in self.Vt): self.lastVt[left].add(right[-2]) stack.append((left, right[-2])) F1[(left, right[-2])] = True# 根据原则②：若有规则U→…V,且b ∈ LASTVT(V)，则b ∈ LASTVT(U)while(len(stack)&gt;0): # 弹出栈顶元素,记(V,b) V,b = stack.pop() for left in self.Vn: for right in self.rule[left]: # 对每一个形如U→…V的规则 # U即left if(right[-1]==V): # 若F(U,b) 为假,变为真, 进STACK栈 if((left,b) not in F1.keys()): F1[(left, b)]=True stack.append((left,b)) # 若F(U,b)为真,再循环 if(F1[(left,b)]==True): continue# FIRSTVT(U)=&#123;b∣F(U,b)=TRUE&#125;for key in F1: self.lastVt[key[0]].add(key[1]) 执行程序的结果如下，可以看出get_lastVt函数已正确执行： 自动生成优先关系矩阵生成优先关系矩阵由函数get_matrix(self)实现，根据算法描述，程序需要考虑以下四种字符组合情况： …ab… : Xi = Xi+1 …aVb… : Xi = Xi+2 …aU… : a &lt; firstvt(U) …Ub… : lastvt(U) &gt; b 对所有产生式中的规则而言，其均满足上述四种情况中的一种，其实现程序如下：1234567891011121314151617181920212223242526272829303132333435def get_matrix(self): # 用字典映射来记录算符优先关系（横，纵）-&gt; '&gt;、&lt;、=' self.matrix = dict() # left -&gt; right for left in self.Vn: for right in self.rule[left]: for i in range(len(right)-1): # ...ab... : Xi = Xi+1 if(right[ i ] in self.Vt and right[i + 1] in self.Vt): self.matrix[(right[i], right[i + 1])] = '=' # ...aVb... : Xi = Xi+2 if(i&lt;len(right)-2 and right[i] in self.Vt and right[i+2] in self.Vt): self.matrix[(right[i], right[i + 2])] = '=' # ...aU... : a &lt; firstvt(U) if(right[i] in self.Vt and right[i+1] in self.Vn): for b in self.firstVt[right[i+1]]: self.matrix[(right[i], b)] = '&lt;' # ...Ub... : lastvt(U) &gt; b if(right[i] in self.Vn and right[i+1] in self.Vt): for a in self.lastVt[right[i]]: self.matrix[(a, right[i+1])] = '&gt;' # 处理：'#' # '#' &lt; firstvt(S) # '#' &lt; lastvt(S) # '(#,#)'='=' for item in self.firstVt[self.start]: self.matrix[('#',item)]='&lt;' for item in self.lastVt[self.start]: self.matrix[(item,'#')]='&gt;' self.matrix[('#','#')]='=' 最后别忘了对#的处理，由于#只出现在拓广文法S-&gt;\#E\#中，所以可以直接应用上述第2、3、4种情况下的对应处理方法，即： # = # # &lt; firstVt[E] lastVt[E] &gt; # 程序的执行结果如下，可以看到优先关系矩阵的详细信息： 判断能否规约在分析OPG分析过程中，涉及到一步：对于找到的最左素短语，应判断是否存在产生式规则能对其进行规约。由于在分析过程中，非终结符均被N所替代，所以首先要调用get_assistrule(self)将rule中非的终结符用N来替换，生成辅助规则集rule1，以便检查规约。get_assistrule(self)的代码如下：1234567891011def get_assistrule(self): self.rule1 = &#123;key : list() for key in self.rule.keys()&#125; for key in self.rule.keys(): for right in self.rule[key]: right1="" for c in range(len(right)): if (right[c] in self.Vn): right1+='N' else: right1+=right[c] self.rule1[key].append(right1) 在替换完成后，我们便可根据rule1来进行规则的匹配，对于传入的最左素短语test而言，调用函数can_statute(self,test)即可给出判断结果，代码如下：1234567# 判断最左素短语能否规约def can_statute(self,test): for key in self.rule1: for right in self.rule1[key]: if(test==right): return True return False 主分析在上述准备工作都完成后，接下来便可以开始我们的主分析流程。主分析对应函数compile(self,test)，其功能为：对于传入的程序串test，可以给出其对于算符优先文法的判别结果，如果出错可以返回出错分析结果。算法的处理流程如下：总而言之，分析流程的思想为，先找到一个符号串满足如下约束：$$a_j&lt; a_j+1 = a_j+2 = … a_i &gt; R$$其中: R为即将输入的字符，a为分析栈中的字符如果找到了这样的字符串，说明此时我们已经找到了分析栈中待规约的最左素短语$a_j-1…a_i$。如果其能规约，只需将这一串字符替换为N；如果不能规约，说明其不满足该文法下的算符优先语法，即出错。 主分析的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273def compile(self,test): # 分析栈 analyse_stack = ['#'] i = 0 j = 0 # j+1到i记录最左素短语 k = -1 # i记录输入串下标 while(True): k = k+1 # 数组越界则为出错 if(k&gt;len(test) or i&gt;len(analyse_stack) or j&gt;len(analyse_stack)): print("[error] 输入串格式不满足算符文法格式") return False R = test[k] # R记录输入串下一个要输入的字符 while(True): # 寻找非终结符 if(analyse_stack[i] in self.Vt): j = i else: j = i-1 # S(j),R 无优先关系 if((analyse_stack[j],R) not in self.matrix.keys()): print("[error] \'" + analyse_stack[j] + "\',\'" + R + "\' 无优先关系") return False # S(j)&lt;R 或 S(j)=R if(self.matrix[(analyse_stack[j],R)]!='&gt;'): i = i+1 if(i&gt;=len(analyse_stack)): analyse_stack.append(R) else: #analyse_stack.append(R) analyse_stack[i]=R break # S(j)&gt;R while(True): # Q=S(j) Q = analyse_stack[j] j = j-1 if(analyse_stack[j] not in self.Vt): j = j-1 # S(j),Q 无优先关系 if ((analyse_stack[j], Q) not in self.matrix.keys()): print("[error] \'" + analyse_stack[j] + "\',\'" + Q + "\' 无优先关系") return False # S(j)&lt; Q &gt;R temp=self.matrix[(analyse_stack[j],Q)] if(temp=='&lt;'): break # 检验最左素短语是否能规约 item = j+1 the_left="" while(item&lt;=i): the_left += analyse_stack[item] item+=1 if(self.can_statute(the_left)): for c in range(j+2,i+1): analyse_stack.pop() i = j+1 analyse_stack[i] = 'N' else: print("无法规约："+the_left) return False # 成功 if(i==1 and R=='#'): return True 测试分析基于题设要求，输入文件为词法分析器的输出结果，类似如下格式： 我共选用了两组五个测试样例对模型进行了测试，包括两正三负： 正确样例 错误样例模型可检测出不满足产生式的句型：模型可检测出无优先级的句型：模型可检测出包含未定义的符号（即无优先级）的句型： 总结到此，本次算符优先实验已全部完成。我的模型具有如下优点： 根据产生式规则自动生成firstVt集合 根据产生式规则自动生成lastVt集合 根据产生式规则自动生成优先关系矩阵 可以分析多种出错原因 面向对象的思想，模型泛化能力强。只需要改变输入规则集，其可以应对一切算符优先文法。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——LL(1)语法分析器]]></title>
    <url>%2F2019%2F05%2F02%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94LL-1-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实验项目实现LL(1)分析中控制程序（表驱动程序）;完成以下描述赋值语句的LL(1)文法的LL(1)分析过程。123456789S→V=EE→TE′E′→ATE′|εT→FT′T′→MFT′|εF→ (E)|iA→+|-M→*|/V→i 设计说明终结符号i为用户定义的简单变量，即标识符的定义 设计要求（1）输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果；（2）LL(1)分析过程应能发现输入串出错；（3）设计两个测试用例（尽可能完备，正确和出错），并给出测试结果；（4）考虑根据LL(1)文法编写程序构造LL（1）分析表，并添加到你的LL（1）分析程序中。 设计思路总数据流LL(1)语法分析器的实现相比递归下降而言复杂了很多，但概括起来程序的实现总共需要如下几步： 构造非终结符的First集 构造非终结符的Follow集 根据First集和Follow集构造LL(1)分析表 根据分析表构造分析栈逐个匹配 所以流程如下： 存储结构在总数据流确定之后，可以发现在分析过程中涉及到很多辅助量，例如各个非终结符对应的First集。而设置怎样的数据结构来存储这些辅助量是一个在程序编写之前就应该确定下来的问题。下面给出我在程序编写中所预设的数据结构： table th:first-of-type { width: 100px; } 变量名 类型 含义 rule map&lt;string,vector&gt; 记录产生式规则: string→{string,string...} first map&lt;char,set&gt; 记录各个非终结符号对应的first集 follow map&lt;char,set&gt; 记录各个非终结符号对应的follow集 Vt set&lt;char> 记录终结符集合Vt Vn set&lt;char> 记录非终结符集合Vn start char 文法开始符号 point struct Point{char vt; char vn} 记录分析表坐标 table map&lt;point,string&gt; LL(1)分析表：point[坐标]→string[对应动作] file_tuple typedef struct {int code; char symbol} 记录输入的二元组,code:编码,symbol:符号 file_text vector&lt;file_tuple&gt; 存储整个输入文件 在存储结构确定之后，我们便可以着手落实LL(1)语法分析器的实现了，首先从first集的构造开始。 自动构造first集首先需要对first集有一个理性的定义： $$first(α)=\lbrace a| α=^*&gt;aδ,且a∈V_t,δ∈V^* \big\rbrace (若α=^*&gt;ε,则ε∈first(α)\big)$$ first集的构造有确定的算法，算法的描述如下： 若x∈Vt, 则FIRST(x)={x}若X∈Vn, 有X→aα,(a∈Vt)或/和X→ε,则a或/和ε∈FIRST(x)对X→Y1Y2…….Yk(且Y1∈Vn), 反复使用以下直到每一个FIRST(X)不再增大为止. i. 若Y1 ∈Vn,则把FIRST(Y1 )\ {ε}元素加入FIRST(X)中ii. 若Y1、Y2、……Y i-1 ∈Vn (2≤i ≤k),且ε ∈FIRST(Yj) (1≤j≤i-1),则把FIRST(Yi)\ {ε}元素加入FIRST(x)中iii. 若Y1、Y2、……Yk ∈Vn,且ε∈FIRST(Yj)(1≤j≤k),则把ε元素加入FIRST(x)中 用代码实现这样抽象的算法并不是一件简约的事情，下面是构造first集的代码，其中各个步骤都标有详细的注释，分别对应上述算法中的各个步骤：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110void make_first()&#123; //初始化first集 for(set&lt;char&gt;::iterator it = Vn.begin();it!=Vn.end();it++)&#123; set&lt;char&gt;t; first.insert(make_pair(*it,t)); &#125; //遍历规则rule //2.若X∈Vn,有X→aα,(a∈Vt)或/和X→ε 则a或/和ε∈FIRST(x) for(map&lt;string,vector&lt;string&gt;&gt;::iterator it=rule.begin();it!=rule.end();it++)&#123; //用tempp记录it-&gt;first对应的first集 set&lt;char&gt; tempp; //left -&gt; right vector&lt;string&gt; right=it-&gt;second; string left=it-&gt;first; for(int i=0;i&lt;right.size();i++)&#123; // X-&gt;aα (a∈Vt) a即right[i][0] if(Vt.count(right[i][0])!=0)&#123; tempp.insert(right[i][0]); &#125; // X→ε 则ε∈FIRST(x) if(right[i]==" ")&#123; tempp.insert(' '); &#125; &#125; if(first.at(*left.c_str()).size()==0)&#123; first.at(*left.c_str())=tempp; &#125; else first.at(*left.c_str()).insert(tempp.begin(),tempp.end()); &#125; //循环结束条件： 直到每一个FIRST(X)不再增大为止 //3.对X→Y0Y1…….Yk(且Y0 ∈Vn), 反复使用以下直到每一个FIRST(X)不再增大为止 set&lt;char&gt; temp[9]; int k=0,first_size=0; for(map&lt;string,vector&lt;string&gt;&gt;::iterator it=rule.begin();;it++,k++)&#123; //用temp[k]记录it-&gt;first对应的first集 //set&lt;char&gt; temp; //left -&gt; right vector&lt;string&gt; right=it-&gt;second; string left=it-&gt;first; //3.对X→Y0Y1…….Yk(且Y0 ∈Vn), 反复使用以下直到每一个FIRST(X)不再增大为止 bool flag=true;//检测连续含&#123;ε&#125;的Yj for(int i=0;i&lt;right.size();i++)&#123; for(int j=0;j&lt;right[i].size()&amp;&amp;(Vn.count(right[i][j])&gt;0)&amp;&amp;flag;j++)&#123; //FIRST(Yj) set&lt;char&gt; temp1=first.at(right[i][j]); //i 若Y0∈Vn 则把FIRST(Y0)\&#123;ε&#125;元素加入FIRST(X)中 if(j==0)&#123; //\&#123;ε&#125; if(temp1.count(' ')&gt;0)&#123; temp1.erase(' '); &#125; //Y0不含&#123;ε&#125; else&#123; flag=false; &#125; //FIRST(Y0)\&#123;ε&#125; temp[k].insert(temp1.begin(),temp1.end()); &#125; /* ii 若Y1、Y2、……Y i-1 ∈Vn(2≤i ≤k) 且ε ∈FIRST(Y j) (1≤j ≤i-1) 则把FIRST(Yi )\&#123;ε&#125;元素加入FIRST(x)中 */ else if(j&lt;right[i].size()-1)&#123; //Y0...Yj-1含&#123;ε&#125; if(temp1.count(' ')&gt;0)&#123; temp1.erase(' '); &#125; //Yj不含&#123;ε&#125; else&#123; flag=false; &#125; //FIRST(Yj)\&#123;ε&#125; temp[k].insert(temp1.begin(),temp1.end()); &#125; /* iii 若Y0、Y1、……Yk ∈Vn且ε ∈FIRST(Yj)(0≤j ≤k) 则把ε元素加入FIRST(x)中 */ else&#123; temp[k].insert(' '); &#125; &#125; &#125; if(first.at(*left.c_str()).size()==0)&#123; first.at(*left.c_str())=temp[k]; &#125; else first.at(*left.c_str()).insert(temp[k].begin(),temp[k].end()); //跳出条件 if(k==first.size()-1)&#123; int cnt=0; //求和，观察first集有无增大 for(int kk=0;kk&lt;=k;kk++)&#123; cnt+=temp[kk].size(); &#125; //和上一次大小一样，循环终止 if(cnt==first_size) break; //重新循环 else&#123; k=0; it=rule.begin(); first_size=cnt; &#125; &#125; &#125;&#125; 自动构造follow集在构造完first集之后，下一步便可进入到follow集的构造。当然顺序不是我规定的，但是follow集必须在first集构造完后构造，因为其算法描述是基于first集所定义的。follow集的定义如下： $$follow(A)= \lbrace a| S=^*&gt;αAaδ,且a∈V_t,α,δ∈V^* \rbrace \big(若S=^*&gt;αA,则 \sharp∈follow(A)\big)$$ 当然，也存在构造follow集的成熟算法，算法描述为： i. 置FIRST(α)={ }ii. FIRST(X1)\ {ε}加入FIRST(α)iii. 若ε ∈ FIRST(X1),则FIRST(X2)\ {ε}加入FIRST(α)&emsp;&nbsp;若ε ∈ FIRST(X1)且ε ∈ FIRST(X2),则FIRST(X3)\ {ε}加入FIRST(α) ……..以此类推&emsp;&nbsp;若ε ∈ FIRST(Xi) 1≤ i ≤n 则ε ∈ FIRST(α) 在定义和算法都描述清晰之后，下一步需要把算法细化为代码实现。follow集的实现与first集的实现大同小异，代码如下，其中各个步骤都标有详细的注释，分别对应上述算法中的各个步骤：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void make_follow()&#123; //初始化follow集 for(set&lt;char&gt;::iterator it = Vn.begin();it!=Vn.end();it++)&#123; set&lt;char&gt;t; //令#∈FOLLOW(S) S为文法开始符号 if(*it==start) t.insert('#'); follow.insert(make_pair(*it,t)); &#125; //遍历规则rule //2.对A→ αBβ,且β ≠ε, 则将 FIRST(β)\&#123;ε&#125;加入FOLLOW(B)中 for(map&lt;string,vector&lt;string&gt;&gt;::iterator it=rule.begin();it!=rule.end();it++)&#123; //left -&gt; right vector&lt;string&gt; right=it-&gt;second; string left=it-&gt;first; //对每个left遍历 for(int i=0;i&lt;right.size();i++)&#123; //对left的每一个规则遍历 for(int j=0;j&lt;right[i].size();j++)&#123; //找到B所在：right[i][j] if(Vn.count(right[i][j])!=0)&#123; set&lt;char&gt; tt; //β属于Vt if(Vt.count(right[i][j+1])!=0)&#123; tt.insert(right[i][j+1]); follow.at(right[i][j]).insert(tt.begin(),tt.end()); &#125; //β属于Vn,FIRST(β)\&#123;ε&#125;加入FOLLOW(B)中 if(Vn.count(right[i][j+1])!=0)&#123; tt=first.at(right[i][j+1]); tt.erase(' '); follow.at(right[i][j]).insert(tt.begin(),tt.end()); &#125; &#125;//找到B所在：right[i][j] &#125;//对left的每一个规则遍历 &#125;//对每个left遍历 &#125;//遍历规则rule // 3.反复, 直至每一个FOLLOW(A)不再增大 // 对A→ αB或A→ αBβ(且ε ∈ FIRST(β)) // 则FOLLOW(A)中的全部元素加入FOLLOW(B) int k=0; int follow_size=0;//记录follow集的大小 for(map&lt;string,vector&lt;string&gt;&gt;::iterator it=rule.begin();;it++,k++)&#123; //left -&gt; right vector&lt;string&gt; right=it-&gt;second; string left=it-&gt;first; //对每个left遍历(一个left对应多个规则) for(int i=0;i&lt;right.size();i++)&#123; //对left的每一个规则遍历（一个规则对应多个字符） for(int j=0;j&lt;right[i].size();j++)&#123; //找到B所在：right[i][j] if(Vn.count(right[i][j])!=0)&#123; set&lt;char&gt; tt; //到规则的最后一个字符 if(j==right[i].size()-1)&#123; //最后一个字符是Vn，即A→αB，则FOLLOW(A)中的全部元素加入FOLLOW(B) tt=follow.at(*left.c_str()); follow.at(right[i][j]).insert(tt.begin(),tt.end()); &#125; //没到最后一个,即A→ αBβ(且ε∈FIRST(β)) 这种情况 else&#123; bool flag=true; //检索ε∈FIRST(β)是否成立 for(int jj=j+1;jj&lt;right[i].size()&amp;&amp;flag;jj++)&#123; //right[i][jj]是Vn且包含ε if(Vn.count(right[i][jj])!=0&amp;&amp;first.at(right[i][jj]).count(' ')!=0)&#123; continue; &#125; //right[i][jj]不是Vn或不包含ε else&#123; flag=false; &#125; &#125; //A→ αBβ(且ε∈FIRST(β))情况满足 if(flag)&#123; tt=follow.at(*left.c_str()); follow.at(right[i][j]).insert(tt.begin(),tt.end()); &#125; &#125; &#125;//找到B所在：right[i][j] &#125;//对left的每一个规则遍历 &#125;//对每个left遍历 //跳出条件 if(k==follow.size()-1)&#123; int cnt=0; for(map&lt;char,set&lt;char&gt;&gt;::iterator it1=follow.begin();it1!=follow.end();it1++)&#123; cnt+=it1-&gt;second.size(); &#125; //和上一次大小一样，循环终止 if(cnt==follow_size) break; //重新循环 else&#123; k=0; it=rule.begin(); follow_size=cnt; &#125; &#125;//跳出条件 &#125;&#125; 自动生成LL(1)分析表在first集和follow集都构造好之后，我们的前期准备工作已经进入到了最后阶段现在我们需要做的就是：根据first集和follow集来构造LL(1)分析表分析表的横坐标由终结符Vt构成，纵轴由非终结符Vn构成，坐标点的内容为对横纵坐标组合所采取的产生式动作。 由每一个产生式A→α1|α2|...|αn确定M[A,a]矩阵，a∈Vt，分析表M的定义如下： i. 任何a∈FIRST(αi),置M[A, a]=“pop,push(αi′)”,α′为α倒置 或将A→αi 规则填入M[A, a]ii. 若ε ∈ FIRST(αi),则对于任一个b∈FOLLOW(A),b∈Vt或#,置M[A, b]=“pop”或将A → ε规则填入M[A,b],此时b不属于FIRST(A)iii. 其它空白为出错 根据分析表的算法描述，可以编写出如下的代码，其中各个步骤都标有详细的注释，分别对应上述算法中的各个步骤：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void make_table()&#123; string action; //纵轴遍历Vn for(set&lt;char&gt;::iterator it1=Vn.begin();it1!=Vn.end();it1++)&#123; //横轴遍历Vt for(set&lt;char&gt;::iterator it2=Vt.begin();it2!=Vt.end();it2++)&#123; //结构体t（vn，vt）来记录坐标 point t; t.vn=*it1; t.vt=*it2; action=""; //如果it2是it1的first集元素:it2∈first(it1) if(first.at(t.vn).count(t.vt)!=0)&#123; //本应有一步动作：查询it2是it1哪一个规则的first集元素 string v= &amp;t.vn;//将it1转化为string类型 vector&lt;string&gt; Trule; Trule=rule.at(v.substr(0,1)); //剔除空产生式 int T=0; for(vector&lt;string&gt;::iterator it=Trule.begin();T&lt;Trule.size();it++,T++)&#123; if(*it==" ") Trule.erase(it); &#125; if(Trule.size()&gt;1)&#123; for(int ii=0;ii&lt;Trule.size();ii++)&#123; //空动作不管 if(Trule[ii]==" ") continue; //产生式的第一个即为vt，则必定为其first集 if(Trule[ii].find(t.vt)!=string::npos)&#123; action=Trule[ii]; break; &#125; &#125; &#125; else action = rule.at(v.substr(0,1))[0];//直接拿第一个规则，因为第二个规则即末尾规则肯定为it1-&gt;ε table.insert(make_pair(t, action)); &#125; //如果it2是it1的follow集元素:it2∈follow(it1),且若ε ∈ FIRST(it1) else if(first.at(t.vn).count(' ')!=0&amp;&amp;follow.at(t.vn).count(t.vt)!=0)&#123; action="pop"; table.insert(make_pair(t, action)); &#125; //对应分析表中的空白，即出错 else&#123; action="-1"; table.insert(make_pair(t, action)); &#125; &#125;//横轴遍历Vt //纵轴添加一个‘#’ point t1; t1.vn=*it1; t1.vt='#'; //添加条件：Vn-&gt;ε 且 ‘#’ ∈ follow(Vn) if(first.at(t1.vn).count(' ')!=0&amp;&amp;follow.at(t1.vn).count(t1.vt)!=0)&#123; action="pop"; table.insert(make_pair(t1, action)); &#125; //对应分析表中的空白，即出错 else&#123; action="-1"; table.insert(make_pair(t1, action)); &#125; &#125;//纵轴遍历Vn&#125; 代码中的action变量记录各种情况下应该采取的动作，即M[A,a]此外，对于空白，算法的描述为错误，代码这里将空白描述为action=‘-1’来代表出错。 到此，我们的first集、follow集和分析表已经全部构造完毕！ 构造分析栈准备工作全部完成之后，接下来便是构造分析栈来对输入二元组进行语法分析。分析的算法流程描述如下： 其中start为文法开始符号 测试选用两组用例包含两错两对，测试结果如下： 正确样例对于i=i+i，编译结果为：对于i=i*i/i，编译结果为： 错误样例对于i=i+-，编译结果为：对于i=i*i/)，编译结果为：可以看到，语法分析器可以正确实现其功能！ 优点 通过文件输入规则，自动纳入规则集 自动构造first集 自动构造follow集 自动构造LL(1)分析表 通过文件输入二元组，自动输出判别结果 总结对于这种具有多个复杂存储结构的实验，一定要在事先理清楚各个变量的数据结构的意义，否则很容易陷入迷惑。此外在c++中需要尽量避免char类型和string类型的混合使用，尽管string提供了c_str方法，但其返回值为char*，在循环时很容易造成指针错误，所以要谨慎使用！]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——递归下降语法分析器]]></title>
    <url>%2F2019%2F05%2F01%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实验项目完成以下描述赋值语句的LL(1)文法的递归下降分析程序123456789S→V=EE→TE′E′→ATE′|εT→FT′T′→MFT′|εF→ (E)|iA→+|-M→*|/V→i 设计说明终结符号i为用户定义的简单变量，即标识符的定义 设计要求（1）输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果，输出为输入串是否为该文法定义的算术表达式的判断结果；（2）递归下降分析程序应能发现简单的语法错误；（3）设计两个测试用例（尽可能完备，正确和出错），并给出测试结果 设计思路接收输入词法分析器输出文件由设计要求中的（1）可知，语法分析器所能接受的输入为词法分析器所输出的二元组首先我们来回顾一下词法分析器所输出的二元组的格式：可以看到，语句i=i+i)对应的词法分析输出二元组格式为：&lt;number,token&gt;的格式 number：编码数字token：符号/字符串 显然，我们可以通过一个结构体来接受词法分析器所输入的二元组！ 数据存储结构我构造的结构体如下：12345//记录词法分析器生成的二元组typedef struct &#123; int num; string token;&#125;two; 考虑到语句长度总是变化的，所以为了提高程序的鲁棒性，总的数据结构应定义为可变数组：12//记录全部的二元组vector&lt;two&gt; text; 到此，数据储存结构的准备工作1已全部完成。 构造执行函数根据递归下降分析的思想，我们首先需要对所有非终结符对应的产生式构造执行函数。再者，根据设计要求，我们在进行字符匹配时仅使用编码two-&gt;num进行匹配即可 编码映射在本题中所使用到的主要编码如下： 字符 编码 # -1 id 10 = 18 + 19 - 21 * 23 / 24 ( 27 ) 28 S()对产生式：S→V=E，可以得到如下的递归调用流程。 由词法分析器的编码可知，match（18）中的18代表字符= E()对产生式：E→TE′，可以得到如下的递归调用流程。 E’()对产生式：`E′→ATE′|ε，可以得到如下的递归调用流程。 由于产生式包含空动作E′→ε，所以在程序执行时需要判断是否读到E’的follow集元素，其中编码28代表字符)，编码-1代表字符#。 T()对产生式：T→FT′，可以得到如下的递归调用流程。 T’()对产生式：T′→MFT′|ε，可以得到如下的递归调用流程。 由于产生式包含空动作T′→ε，所以在程序执行时需要判断是否读到E’的follow集元素，其中编码19代表字符+，编码21代表字符-，编码28代表字符)，编码-1代表字符#。 F()对产生式：F→ (E)|i，可以得到如下的递归调用流程： 10代表用户定义标识符，27代表字符（，28代表字符） A()对产生式：A→+|-，可以得到如下的递归调用流程： 19代表字符+，21代表字符- M()对产生式：M→*|/，可以得到如下的递归调用流程： 23代表字符*，24代表字符/ V()对产生式：V→i，可以得到如下的递归调用流程： 10代表用户定义标识符 测试正确用例对于语句：1i = i + i 编译结果为： 对于语句：1i = i * (i/i) 编译结果为： 错误用例对于语句：1i = i + i ） 编译结果为： 对于语句：1i = i + - 编译结果为： 至此，该递归下降语法分析器已全部符合题目要求]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——语法分析G[]]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90G-%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目描述本次选做题需要实现一个简单的语法分析器，其文法描述如下： &lt;程序&gt;→begin &lt;语句&gt; end &lt;语句&gt;→&lt;赋值语句&gt;│&lt;条件语句&gt; &lt;赋值语句&gt;→&lt;变量&gt;:=&lt;表达式&gt; &lt;条件语句&gt;→if &lt;表达式&gt; then &lt;语句&gt; &lt;表达式&gt;→&lt;表达式&gt;+&lt;变量&gt;│&lt;变量&gt; &lt;变量&gt;→i 消除左递归一目了然就可以看到，产生式：&lt;表达式&gt;→&lt;表达式&gt;+&lt;变量&gt;│&lt;变量&gt;存在左递归。所以第一步要做的是消除左递归，消除结果为： &lt;表达式&gt;→&lt;变量&gt;&lt;表达式1&gt; &lt;表达式1&gt;→+&lt;变量&gt;&lt;表达式1&gt;|ε 到此，文法中的左递归已经完全消除，且满足LL(1)文法。 重命名为了便于编程，下面对文法中的非终结符用单词替换，如下： program 程序 statement 语句 assign 赋值语句 condition 条件语句 expression 表达式 expression_1 表达式1 variable 变量 程序实现 根据递归下降编程的思想，上述7个非终结符分别对应7个子函数，其实现的流程图分别如下： 其中： match(token)函数的作用是用token与当前扫描到的字符(串)进行匹配，匹配成功则返回true nextsym()函数的作用是使指针item滑动到下一个单词处 program statement assign condition expression expression_1这里需要说明的是，由于产生式&lt;表达式1&gt;→+&lt;变量&gt;&lt;表达式1&gt;|ε中含有&lt;表达式1&gt;→ε，故在匹配时如果没有match到其first集中的元素，则接下来需要去match其follow集中的元素，即“end”和“then”，若与follow集中的元素匹配成功，则指针item需要回滚。 variable 测试我选用了正确和错误的两组共四个测试用例对程序进行了测试，测试结果如下： 正确样例 错误样例 可以看到，程序能够成功识别该文法的语言并给出正确的反馈信息！]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——文件名识别]]></title>
    <url>%2F2019%2F04%2F11%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%90%8D%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[题目思考本次选做题是制作一个文件名的识别程序，其可以识别诸如xx:xx.xx之类的文件名，具体题目要求如下：某操作系统下合法的文件名规则为：device:name.extention,其中第一部分（device:)和第三部分（.extention)可缺省，若device、name和extention都是由字母组成，长度不限，但至少一位。 显然这样的题目要求与词法分析器和无符号数识别类似，按照之前的词法分析器程序的编写思路，首先来构造程序的状态转换图。 状态转换图题目给出了文件名规则：device:name.extention，我们令d代表字母，则该规则可以转化为正则式表示为：d*:d+.d*，其中*和+分别代表0和1次及以上自重复。 从而可以得到如下的状态转换图： 其中：2状态的终结态代表device和extension均缺省的情况，4状态的终结态代表extension缺省的情况，6状态的终结态代表device缺省的情况。 数据流根据上述状态转换图，可以拟定初步的编程数据流图如下： 子程序实现显然，从数据流图中可以看到，功能实现的核心在于函数：int next_state(int current_state,char temp)即根据现在状态以及下一个字符判断下一个状态，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int next_state(int current_state,char temp)&#123; int next=-1; switch (current_state) &#123; case 1:&#123; if(isalpha(temp))&#123; next=2; &#125; else&#123; next=-1; &#125; break; &#125; case 2:&#123; if(isalpha(temp))&#123; next=2; &#125; else if(temp=='.')&#123; next=5; &#125; else if(temp==':')&#123; next=3; &#125; else&#123; next=-1; &#125; break; &#125; case 3:&#123; if(isalpha(temp))&#123; next=4; &#125; else&#123; next=-1; &#125; break; &#125; case 4:&#123; if(isalpha(temp))&#123; next=4; &#125; else if(temp=='.')&#123; next=5; &#125; else&#123; next=-1; &#125; break; &#125; case 5:&#123; if(isalpha(temp))&#123; next=6; &#125; else&#123; next=-1; &#125; break; &#125; case 6:&#123; if(isalpha(temp))&#123; next=6; &#125; else&#123; next=-1; &#125; break; &#125; &#125; return next;&#125; 代码测试在程序完备之后，我对程序选择了如下测试样例进行测试： 可以看到，凡是name缺省的错误文件命名均可以被识别。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git——日常使用]]></title>
    <url>%2F2019%2F04%2F06%2Fgit%E2%80%94%E2%80%94%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天好不容易写完了操作系统，刚想行云流水一波上传到GitHub，结果在最后一步pull的时候报错，给我慌了十分钟的一批，解决完决定记录一下有关的操作流程。 用网页传代码或者文件着实不像一个计算机系学生应有的水准，下面来列支一下每次上传文件的流程。 git init git add . git commit -m &quot;xxx&quot; git push -u origin master 对，没有问题，操作仅仅就这么几步而已，那么我今天遇到的error是什么呢？ 上一次手残把project2的commit写错了，想改发现不能直接在网页端改，所以还是需要依靠命令来修改。 修改的步骤如下： git log：罗列commit记录，每一次commit都对应一个记录编码 git reset --hard xxx：将HEAD强行指向xxx所对应的commit记录 git push -u origin master -f：更新仓库，这一步至关重要，如果缺少了这一步就会导致本地与GitHub端的HEAD指向不匹配，从而报错 至此，平时所需要的的操作就叙述结束了，当然git命令还不止这些，下面这些命令也有可能被用到： git clone https://仓库地址：下载文件到本地 git remote add origin https:// https://github.com/hnjia00/OS2019：这条命令可以与仓库建立联系]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——进程同步]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[本次实验全部基于Ubuntu 16.04完成代码托管于GitHub: https://github.com/hnjia00/OS2019 本次试验的内容核心在于对于信号量的理解和利用，通过信号量的合理配置从而使进程和线程的运行合乎逻辑。 实验目的 系统调用的进一步理解。 进程上下文切换。 同步的方法。 Q1.通过fork的方式，产生4个进程P1,P2,P3,P4，每个进程打印输出自己的名字，例如P1输出“I am the process P1”。要求P1最先执行，P2、P3互斥执行，P4最后执行。通过多次测试验证实现是否正确。 A1.首先需要理清楚进程的逻辑关系，为了使这四个进程满足题目要求的执行顺序，我在程序里使用了三组信号量，分别为sem1，sem2，sem3。 需要注明的是： 为了满足p1最先执行，p2和p3在其后等待，sem1设置了两个信号量，即sem1 = [0,0]。 p2等待p1的信号量sem1[0]，p3等待p1的信号量sem1[1]从而达到在p1之后执行的要求。此外，为了满足p2和p3互斥执行，还定义了一个互斥信号量sem2 = 1，这样p2和p3在等待sem1之后还需要等待sem2以实现互斥执行的要求。 为了满足p4最后执行，即满足p4在p2和p3之后执行，sem3设置了两个信号量，即sem3 = [0,0]。其需要等待p2结束后产生的信号量sem3[0]，以及等待p3结束后产生的信号量sem3[1]，从而实现最后执行的要求，整体逻辑图如下： 在逻辑图实现之后，需要考虑进程的创建关系。 虽然一个父进程能创建若干个子进程，但是一个子进程只能对应一个父进程，也就是说进程的创建不能以信号量逻辑图为基础，因为P4不能对应两个父进程P2和P3。 所以在创建中各个进程所对应的父子关系与信号量逻辑图略有不同。 主程序代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int main(int argc, char *argv[])&#123; pid_t pid1, pid2, pid3; int sem1, sem2, sem3; sem1 = semget(1000, 2, 0666 | IPC_CREAT);//[0,0]，保证p1最先 sem2 = semget(1001, 1, 0666 | IPC_CREAT);//[1],保证p2、p3互斥 sem3 = semget(1002, 2, 0666 | IPC_CREAT);//[0,0]，保证p4最后 //信号量赋值 ushort init_arry[2] = &#123;0, 0&#125;; setSemValues(sem1, init_arry); setSemValue(sem2, 0, 1); setSemValues(sem3, init_arry); pid1 = fork(); if (pid1 &gt; 0) &#123; pid2 = fork(); //p1 if (pid2 &gt; 0) &#123; printf("P1:I am P1\n"); printf("pid,ppid:%d,%d\n",getpid(),getppid() ); signal(sem1,0); signal(sem1,1); sleep(1); &#125; //p4 if(pid2 == 0) &#123; wait(sem3, 0); wait(sem3, 1); printf("P4:I am P4\n"); printf("pid,ppid:%d,%d\n",getpid(),getppid() ); &#125; &#125; if (pid1 == 0) &#123; pid3 = fork(); //p2 if (pid3 &gt; 0) &#123; wait(sem1, 0); wait(sem2, 0); printf("P2:I am P2\n"); printf("pid,ppid:%d,%d\n",getpid(),getppid() ); signal(sem2, 0); signal(sem3, 0); sleep(1); &#125; //p3 if (pid3 == 0) &#123; wait(sem1, 1); wait(sem2, 0); printf("P3:I am P3\n" ); printf("pid,ppid:%d,%d\n",getpid(),getppid() ); signal(sem2, 0); signal(sem3, 1); &#125; &#125; return 0;&#125; 在第一题中，信号量的定义部分我使用了semget()函数，虽然其常用于定义一个单信号量，但我也用到了其定义信号量集的功能（如sem1和sem3），函数注释如下：12345678int semget(key_t key, int num_sems, int sem_flags):功能描述： 创建一个新信号量或取得一个已有信号量参数说明： key:整数值,不相关的进程可以通过它访问一个信号量,它代表程序可能要使用的某个资源 num_sems:指定需要的信号量数目 sem_flags:一组标志,当想要当信号量不存在时创建一个新的信号量,可以和值IPC_CREAT做按位或操作 0666:创建了一个权限为666的信号量,每个人可读和可写 此外，代码中所用到的setSemValues(),setSemValue(),wait(),signal()的具体实现均已托管至GitHub，有兴趣可以进一步一探究竟！ 代码的执行结果如图，可以看到，多次执行均能保证进程次序。 Q2.火车票余票数ticketCount 初始值为1000，有一个售票线程，一个退票线程，各循环执行多次。添加同步机制，使得结果始终正确。要求多次测试添加同步机制前后的实验效果。(说明：为了更容易产生并发错误，可以在适当的位置增加一些pthread_yield()，放弃CPU，并强制线程频繁切换。) A2.从题目可以体会到，这是一个典型的生产者消费者问题，售票线程为消费者，退票线程为生产者，临界资源为火车票余票数ticketCount。 初步分析进一步分析可以得知： 退票线程能够访问临界资源的条件为：火车票余量空间满足退票数目。 售票线程能够访问临界资源的条件为：火车票余量大于0. 有了以上思路后，可以通过设置两个信号量来实现上述功能，两个信号量的介绍如下： empty = 0：记录剩余空间 full = 1000：记录剩余票数 初步实现代码的实现逻辑如下： 为了保证代码和逻辑的鲁棒性，需要在关键代码部分增加pthread_yield()函数来测试代码，对pthread_yield()函数的解释为： pthread_yield() causes the calling thread to relinquish the CPU.The thread is placed at the end of the run queue for its static priority and another thread is scheduled to run. 即pthread_yield（）使调用线程放弃CPU。该线程放在运行队列的末尾，以获得其静态优先级并计划运行另一个线程。 售票线程、退票线程的实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243int ticketCount=1000;//剩余票数int temp;sem_t *empty = NULL;//记录剩余空间sem_t *full = NULL;//记录剩余票数int N_sell;//售票数int N_return;//退票数int pthread_yield(void);//售票void *Psell()&#123; int i=0; for(;i&lt;N_sell;i++)&#123; sem_wait(full); //售票进程关键代码 temp=ticketCount; pthread_yield(); temp=temp-1; pthread_yield(); ticketCount=temp; // printf("[Sell - %d]\n",i+1); sem_post(empty); &#125; printf("[Sell end: total sell:%d]\n",i);&#125;//退票进程void *Preturn()&#123; int i=0; for(;i&lt;N_return;i++)&#123; sem_wait(empty); //退票进程关键代码 temp=ticketCount; pthread_yield(); temp=temp+1; pthread_yield(); ticketCount=temp; // printf("&#123;Return + %d&#125;\n",i+1); sem_post(full); &#125; printf("&#123;Return end: total return:%d&#125;\n",i);&#125; 初步测试对于售票数=30，退票数=7的测试，执行结果如图所示，可以看到在模拟售票30张退票7张时，程序的执行结果正确： 在小规模测试上获得正确结果之后，接下来我将测试级扩大到了10w级别，对于售票数=100000，退票数=99000的测试，程序的结果如下：竟然得到了错误的结果！ 出错分析为了探究出错原因，我将pthread_yield()函数去掉重新执行了代码，这次程序的出了正确的结果： 纠其原因，尽管使用了生产消费者所常用的配套信号量，但仍然不足以克服pthread_yield函数所带来的线程切换。也就是说，尽管通过sem_wait(empty)能控制退票线程Preturn()访问临界区的的入口条件，但即使Preturn()进入了临界区，其也有可能被pthread_yield所强制切换到Psell()售票线程，从而导致临界区被两个线程同时访问，以至于临界资源ticketCount被错误修改！ 所以，为了达到保护临界资源的目的，需要设置互斥信号量！从而保证任意适合只能有一个线程对临界资源进行访问修改。 二次修改修改后的线程逻辑如下： 进而修改线程代码为：123456789101112131415161718192021222324252627282930313233343536373839404142sem_t *mutex = NULL;//互斥信号量//售票void *Psell()&#123; int i=0; for(;i&lt;N_sell;i++)&#123; sem_wait(full); //等待互斥信号 sem_wait(mutex); //售票进程关键代码 temp=ticketCount; //pthread_yield(); temp=temp-1; //pthread_yield(); ticketCount=temp; printf("[Sell - %d]\n",i+1); sem_post(empty); //释放互斥信号 sem_post(mutex); &#125; printf("[Sell end: total sell:%d]\n",i);&#125;//退票进程void *Preturn()&#123; int i=0; for(;i&lt;N_return;i++)&#123; sem_wait(empty); //等待互斥信号 sem_wait(mutex); //退票进程关键代码 temp=ticketCount; pthread_yield(); temp=temp+1; pthread_yield(); ticketCount=temp; printf("&#123;Return + %d&#125;\n",i+1); sem_post(full); //释放互斥信号 sem_post(mutex); &#125; printf("&#123;Return end: total return:%d&#125;\n",i);&#125; 正确执行再次执行上次的测试用例，这次的执行结果为0，即售票-10w,退票+9.9w,初始+0.1w=0，完全正确！ Q3.一个生产者一个消费者线程同步。设置一个线程共享的缓冲区， char buf[10]。一个线程不断从键盘输入字符到buf,一个线程不断的把buf的内容输出到显示器。要求输出的和输入的字符和顺序完全一致。（在输出线程中，每次输出睡眠一秒钟，然后以不同的速度输入测试输出是否正确）。要求多次测试添加同步机制前后的实验效果。 A3.这是一个典型的生产者-消费者问题，思路与第二题相仿，需要两个信号量来辅助实现，信号量的使用情况如下： empty = 5：记录剩余空间 full = 0：记录使用空间 要说明的一点是，为了便于测试debug和结果演示，我将char buf[10]修改为了int buf[5]，一来是缩小规模可以更直观看到演示结果，二来使用int型数组也可以防止回车符的乱入。 由于逻辑与上一题相仿，仅仅是取消了互斥mutex，所以这里不做赘述。 代码实现读入和输出线程的实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041#define N 5int buf[N];//信号量sem_t *empty=NULL,*full=NULL;//T1、T2分别代表输入输出的测试规模int T1=15,T2=15;//in：输入指针，out：输出指针int in=0,out=0;//输入线程void *producer() &#123; int nextp; while(T1--)&#123; sem_wait(empty); printf("%s\n","input: "); scanf("%d",&amp;nextp); buf[in]=nextp; in = (in+1)%N; sem_post(full); &#125; printf("%s\n", "[input]:over"); return NULL;&#125;//输出线程void *consumer() &#123; int nextc; while(T2--)&#123; sem_wait(full); nextc=buf[out]; sleep(1); printf("output:%d\n", nextc); out = (out+1)%N; sem_post(empty); &#125; printf("%s\n", "[output]:over"); return NULL;&#125;empty = sem_open("empty",O_CREAT,0666,5);//记录剩余空间full = sem_open("full",O_CREAT,0666,0);//记录使用空间 测试用例123输入规模：T1=15输出规模：T2=15测试数据：1、2、3...9、0、9、8、7、6、5 正常速度输入对于正常的输入速度，程序的执行结果如下。可以看到，每一个输入下都匹配着正确的输出结果。 快速输入对于快速的输入速度，程序的执行结果如下。可以看到尽管输入提示语句input:看起来有一些“不合位置”，但在两个信号量empty和full的合理使用下，输入输出线程的进入条件会严格受控于缓冲区的剩余空间和已使用空间，十五个数字字符1～0，9～5全被成功输入并得以按顺序依次输出。 去同步机制输入为了测试信号量的作用，这次测试将信号量去掉，重新进行快速输入，结果如下。可以看到对于块长为5的缓冲区，在输入线程的指针in超过输出线程指针out的移动位置后，原先已经被输入但还未来得及输出的字符会被新的输入所覆盖，从而造成输出丢失，进而导致输出持续混乱 Q4.a）通过实验测试，验证共享内存的代码中，receiver能否正确读出sender发送的字符串？如果把其中互斥的代码删除，观察实验结果有何不同？如果在发送和接收进程中打印输出共享内存地址，他们是否相同，为什么？b)有名管道和无名管道通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？c）消息通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？ A4.a) 共享内存功能测试同时开启两个终端，分别启动receiver进程和sender进程，执行操作如下，在sender端键入字符串，且sender端以空格作为一段字符串的分隔标志，可以在receiver段得到sender端所输入的的字符串： 删除互斥在删去信号量后，在接收端会发生输出混乱，具体表现如下：receiver端不会等待sender端的输入情况，其会不加限制的重复输出共享内存中已有的内容： 重新开启进程后，上次程序所写在共享内存区内的字符串仍然会被重复输出： 观察地址重新调回互斥，在sender进程和receiver进程分别添加语句12printf("\n[Sender] address:%p\n", shm_ptr);printf("\n[Receiver] address:%p\n", shm_ptr); 实现打印共享内存的地址，可以观测到如下输出结果，两个进程的共享内存地址并不相同。其原因为：sender进程和receiver进程实现了对共享内存shm_ptr的访问，shm_ptr的物理地址有且唯一，但在程序进程中所查询到的地址并不是shm_ptr的物理地址，而是shm_ptr向进程所映射的虚拟地址，所以这就造成了同一块物理地址在不同的进程中的打印值不同的结果。即：共享内存在每个进程里的映射地址是不同的 b) 管道通信无名管道同步无名管道的代码执行结果如图。无名管道通过定义fd[2]文件描述符数组来实现消息同步：fd[0]描述只读,fd[1]描述只写，从而实现读写同步。但值得注意的是，无名管道是半双工的，就是对于一个管道来讲，只能读，或者写。 无名管道只能在相关的，有共同祖先的进程间使用（即一般用户父子进程），而多进程用同一管道通信容易造成交叉读写的问题。 阻塞在执行open,write,read等操作时会发生阻塞现象。因为管道和文件一样，文件read函数以O_RDONLY方式打开也会阻塞，但是文件数据在本地，读取非常快，感觉不到阻塞，但是管道以O_RDONLY方式打开，会阻塞进程，read()函数会等待管道另一端写入数据，直到另一端关闭文件描述符。更具体的，读写进程的阻塞可归类为下列几类情况： 读进程 写进程 管道无数据 管道有数据 阻塞 return 0 返回数据 阻塞 阻塞等待 读取数据 阻塞 收到SIGPIPE信号，write返回-1 阻塞 写入数据 满则阻塞等待 有名管道同步有名管道的代码执行结果如图。有名管道分别定义了两个进程来实现消息同步：进程fifo_send实现了创建管道、向管道只写数据的功能。进程fifo_rcv实现了查阅管道，从管道中只读数据的功能。通过两个进程对同一管道的只读只写从而实现同步机制。 阻塞有名管道的读写阻塞情况同无名管道。此外，有名管道比无名管道还多一种阻塞情况：通信双方一方不存在则阻塞，如下图所示。 c) 消息队列同步消息队列的代码执行结果如图。消息队列通过server端和client端的配合操作实现消息同步：进程client中创建了两个进程，其中父进程用于接受键盘键入以及发送数据，子进程用于接收server的返回数据并实现输出。进程server中等待接收client端发送的数据，当收到信息后，打印接收到的数据，并原样的返回client端。以上流程通过两个struct msgbuf类型结构体sndBuf,rcvBuf来辅助实现。 阻塞阻塞情况与管道类似，在队列中没有消息时读进程会阻塞，在队列中数据已满时写进程会阻塞。 Q5.阅读Pintos操作系统，找到并阅读进程上下文切换的代码，说明实现的保存和恢复的上下文内容以及进程切换的工作流程。 A5.代码阅读有关关上下文切换的代码位于/threads/switch.h和/threads/switch.S中，这里首先介绍对两个代码的简略阅读。 switch.h头文件代码如下：汇编代码如下： 从CUR（正在运行的线程）切换到NEXT，NEXT也必须运行switch_threads（），在NEXT的上下文中返回CUR。这个函数通过假设我们切换到的线程也在运行switch_threads（）来工作。因此，它所要做的就是在堆栈上保留一些寄存器，然后切换堆栈并恢复寄存器。作为切换堆栈的一部分，我们在CUR的线程结构中记录当前堆栈指针。 线程切换如果一个线程用完了它的时间片，thread_tick就会调用该函数intr_yield_on_return。但是，此时不会产生下一个线程。相反，它修改一个标志，让中断处理程序知道，在从中断返回之前，它应该执行一个上下文切换到另一个线程。 于是，经过thread_tick和timer_interrupt回报，intr_handler将调用thread_yield，它将调用schedule。schedule选择要运行的下一个线程并调用一个函数switch_threads，在x86程序集中实现，带有两个参数:( cur指向thread 当前线程结构的指针，即被抢占next的指针）和（指向下一个thread结构的指针） 线程运行）。 所以，堆栈看起来像这样： 理解switch_threads的关键是要明白，如果切换到另一个线程，那么其他线程switch_threads在被抢占时也必须运行。实际上，一个自愿或非自愿地产生CPU的线程将始终具有类似于以下之一的堆栈： switch_threads后面的所隐含的内容是，要切换到另一个线程，只需要切换堆栈（因为每个线程都保证switch_threads在被抢占的位置运行），我们只需更改esp值就可以做到这一点。 在调用之后switch_threads，堆栈的底部将如下所示： switch_threads堆栈帧（0x0C00）的起始地址是任意的，没有深刻的意义。但是，显示的所有其他值将与从中switch_threads开始的堆栈帧0x0C00一致。 首先，switch_threads需要保存一些寄存器（这是x86架构所要求的）：1234pushl ％ebx pushl ％ebp pushl ％esi pushl ％edi 堆栈结构如下： 接下来，switch.h将SWITCH_CUR和SWITCH_NEXT定义为堆栈帧中的cur和next的偏移量（20和24）。在x86中，表达式SWITCH_CUR(%esp)变为20(%esp)，转换为内存地址esp+20cur。换句话说，这给了我们当前thread（）的地址。类似的，SWITCH_NEXT(%esp)提供了next线程的地址 。 下面一段汇编代码保存当前线程的堆栈指针，并设置esp为指向要运行的下一个线程的（先前保存的）堆栈指针。1234movl SWITCH_CUR （％esp ）， ％eax movl ％esp ， （％eax ，％edx ，1 ）movl SWITCH_NEXT （％esp ）， ％ecx movl （％ecx ，％edx ，1 ）， ％esp 在完成上述操作后，切换线程即完成，剩下的就是恢复之前推入堆栈的寄存器，然后返回switch_threads：12345popl ％edi popl ％esi popl ％ebp popl ％ebx ret 进程切换在理解清楚线程的切换机理后，进程切换也可以类比。 所谓进程切换，其只是线程切换和内核空间与用户空间之间切换的组合。基本上，当一个进程正在运行时，一个定时器中断将控制CPU回到内核，这将导致中断处理过程（最终导致调用thread_tick）。此时，如果我们抢占当前线程（及其关联的进程），我们将切换到不同的内核线程。如果此内核线程与进程关联，我们将切换回用户空间。 主要的区别是，切换到一个新的进程也将涉及调用process_activate从thread_schedule_tail（即运行功能之后switch_threads，但是从中断处理程序返回之前）。process_activate更新CPU的cr3寄存器以指向当前正在运行的进程的页面目录，并将值保存esp到TSS。 其中process_activate源码位于\userprog\process.c,TSS的源码位于\userprog\tss.c，如下所示： 参考文献【1】Linux共享内存实现机制的详解 :https://www.jb51.net/article/118285.htm【2】Linux 进程通信（无名管道）:https://www.cnblogs.com/zhanggaofeng/p/5829801.html【3】Linux进程间通信 – 管道(pipe):https://www.cnblogs.com/Jimmy1988/p/7553069.html【4】Linux进程间通信 – 消息队列:https://www.cnblogs.com/Jimmy1988/p/7699351.html【5】How does thread/process switching work in Pintos?:https://uchicago-cs.github.io/mpcs52030/switch.html]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译原理——无符号数识别]]></title>
    <url>%2F2019%2F04%2F03%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[实现思路无符号数的识别已经在课上做过详细的讲解，其主要实现思想可参考无符号数识别的状态转换图，这里不做赘述。 测试样例程序的测试用例及测试结果如下，可以看到，程序可以正确识别满足格式要求的无符号数，最终以要求格式整数E指数的形式输出。： 代码实现下面来简单列支程序子函数代码 辅助全局变量为了达到识别输入的无符号数的功能，首先需要预设几个全局变量，其变量名及解释如下：1234int w=0;//整数累加器（初值为0）int p=0;//指数累加器（初值为0）int n=0;//十进小数累加器（初值为0）int e=1;//十进指数的符号（初值为1， 遇负号为-1） 子函数：判断是否为无符号数无符号数以string类型变量接收，通过bool isnum(string num)函数来实现判别，即最终状态如果落在1、2、6则为无符号数，函数的实现如下：12345678910111213141516//判断是否为无符号数bool isnum(string num)&#123; int state = 0; int i=0; for(;i&lt;num.size();i++)&#123; char temp = num[i]; state = next_state(state, temp); if(state==-1) return false; &#125; //没有到达终态1、2、6 if(state==3||state==4||state==5) return false; return true;&#125; 子函数：获取下一状态在bool isnum(string num)函数中需要用到另一个辅助函数int next_state(int currentstate,char temp)来求取下一状态，其实现主要依托switch-case架构，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//获取下一个状态及中间量计算结果int next_state(int currentstate,char temp)&#123; int next=-1; switch (currentstate) &#123; case 0:&#123; if(isdigit(temp))&#123; n=0; p=0; e=1; w=(temp-'0'); next=1; &#125; else if(temp=='.')&#123; n=0; p=0; e=1; w=0; next=3; &#125; else next=-1; break; &#125; case 1:&#123; if(isdigit(temp))&#123; w=w*10+(temp-'0'); next=1; &#125; else if(temp=='.')&#123; next=2; &#125; else if(temp=='E'||temp=='e')&#123; next=4; &#125; else next=-1; break; &#125; case 2:&#123; if(isdigit(temp))&#123; w=w*10+(temp-'0'); n=n+1; next=2; &#125; else if(temp=='E'||temp=='e')&#123; next=4; &#125; else next=-1; break; &#125; case 3:&#123; if(isdigit(temp))&#123; n=n+1; w=w*10+(temp-'0'); next=2; &#125; else next=-1; break; &#125; case 4:&#123; if(isdigit(temp))&#123; p=p*10+(temp-'0'); next=6; &#125; else if(temp=='+')&#123; next=5; &#125; else if(temp=='-')&#123; e=-1; next=5; &#125; else next=-1; break; &#125; case 5:&#123; if(isdigit(temp))&#123; p=p*10+(temp-'0'); next=6; &#125; else next=-1; break; &#125; case 6:&#123; if(isdigit(temp))&#123; p=p*10+(temp-'0'); next=2; &#125; else next=-1; break; &#125; &#125; return next;&#125; 主函数至此，无符号数的识别功能全部实现，只需要在主函数中循环接受输入并判断即可。12345678910111213141516171819int main(int argc, const char * argv[]) &#123; while(1)&#123; string num; cout&lt;&lt;"input:"; cin&gt;&gt;num; if(isnum(num))&#123; cout&lt;&lt;"it is an unsigned number～\n"; if(e*p-n!=0&amp;&amp;w!=0) cout&lt;&lt;"the number is:"&lt;&lt;w&lt;&lt;"E"&lt;&lt;e*p-n&lt;&lt;endl&lt;&lt;endl; else cout&lt;&lt;"the number is:"&lt;&lt;w&lt;&lt;endl&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;"it isn't an unsigned number!"&lt;&lt;endl&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——初步]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[本次实验全部基于Ubuntu 16.04完成代码托管于GitHub：https://github.com/hnjia00/OS2019/tree/master/Code_Of_project1 系统调用实验Q1.阅读分别运行用API接口函数getpid()直接调用和汇编中断调用两种方式调用Linux操作系统的同一个系统调用getpid的程序: 请问getpid的系统调用号是多少？ Linux系统调用的中断向量号是多少？ A1.执行将两个文件分别命名为getpid_c.c和getpid_assembly.c，首先用gcc编译API接口调用程序，执行结果如下：可以看到程序分别输出了41580、41602、41612，其代表每次执行程序的进程识别码，且进程相互不同。其次用gcc编译汇编中断调用程序，其执行结果如下：程序的执行结果与API调用实现相同，可以实现输出进程的识别码。 系统调用号查阅有关博客，getpid的系统调用号分两个：在 32位系统下为 20，在 64位系统下为 39.本题的代码基于32位系统，所以程序中传入的系统调用号为 0x14，即 20. 中断向量号根据第二段汇编内嵌代码所提供的信息，其通过代码：INT 0x80 进入中断，所以Linux系统调用的中断向量号是 80H。 Q2.上机完成习题1.13 A2.linux系统调用的C函数形式为了实现打印输出“hello world”，这里选用系统调用函数write来实现，通过下面代码即可实现：123456#include &lt;stdio.h&gt;int main()&#123; write(1,"hello world!\n",14); return 0;&#125; 其中write的三个参数分别制定：输出方式、输出内容和输出长度。执行结果如下： 汇编代码通过C语言内嵌汇编的形式来打印“hello word”的方法如下：12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; char* msg = "Hello World!\n\r"; int len = 14; int result = 0; asm volatile("mov %2, %%edx;\n\r" /*传入参数：要显示的字符串长度*/ "mov %1, %%ecx;\n\r" /*传入参赛：文件描述符（stdout）*/ "mov $1, %%ebx;\n\r" /*传入参数：要显示的字符串*/ "mov $4, %%eax;\n\r" /*系统调用号：4 sys_write*/ "int $0x80" /*触发系统调用中断*/ :"=m"(result) :"m"(msg),"r"(len) /*输入部分：绑定字符串和字符串长度变量*/ :"%eax"); return 0;&#125; 程序的执行结果如下： Q3.阅读pintos操作系统源代码，画出系统调用实现的流程图. A3.由于并未实际操作过pintos系统，所以如何定位系统调用的区域或是执行流程是一个很大的问题。为此，我参考了Linux的系统调用流程，将Linux的系统调用思想转移到pintos系统上，下面是我的学习所得。 先拿Linux的系统调用read函数来举个例子，其实现流程如下： 在理解了Linux系统调用后，我尝试对pintos的项目源码进行了研读。Pintos系统调用的相关代码存储在：pintos\src\lib\user下的syscall.c、syscall.h和syscall-nr.h中。其中：syscall-nr.h用于存储系统调用号的声明，syscall.c和syscall.h则编写了系统调用函数的具体实现。还是继续拿read()函数来说明pintos的系统调用流程： 首先用户在用户程序中调用read函数。 接下来进入read函数的封装例程阶段，其对应syscall.c中的代码段： 在C库的read函数中，其返回了一个syscall3 (SYS_READ, fd, buffer, size);的指向，即系统调用处理程序。其中第一个参数SYS_READ即为read函数的系统调用号，该声明位于文件syscall-nr.h中： Syscall3函数的实现也位于syscall.c文件中，其代码如下： 从代码中可以看到，syscall3函数通过 INT $0x30 语句触发了系统的软中断。 承接syscall3的初始化函数位于src/userprog/syscall.c中，通过函数syscall_init调用执行intr_register_int来完成中断的初始化 接下来进入中断服务程序处理过程 中断服务处理程序位于src/threads/interrupt.c和src/threads/interrupt.h文件中，其中：interrupt.h定义了中断堆栈帧的各个寄存器以及中断程序的声明,通过syscall3的参数传入即可识别需要执行的功能： interrupt.c存储了中断服务程序的具体实现，中断的处理主要先依靠函数void intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,intr_handler_func *handler, const char *name)实现相关参数的初始化 进而通过调用函数：void intr_handler (struct intr_frame *frame)来实现：其函数的描述为： 处理所有中断，故障和异常。这个函数由汇编语言中断存根调用使用intr-stubs.S。 FRAME描述了中断和中断线程的寄存器。 通过中断程序的执行，从而得以调用系统调用服务例程。 所以，pintos的系统调用流程 应该为： 并发实验Q1.编译运行该程序（cpu.c），观察输出结果，说明程序功能。(编译命令： gcc -o cpu cpu.c –Wall)（执行命令：./cpu） A1.通过观察，可以得出程序的功能为：每隔一秒打印输入的参数或提示程序的正确输入格式。 Q2.再次按下面的运行并观察结果：执行命令：./cpu A &amp; ./cpu B &amp; ./cpu C &amp; ./cpu D &amp;程序cpu运行了几次？他们运行的顺序有何特点和规律？请结合操作系统的特征进行解释。 A2.观察程序可知，CPU的运行次数取决于while循环的执行次数，如果不强制终止程序，CPU将会一直运行下去。 程序的部分执行结果如下：从上图的执行结果中可以观察到：4个程序在每一轮都会轮流执行，而且执行的打印次序没有固定的顺序。这是因为：对于4个完全相同的程序而言，CPU的优先级是相同的，所以每一轮的执行顺序是随机的，没有特定的规律。 内存分配实验Q1.阅读并编译运行该程序(mem.c)，观察输出结果，说明程序功能。(命令： gcc -o mem mem.c –Wall) A1.程序的执行结果如图：程序首先打印指针p所指向的内存地址：0x19d2010及其对应的进程：41862其次程序每隔一秒打印指针p+1后的相对地址1、2、3… 及其对应的进程：41862 Q2.再次按下面的命令运行并观察结果。两个分别运行的程序分配的内存地址是否相同？是否共享同一块物理内存区域？为什么？命令：./mem &amp;; ./mem &amp; A2.调用两个进程同时执行程序mem.c，其结果如下：从上图可以看到，两个分别运行的程序分配的内存地址不同，两个指针分别指向内存：0x8a2010和0x2337010，因为指针指向的内存单元的地址不同，所以不共享同一块物理内存区域。 在尝试关闭ALSR地址空间随机化后再次运行程序，发现程序有变化： 所以两个分别运行的程序分配的内存地址本可以相同，但正是因为ALSR地址空间随机化后从而导致用户观测到的地址互不相同。 原因： Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存），而且更重要的是，用户程序可使用比实际物理内存更大的地址空间。 共享的问题Q1.阅读并编译运行该程序，观察输出结果，说明程序功能。（编译命令：gcc -o thread thread.c -Wall –pthread）（执行命令1：./thread 1000） A1.程序执行的输出结果如图：阅读代码可知，程序的功能为开启两个线程，同时执行子函数worker，实现对counter变量的loops*2次累加，最后打印counter的初值和累加结果。 Q2.尝试其他输入参数并执行，并总结执行结果的有何规律？你能尝试解释它吗？（例如执行命令2：./thread 100000）（或者其他参数。） A2.更改参数，程序执行的输出结果如图：从输出结果可以发现，counter的final值为输入参数的2倍，初始值恒为0.原因：虽然程序同时创建了两个线程执行worker函数，但两个线程均是对同一个counter变量进行相同次数的累加，所以最终结果总为loops的2倍，即输入参数argc的2倍。 参考文献使用库函数API和C代码中嵌入汇编代码两种方式使用同一个系统调用：https://blog.csdn.net/sunyeyi/article/details/44702575 linux系统调用号查询：https://blog.csdn.net/u012763794/article/details/78777938 Linux内存管理：https://www.cnblogs.com/ralap7/p/9184773.html]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——进程控制]]></title>
    <url>%2F2019%2F03%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[本次实验全部基于Ubuntu 16.04完成代码托管于GitHub: https://github.com/hnjia00/OS2019 最近的课程正在讲述进程有关的知识，老师说进程是面试的时候面试官最喜欢提问的话题，也是区分科班操作系统出身学生的一个标准，所以这部分内容和习题的实践性要远强于第一次。 Q1.打开一个vi进程。通过ps命令以及选择合适的参数，只显示名字为vi的进程。寻找vi进程的父进程，直到init进程为止。记录过程中所有进程的ID和父进程ID。将得到的进程树和由pstree命令的得到的进程树进行比较。 A1.第一题还是以基本操作为主，是一个按部就班的过程，下面就来逐步讲述。 打开vi进程只需在终端直接输入vi，执行结果如下： 接下来启动另一个terminal，通过命令 ps -A 查找 vi 的进程信息，结果如下： 在找到vi的进程号 pid 之后，可以继续从 ppid 处得到进程的父进程id，通过命令ps -l逐步寻找vi的父进程，寻找步骤如下： 在得到vi的进程调用序列之后，通过pstree命令来查看所有的进程树如下图所示，可以发现进程树命令和逐层寻找得到的结果相同，均为如下序列。 1Systemd-&gt;lightdm-&gt;lightdm-&gt;gnome-terminal-&gt;bash-&gt;vi 这里还要额外提一句，使用 Systemd 就不需要再用 init 了。这是因为init进程有两个缺点：启动时间长且启动脚本复杂。Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。 Q2.编写程序，首先使用fork系统调用，创建子进程。在父进程中继续执行空循环操作；在子进程中调用exec打开vi编辑器。然后在另外一个终端中，通过ps–Al命令、ps aux或者top等命令，查看vi进程及其父进程的运行状态，理解每个参数所表达的意义。选择合适的命令参数，对所有进程按照cpu占用率排序。 A2. 首先需要编写一个用于实现题干功能的C语言代码。分析题目可以看到，首先需要使用 fork() 系统调用创建子进程，其次根据fork的返回值相应的在父/子进程中填入对应的功能代码，我的代码具体如下，程序在父进程中执行空循环操作，在子进程中通过系统调用 execlp() 来启动vi进程，执行结果通过在另外的终端中的命令得以查看。 12345678910111213141516171819202122232425#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123; pid_t pid; pid = fork(); //父进程: pid&gt;0 if(pid &gt; 0) while(1); //子进程： pid=0 else if(pid == 0)&#123; int ret; ret = execlp("vi","",NULL); if (ret == -1)&#123; perror ("execl"); printf("excel error\n"); &#125; &#125; else if(pid == -1)&#123; perror("fork"); printf("fork error\n"); &#125; &#125; ps-Al执行 ps -Al命令的执行结果如下：其中，各个参数的解释如下： 参数 说明 F flag S 程序的状态 UID 执行者身份 PID 进程ID PPID 父进程ID C 使用的CPU资源百分比 PRI 进程的执行优先权 NI 进程的nice值 ADDR 内核函数 SZ 占用内存的大小 WCHAN 进程正在睡眠的内核函数名称 TTY 登入者的终端机位置 TIME 使用掉的CPU时间 CMD 下达指令的名称 ps aux执行 ps aux 命令可以打印使进程按如下格式输出：1USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 其中，各个参数的解释如下： 参数 说明 USER 行程拥有者 PID pid %CPU 占用的 CPU 使用率 %MEM 占用的记忆体使用率 VSZ 占用的虚拟记忆体大小 RSS 占用的记忆体大小 TTY 终端的次要装置号码 STAT 该行程的状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) START 行程开始时间 TIME 执行的时间 COMMAND 所执行的指令 执行结果如下：可以看到，./fork-exec进程一直在运行，且占用了97.7%的CPU资源，这应该全部归功于空循环。 toptop命令用于实时显示进程的动态，按照CPU的占有量降序排序，进程信息区统计信息区域的下方显示了各个进程的详细信息，各列的含义如下： 参数 说明 PID 进程id USER 进程所有者的用户名 PR 优先级 NI nice值。负值表示高优先级，正值表示低优先级 VIRT 进程使用的虚拟内存总量，单位kb RES 进程使用的、未被换出的物理内存大小，单位kb SHR 共享内存大小，单位kb S 进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) %CPU 上次更新到现在的CPU时间占用百分比 %MEM 进程使用的物理内存百分比 TIME+ 进程使用的CPU时间总计，单位1/100秒 COMMAND 命令名/命令行 执行结果如下： Q3.使用fork系统调用，创建如下进程树，并使每个进程输出自己的ID和父进程的ID。观察进程的执行顺序和运行状态的变化。 A3.实现进程树需要通过fork系统调用来实现，首先需要熟悉fork的具体作用。 fork在英文中是”分叉”的意思，fork函数启动一个新的进程，这个进程几乎是当前进程的一个拷贝：子进程和父进程使用相同的代码段，子进程复制父进程的堆栈段和数据段。 所以也就是说，执行一次fork函数，有两个返回值。根据返回值的不同可以区别父进程(&gt;0)和子进程(=0)。 根据进程树的结构，p1有两个子进程p2和p3，同时p2也有两个子进程p4和p5，所以我所编写的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdbool.h&gt;#include&lt;sys/types.h&gt;int main(int argc, char *argv) &#123; /* 先打印根节点 */ pid_t p1; printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); if(p1 == 0)&#123; /* 进入进程p1 */ pid_t p3; /* 先创建p3 */ p3 = fork(); if(p3 == 0) /* j进入进程p3 */ printf("p3 pid: %d, ppid: %d\n", getpid(),getppid()); else if(p3 &gt; 0)&#123; /* 进入p3的父进程，也就是p1。 接下来创建进程p2 */ pid_t p2; p2 = fork(); if(p2==0)&#123; /* 进入进程p2,接下来先创建p4 */ printf("p2 pid: %d, ppid: %d\n", getpid(),getppid()); pid_t p4; p4 = fork(); if(p4 == 0)&#123; /* 进入进程p4 */ printf("p4 pid: %d, ppid: %d\n", getpid(),getppid()); &#125; else if(p4 &gt;0)&#123; /* 此处位于p4的父进程，即p2,继续创建p5 */ pid_t p5; p5 = fork(); if(p5==0) printf("p5 pid: %d, ppid: %d\n", getpid(),getppid()); &#125; &#125; &#125; &#125; sleep(1); &#125; 程序的输出结果如下，满足题目的进程树的架构： Q4. 修改上述进程树中的进程，使得所有进程都循环输出自己的ID和父进程的ID。然后终止p2进程(分别采用kill -9 、自己正常退出exit()、段错误退出)，观察p1、p3、p4、p5进程的运行状态和其他相关参数有何改变。 A4. 第四题应该是这几个题中最难的一个，综合了前三个题的知识应用，必须有对进程的充分认识和fork系统调用的理解才能实现这些功能，我的视线具体如下： 代码部分需要在第三题的基础上进行修改，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdbool.h&gt;#include&lt;sys/types.h&gt;int main(int argc, char *argv) &#123; /* 先打印根节点 */ pid_t p1; if(p1 == 0)&#123; /* 进入进程p1 */ int p1pid,p1ppid; p1pid = getpid(); p1ppid = getppid(); //printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); pid_t p3; /* 先创建p3 */ p3 = fork(); if(p3 == 0)&#123; /* j进入进程p3 */ int i; for(i=0;i&lt;10;i++)&#123; printf("p3 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else if(p3 &gt; 0)&#123; /* 进入p3的父进程，也就是p1。 接下来创建进程p2 */ pid_t p2; p2 = fork(); if(p2==0)&#123; /* 进入进程p2,接下来先创建p4 */ pid_t p4; p4 = fork(); if(p4 == 0)&#123; /* 进入进程p4 */ int i; for(i=0;i&lt;10;i++)&#123; printf("p4 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else if(p4 &gt;0)&#123; /* 此处位于p4的父进程，即p2,继续创建p5 */ pid_t p5; p5 = fork(); if(p5==0)&#123; //p5 int i; for(i=0;i&lt;10;i++)&#123; printf("p5 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; else&#123; //p2 int i; for(i=0;i&lt;10;i++)&#123; //通过exit()终止p2 if(i==2) exit(1); //段错误 //if(i==5) //&#123; // int *p=NULL; // *p=0; //&#125; printf("p2 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; &#125; &#125; &#125; int i; for(i=0;i&lt;10;i++)&#123; printf("p1 pid: %d, ppid: %d\n", getpid(),getppid()); sleep(1); &#125; return 0; &#125; sleep(1); &#125; 即需要在刚进入p1的时候记录p1的pid和ppid以便后续打印输出，p2进程的输出部分需要控制在p5进程的父进程部分，如果在刚进入p2就执行循环输出，p4和p5进程就会因此无法创建。 程序的输出结果如下： 下面分别采用kill -9 、自己正常退出exit()、段错误退出来终止p2进程。 kill -9kill -9属于手动中断进程，通过此命令中断p2的结果如下：在p2被中断之后，其子进程p4和p5的参数ppid的值随即发生改变。 exit()exit()函数属于安放在代码中的正常退出函数，将其放入p2循环打印的代码中，控制其在特定次数后执行便可以达到我们的预期，结果如下：可以看到，由于p2先于其父进程p1结束，随即就变成了僵尸进程defunct状态 段错误所谓段错误，一般是访问了未申请的内存或非法的内存时产生的，概括点说在代码中一般是由指针的不当使用引起的。为了引起段错误，我在代码中设置了如下代码段：其执行结果如下： 参数变化对于每种错误我均使用了ps命令来查看进程参数信息，最后发现三种情况所造成的进程中断所带来的参数变化是一样的，p2进程的参数变化如下：从图中可以看到： 程序的状态由S变为Z，即僵死 占用内存大小变为0 WCHAN由hrtime变为‘-’，进程停止 cmd部分多了僵尸进程标识符 参考文献linux命令ps aux|grep xxx详解 https://www.cnblogs.com/robertoji/p/5555449.html linux的top命令参数详解 https://www.cnblogs.com/LeoBoy/p/7976612.html ps命令执行后各项参数的含义 https://blog.csdn.net/tcpipstack/article/details/8541980]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——存储过程和函数]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本次作业基于Mac OS X系统下的mysql workbench软件完成 存储过程在数据库编程中也是一个重要的角色，其主要的能力在于能被编译好放到服务器中，在使用时直接call即可调用执行，既能简化操作又能节省时间，能在优化层面起到一个很好的作用。 实验内容1、编写存储过程实现下列操作： （1）查询某读者、某段时间的借阅信息。已知读者姓名，查询起始和终止时间，列出其所有借阅信息。 （2）实现简单的图书入库操作（包含主键的少量信息即可）2、编写函数实现下列操作： 输入会员级别，返回该级别会员所借的图书总数量 解决方案编写存储过程（1）查询某读者、某段时间的借阅信息（已知读者姓名，查询起始和终止时间，列出其所有借阅信息 实现代码如下,其中 delimiter 是MySQL中的命令，这个命令与存储过程没什么关系，其作用就是告诉mysql解释器，该段命令是否已经结束了，mysql是否可以执行了。12345678910USE `bookmis`;DROP procedure IF EXISTS `borrow_book`;DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `borrow_book`(in reader_id varchar(5),in starttime date,in endtime date)BEGIN select * from borrows where borrows.reader_id=reader_id and borrows.Date_borrow&gt;=starttime and borrows.Date_return&lt;=endtime;END$$DELIMITER ; 我们用代码1call borrow_book('r001','2016-01-01','2017-01-01') 来进行测试，成功输出了r001在指定时间的借阅信息： （2）实现简单的图书入库操作（包含主键的少量信息即可） 代码如下，插入的参数为 book_id , book_name 和 Quantity_in 三个1234567891011121314DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` PROCEDURE `entry`(in id varchar(5),in book_name varchar(15),in amount int)BEGIN if id in (select book_id from books) then update books set Quantity_in=Quantity_in+amount where books.book_id=id; else insert into books(book_id,book_name,Quantity_in) values (id,book_name,amount); end if;END$$DELIMITER ; 由于存储过中写到了if条件判断，所以我们分别测试一下插入新书和插入旧书的结果。首先是插入新书，执行代码1call entry('b009','test_book',12) 结果如下：其次是插入旧书，执行代码1call entry('b001','并行计算',20) 结果如下： 编写函数（1）输入会员级别，返回该级别会员所借的图书总数量。 代码如下：123456789101112DELIMITER $$USE `bookmis`$$CREATE DEFINER=`root`@`localhost` FUNCTION`show_vipbooks`(vip_level varchar(6)) RETURNS int(11)DETERMINISTICBEGIN declare sum int; set sum = (select count(book_id) from readers,borrows where readers.level=vip_level and readers.reader_id=borrows.reader_id group by readers.level);RETURN sum;END$$DELIMITER ; 我们拿金卡用户做测试，可以观察到金卡用户 r001,r004:r001,r004总共借阅了图书5本，分别是b001,b002,b001,b002,b006: 执行代码：1select show_vipbooks('金卡') 函数执行结果如下： 小结存储过程和函数在课程设计和项目中都是一个比较重要的成分，其中很大一部分原因在于其代码的集成性。运用存储过程可以起到一个很好的简化代码的作用，只需一个入口参数即可实现重复的数据查询或数据定义的功能，比起繁琐的select语句，一个call起到的作用会更大，更何况其执行速度也得到了很好的优化。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——SQL调优]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94SQL%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[SQL调优是一项很重要的技术，实际在使用小数据集时DBMS自身的搜索优化是能满足我们的时间需求的，只有在数据集规模到10w+以后才能在秒级的层面看到SQL代码优化的效果。 本次实验环境如下： 操作系统：Mac OS X 10.13 DBMS：MySQL 8.0 图形化管理界面：MySQL Workbench 表结构本次实验选用了一个待测试表，名为‘pv_train_part1’，其结构如下： 名称 类型 实例 Key int 5 Feature1 double 1.294408418 Feature2 double 1.331507473 Feature3 double 1.279030084 Feature4 double 0.545543622 Feature5 int 64125 Feature6 double 1.738819447 Feature7 double 0.88708635 Feature8 double 28622.91442 label int 0 数据仿真方法此数据集来源于我跟随老师做的项目，从数据实例和分布来看其明显是一个机器学习模型的训练数据样本，大体是一个八参数的分类问题（实则是一个多参数的特征选取和异常数据监测项目）。 本数据取自github上的开源数据集，其链接为：数据集 数据记录数通过MySQL Workbench的‘Table Data Import Wizard’功能，可以实现将外部csv文件导入的功能： 通过执行结果可以观测到数据记录数如下： 优化规则及执行时间优化规则一:建立索引首先我使用的第一条优化规则便是建立索引，这在几乎所有的DBMS上是通用的优化策略。为了便于展示，这里的优化执行结果以执行查询操作来作为反馈。 在没建立索引前，表的设计层面如下：执行查询语句：1select feature3 from pv_train_part1 where pv_train_part1.key=59081; 结果如下： 可以看到该查询的执行时间为： 0.056 second 。 然后我们给key属性添加主键索引，添加完之后设计层面如下： 添加完成之后重新执行相同的查询语句，执行时间如下： 可以看到，在添加完主键索引之后，查询时间变成了 0.00034 second，较未添加索引之间查询效率提高了 163 倍。 优化规则二:查询限制在MySQL中，假如只需要一条查询条件的结果，或者在事先已经知道查询语句仅仅会返回一条结果的情况下，我们可以在查询语句的结尾后添加 “limit 1” 字段以便在查询到结果后中断对剩余表单的检索，对比如下： 首先我们对表执行查询语句：1select feature3 from pv_train_part1 where pv_train_part1.label=3 ; 查询时间如下： 可以看到，通过普通查询语句查询，其执行时间在 0.039 second。 然后对上述sql语句后添加 “limit 1” ，修改为：1select feature3 from pv_train_part1 where pv_train_part1.label=3 limit 1; 查询时间如下：可以看到，在添加limit 1后，其执行时间缩短为了 0.00049 second，相较于优化前的查询，效率提高了 203 倍。 通过这几个案例可以看出，SQL调优可以为数据库的查询操作提高近百倍的效率，是我们在开发大型工程中的必备知识。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——完整性]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AE%8C%E6%95%B4%E6%80%A7%2F</url>
    <content type="text"><![CDATA[数据库的完整性是一块很重要的知识，涉及到表、视图等的各种约束，是保证数据库或项目正常运行的根本保证，也是继SQL语句后的第二块重要的知识点。 完整性主要包括：实体完整性，参照完整性和用户自定义完整性。当然，在dbms下，用户接触最直接的就是用户自定义完整性和外键的参照完整性，所以下面的实验主要以后两者为主。 用户自定义完整性check语句使用check子句定义如下约束条件:• 读者证件只能是“身份证”或“护照”；• 读者手机号是以“1”打头的11位字符,后10位只能是数字。 解决方案 由于mysql不支持check方法，所以为了完成本题的要求，我对各自问题编写了一个触发器以实现所需功能。 Q. 读者证件只能是“身份证”或“护照”A.123456CREATE DEFINER=`root`@`localhost` TRIGGER `readers_BEFORE_INSERT` BEFORE INSERT ON `readers` FOR EACH ROW BEGIN if NEW.Card_name not in ('身份证' ,'护照') then delete from readers where Card_name = new.Card_name; end if;END 执行错误插入（Card_name=’其他’）如下： 触发器功能启动，报错如下： 执行正确插入（Card_name=’护照’）如下： 语句成功执行： 其实用check语句实现很容易，只需要在表的定义语句中加上check Card_name in (&#39;身份证&#39; ,&#39;护照&#39;)即可实现。 Q. 读者手机号是以“1”打头的11位字符,后10位只能是数字A. 由于mobile为varcher型，直接设置 正则 比较即可1234CREATE DEFINER=`root`@`localhost` TRIGGER `readers_BEFORE_INSERT` BEFORE INSERT ON `readers` FOR EACH ROW BEGIN if NEW.mobile not REGEXP '^[1][0-9]&#123;10&#125;$' then delete from readers where mobile = new.mobile; end if;END 执行错误插入（mobile=2…）如下： 触发器功能启动，报错如下： 触发器编写触发器，实现以下约束• 已挂失的借书证不能再借书；• 向借阅表增加一个借书记录后，在图书表里该图书的出借数自动加1。 解决方案Q. 已挂失的借书证不能再借书A. 由题意可知，存在于loss_reporting表中的用户不能再向borrow表中插入数据，所以代码实现如下：12345678CREATE DEFINER=`root`@`localhost` TRIGGER `borrows_BEFORE_INSERT` BEFORE INSERT ON `borrows` FOR EACH ROW BEGIN if exists(select loss_reporting.reader_id from loss_reporting where(loss_reporting.reader_id = new.reader_id)) then delete from borrows where reader_id = new.reader_id; end if;END Q. 向借阅表增加一个借书记录后，在图书表里该图书的出借数自动加1A.12345678CREATE DEFINER=`root`@`localhost` TRIGGER `borrows_AFTER_INSERT` AFTER INSERT ON `borrows` FOR EACH ROW BEGIN if new.book_id in (select book_id from books) then update books set Quantity_out=Quantity_out+1 where books.book_id=new.book_id; end if;END 参照完整性参照完整性决定了外键约束，即在引用表中外键的值只能设置为被引用表中的值或为null 自定义违约处理将读者表的‘会员级别’外键的违约处理策略定义为置默认值“null” 解决方案在删除或更新外键时，子表置空 123456ALTER TABLE `bookmis`.`readers` ADD CONSTRAINT `level` FOREIGN KEY (`level`) REFERENCES `bookmis`.`member_level` (`level`) ON DELETE SET NULL ON UPDATE SET NULL; 在添加外键约束之后，我们将member_level表中的‘普通’删去，然后观察readers表中的数据变化如下： readers表原始数据： readers表执行删除后的结果如下： 可以观察到‘普通’全被置换为了null; 接下来我们将‘银卡’更新为‘白卡’可以看到readers表中的‘银卡’也被修改为了null（这里可能用cascade效果更好）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——安全性练习]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E6%80%A7%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[登录验证要求能够以2种登录方式登陆（ Windows 身份验证和SQL Server身份验证）。 解决方案 由于我的作业是基于 Mac OS X 系统下，用 mysql workbench 完成，故下面展示如何在Mac上登陆mysql workbench。 首先打开mysql workbench可以看到如下登录界面，选择 loacl instance ，实现Mac OS X系统本地登陆，操作步骤如下： 第二次，打开mysql workbench，选择 nlz 用户登陆，实现mysql workbench身份验证登陆，操作步骤如下: 权限分配新建登陆log1，新建用户u1，新建角色r1，授予角色 r1 对表S的select权限，将角色r1赋给用户u1，验证用户u1只具有表S的select权限，收回用户u1的角色r1，验证用户u1不具有表S的select权限。 要注意的是，角色 role 是 mysql8.0 版本之后才有的，在 mysql5.x 版本里不存在 role 解决方案 新建登陆log1如下： 新建用户u1： 1CREATE USER 'u1'@'localhost'; 新建角色r1: 1CREATE role r1; 授予角色 r1 对表books的select权限： 1grant select on bookmis.books to r1; 将角色r1赋给用户u1： 1grant r1 to 'u1'@'localhost' 激活角色:激活之前，没有角色处于运行状态，状态如下： 1SET DEFAULT ROLE ALL TO 'u1'@'localhost'; 通过执行上述代码实现对u1用户的相关角色的激活操作，激活之后通过代码：SELECT CURRENT_ROLE()查询活动的角色，如下： 验证用户u1只具有表books的select权限： 1SHOW GRANTS FOR 'u1'@'localhost' USING 'r1'; 输出u1具有的权限如下，可以看出，其只具有bookmis.books的select权限. 在u1用户上执行对books执行select操作，查询成功，结果如下： 继续执行查询readers表的操作，查询失败，结果如下： 收回用户u1的角色r1，验证用户u1不具有表books的select权限： 1REVOKE r1 FROM 'u1'@'localhost'; 回收r1之后我们执行代码：SHOW GRANTS FOR &apos;u1&apos;@&apos;localhost&apos; USING &apos;r1&apos;查看u1现在具有的权限，结果如下： 验证r1被回收，所以u1也丧失了相应的权限。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库——SQL练习]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94SQL%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[计网的实验差不多整理完毕了，今天开始陆续整理一下数据库的实验吧，大三上最喜欢的课程就是数据库，所以我觉得作业的完成质量还是可以恭维的。 关系模式关系模式使用的是课程给出的图书管理系统，涉及到六个关系模式，包括两个实体和四个联系。先省略，以后有时间补齐。 SQL：数据查询在bookmis数据库中完成下列SQL查询：1、查找借了会员“李红 ”所借的全部图书的会员姓名2、查找没有借科普类图书的会员姓名3、查找借了2本及以上图书的银卡会员的姓名4、将计算机类图书的入库数加15、用insert命令向图书类别表中添加记录（‘ca07’ , ‘儿童’）6、用delete命令从图书类别表中删除类别‘儿童’7、把金卡读者的读者名和性别存入另一个已知基本表vip_readers (Reader_name,sex)中8、建立一个计算机类图书的视图，显示书编号、书名和出版社9、建立一个分组视图，显示每种级别会员的数量10、在（9）建立的分组视图中查询金卡会员的数量11、自己编写并实现一个能成功执行的视图更新任务 查询方案 本次作业基于MAC OS X系统下的mysql workbench软件完成 Q. 查找借了会员“李红 ”所借的全部图书的会员姓名A. 代码：基本思想为逻辑蕴含的转化:1234567891011select reader_name from readerswhere reader_id in (select distinct reader_id from borrow ba where not exists (select * from borrow bb where reader_id=(select reader_id from readers where reader_name='李红') AND not exists (select * from borrow bc where bc.reader_id=ba.reader_id AND bc.book_id=bb.book_id)) AND reader_id&lt;&gt;(select reader_id from readers where reader_name='李红')); Q. 查找没有借科普类图书的会员姓名A. 代码:123456select reader_name from readerswhere reader_id in (select reader_id from borrow,books,b_category where borrow.book_id=books.book_id AND books.category_id=b_category.category_id AND b_category.category&lt;&gt;'科普'); Q. 查找借了2本及以上图书的银卡会员的姓名A.123456select reader_name from readerswhere level='银卡' AND reader_id in( select reader_id from borrow group by reader_id having count(reader_id)&gt;=2); Q. 将计算机类图书的入库数加1A.1234set sql_safe_updates=0; #mysql中必须降低安全等级才能够批量操作update booksset Quantity_in=Quantity_in+1where Quantity_in&gt;=0; Q. 用insert命令向图书类别表中添加记录（‘ca07’ , ‘儿童’）A.123insert #插入指令into b_category(category_id,category)values('ca07','儿童'); Q. 用delete命令从图书类别表中删除类别‘儿童’A.123delete #删除指令from b_categorywhere(category='儿童'); Q. 把金卡读者的读者名和性别存入另一个已知基本表vip_readers (Reader_name,sex)中A.12345678create table vip_readers (Reader_name varchar(50), sex varchar(2) ); #创建表insert into vip_readers(Reader_name,sex) #插入数据select readers.reader_name,readers.sexfrom readerswhere level='金卡'; Q. 建立一个计算机类图书的视图，显示书编号、书名和出版社A.12345create view cs_book(book_id,book_name,publishing) #创建视图asselect book_id,book_name,publishingfrom books,b_categorywhere books.category_id=b_category.category_id AND b_category.category='计算机'; Q. 建立一个分组视图，显示每种级别会员的数量A.12345create view vip_count(level,number)asselect readers.level,count(level)from readersgroup by readers.level; #分组 Q. 在建立的分组视图中查询金卡会员的数量A.123select level,numberfrom vip_countwhere level='金卡'; Q. 自己编写并实现一个能成功执行的视图更新任务A.123update cs_bookset book_name='abc'where book_id='b001'; SQL：数据定义1、新建数据库Student12、在Student1数据库中新建表S1、C1和 SC1 ,指明主外键（结构与S,C,SC相同）3、在表S1中新增一列addr CHAR（20)4、删除表S1中的列addr5、在表SC1的列sno上建立升序索引6、删除表SC1 定义方案Q. 新建数据库Student1A.1create schema student1 Q. 在Student1数据库中新建表S1、C1和 SC1 ,指明主外键（结构与S,C,SC相同）A.1234567891011121314151617181920create table S1( sno char(4) primary key not null,#主键 sname char(8) not null, age int, sex char(1)); #建表S1create table C1( cno char(4) primary key not null,#主键 cname char(8) not null, tname char(10)); #建表C1create table SC1( sno char(4) not null, cno char(4) not null, grade int, primary key(sno,cno),#指定主键 foreign key(sno) references S1(sno),#指定外键 foreign key(cno) references C1(cno),#指定外键 check (grade is null or grade between 0 and 100)); #建表SC1 Q. 在表S1中新增一列addr CHAR（20)A.12alter table S1 add addr CHAR(20); Q. 删除表S1中的列addrA.12alter table S1 drop addr; Q. 在表SC1的列sno上建立升序索引A.12create index sno1 on SC1(sno asc); Q. 删除表SC1A.1drop table SC1; 小结SQL的数据定义和数据查询语句都是基础的语法，也是在后续编程中最常用到的语句，这里的基础一定要打牢，做项目和课程设计是也就是建立在这些基础语法之上的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——交换机VLAN实验]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E6%9C%BAVLAN%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[实验目的 熟悉 VLAN 的技术背景和原理 熟悉 VLAN 的基本配置方法和配置命令 在交换机上实现 VLAN 的划分 实验拓扑其中PC_A接port1口，PC_C 接port 2口，PC_B接port 1口，PC_D接port 2口， 两台交换机之间接port24口。 实验环境 系统：Windows7软件工具：Cisco Packet Tracer实现途径：软件模拟实现 实验过程本次实验分别从 Packet Tracer 软件模拟以及 实验室实地操作 共同实现： Packet Tracer模拟选择实验仪器利用Packet Tracer选取实验仪器是一件比较容易的事情，仅依靠拖拽功能即可实现布局。 交换机在左下方的控件选择中，我们选中Switches，然后根据实验指导的要求，选中2950T型号的交换机两台，如图所示： PC机根据实验指导书的要求，本次实验需要4台PC机以备测试。继续在控件中找到End Devices，从中找到Generic即为满足实验要求的PC机，如图所示： 构建网络拓扑根据实验指导的要求，PC-A和PC-B分别接两台交换机的port1口，PC-C和PC-D分别接两台交换机的port2口，两条交换机之间接port24相连。利用Packet Tracer建立网络拓扑也是一件比较容易的事情，完成布局如下： 更具体的，我们可以看到交换机的port1、port2和port24被连接挂起： 划分VLAN在连接构建好网络拓扑结构后，我们需要对交换机进行一些配置。在上一个过程中，我们分别连接占用了1、2和24口，所以在这一步我们需要分别对两个交换机的这三个口进行VLAN的划分。分别进入Switch3和Switch4的CLI界面，根据实验指导输入命令用以实现划分，操作如下： 根据实验指导，配置完成之后可以调用命令show vlan和show running-config查看划分情况和配置。 配置PC在配置完交换机后，下一步需要完成对四个PC机的配置，这里的配置实质上是完成对PC机的IP参数的配置，包括IP地址、子网掩码和默认网关等。在PC机的desktop的IP configure界面可以完成上述配置，如图所示： 实验结果完成PC和交换机的配置后，我们可以在PC机的命令行界面执行Ping命令，用以检查是否完成实验要求。按照网络拓扑结构，在我们的测试网络中，PC-A可以Ping通PC-B，但是不能Ping通PC-C和PC-D。 实验室实地操作通过在软件上模拟之后，我对本次实验的具体原理、操作和内容又了进一步的理解。而后在周四的实验上机中，我通过具体的连线和上手操作完成了本次实验的全部要求。 配置交换机实验室的交换机不需要我们再通过超级终端去配置，所以我们只需要对待使用的两台交换机分别划分好vlan和端口即可。 通过两条telnet命令分别连接10007和10008端口进行配置。1telnet 172.31.44.240 10007 1telnet 172.31.44.240 10008 依照实验指导，我们将命令依次输入，实现port24相连，vlan10和vlan20对port1和port2的划分，配置结果如下： PC测试在配置完交换机之后，下一步便该进行PC之间的测试了。依照实验指导的要求，我们需要4台PC分别连接两台交换机的port1和port2。 为了简化实验操作，在实验中我选择了两台PC（分别为192.168.1.2和192.168.1.3）分别连接 &lt; switch1:port1, switch2:port1&gt;&lt; switch1:port1, switch2:port2&gt;&lt; switch1:port2, switch2:port1&gt;&lt; switch1:port2, switch2:port2&gt; 以满足实验要求。 测试结果如下： 接相同端口的情况下可以相互ping通 接不同端口的情况下不可以相互ping通]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——实现路由算法]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 Dijkstra 算法的路由软件。 实验环境 系统：Mac OS X 10.13.1语言：Python 3.6.5平台：pycharm外部库：networkx，matplotlib 实验过程代码设计现Dijkstra算法的方法有很多种，为了在最短的代码内实现最好的效果，我选择了python来实现，借助networkx的有向图类DiGrapg接口实现了图的存储，通过自己实现的Dijkstra算法完成了搜索。 图的构造我们这里借助networkx库里的DiGraph类来构造有向图。DiGraph存储有向图的边的形式为形如(s，d，w)的三元组形式，其中： s: 边的起点；d: 边的终点；w: 边的代价. 考虑到操作的便捷性，我们使用一个path.txt文件来实现图的各个边的三元组的存储，path.txt的格式如下： 定义好边的数据结构之后，我们利用networkx中的函数add_edge()来实现边的输入和图的构建 12345for line in open("path.txt","r"): #按行读取文件 data.append(line.strip('\n')) for row in data: row=row.split(',') #分割三元组 G.add_edge(eval(row[0]), eval(row[1]), weight=eval(row[2]) Dijkstra算法算法实现的流程图如下： 演示部分networkx库同样集成了图的绘制函数，我们通过与matplotlib库的协同操作来完成图的搜索演示。通过以下代码来实现图的分屏：123plt.figure(figsize=(14, 6)) plt.subplot(121)plt.subplot(122) 通过以下代码来实现初始图的绘制：12pos = nx.spring_layout(G)nx.draw_networkx(G, pos,node_size=300,node_color='#FFB5C5') 通过以下代码来实现图上搜索路径的绘制：123456# 绘制非路径上的边 edges_not_in_path = list(set(G.edges()) - set(edges))edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges_not_in_path]nx.draw_networkx_edges(G, pos, edgelist=edges_not_in_path, edge_color='b',width=edgewidth) # 绘制路径上的边 edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges]nx.draw_networkx_edges(G,pos,edgelist=edges,edge_color='r',width=edgewidth) 执行结果我们这里把网络类比为一个有向图，事实上路由的传输方向可以是双向的。其中，图‘Test Graph’即为初始图；对于图‘The shortest path from 0 to 6’： 红色边：通过Dijkstra算法搜索到的最小代价路径；蓝色边：未采纳的边；边的粗细程度：边的权值，越细代表权值越小. 为了验证我们得到的路径是否是正确的答案，我们使用networkx库中标准的函数进行检验，代码如下：answer=nx.dijkstra_path(G,source=start_node,target=end_node)可以得到输出的answer路径如下，与我们的代码所得出的答案相同： 代码附录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import networkx as nx import matplotlib.pyplot as plt #路由算法实现 def Dijkstra(G,start,end): RG = G.reverse() dist = &#123;&#125; previous = &#123;&#125; for v in RG.nodes(): dist[v] = float('inf') previous[v] = 'none' dist[end] = 0 u = end while u!=start: u = min(dist, key=dist.get) distu = dist[u] del dist[u] for u,v in RG.edges(u): if v in dist: alt = distu + RG[u][v]['weight'] if alt &lt; dist[v]: dist[v] = alt previous[v] = u path=(start,) last= start while last != end: nxt = previous[last] path += (nxt,) last = nxt return path #初始化图函数 def init(G): data = [] for line in open("path.txt","r"): #按行读取文件 data.append(line.strip('\n')) for row in data: #分割三元组 row=row.split(',') G.add_edge(eval(row[0]), eval(row[1]), weight=eval(row[2])) return G if __name__=="__main__": #路由算法实现 G=nx.DiGraph() G=init(G) start_node = 0 end_node = 6 path=Dijkstra(G,start_node,end_node) #标准库函数检测 answer=nx.dijkstra_path(G,source=start_node,target=end_node) print("nx.dijkstra_path's path:") for i in range(len(answer)-1): print(str(answer[i])+'-&gt;',end="") print(answer[i+1]) # 构造最小权值边路径 edges=[] for i in range(len(path)-1): edges.append((path[i],path[i+1])) #绘制初始图 plt.figure(figsize=(14, 6)) plt.subplot(121) plt.title("Test Graph") pos = nx.spring_layout(G) nx.draw_networkx(G, pos,node_size=300,node_color='#FFB5C5') #绘制最小路径结果 plt.subplot(122) plt.title("The shortest path from %d to %d" % (start_node, end_node)) nx.draw_networkx_nodes(G, pos=pos, node_size=300,node_color='#FFB5C5') # 绘制非路径上的边 edges_not_in_path = list(set(G.edges()) - set(edges)) edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges_not_in_path] nx.draw_networkx_edges(G, pos, edgelist=edges_not_in_path, edge_color='b',width=edgewidth) # 绘制路径上的边 edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges] nx.draw_networkx_edges(G, pos, edgelist=edges, edge_color='r',width=edgewidth) #显示 plt.show()]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——实现Go-Back-N]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0Go-Back-N%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 Go-Back-N 的可靠数据传输软件。 实验环境 系统：Mac OS X 10.13.1语言：Java开发平台：eclipse内部库：java.net，java.util 实验过程代码设计为了完成本次试验的要求，我编写了两个Java代码文件，分别实现server端功能和client端功能： server端代码流程主要算法流程如下所示，server端实现在一定丢包率范围内接收数据包并且回传ACK： client端代码流程主要的算法流程如下，client端主要实现数据包的传送以及延迟处理： 主机ip获取在启用Go-Back-N之前，我们首先需要获得个人电脑的IP。在Mac OS X系统，使用终端命令ifconfig即可直接查看主机IP，具体如下： 丢包率为0下的测试为了验证代码的正确性，我首先先把丢包率设置为0查看了具体的传输流程，代码执行结果如下： 窗口长度 windowSize = 4；数据包总数 num = 10；超时限制 Timer = 1000ms 执行结果如下： 丢包率为10%下的测试为了继续验证代码的正确性，而后我把丢包率设置为10%查看了具体的传输流程，代码执行结果如下： 小结本次实验中，我们完成了java的网络编程，模拟了GBN算法的运行，对GBN协议有了进一步的了解。在GBN协议中，接收方会丢弃所有失序的分组，尽管丢弃一个正确接收但是失序的分组有点浪费。但是根据GBN的原理。假定当前期望的编号是n，但是n+1提前达到。因为数据必须是有序交付，接收方可能缓存分组n+1，然后在他收到并交付分组n后，再将该分组交付到上层。但是如果n丢失，则n和n+1的分组都会被重发，因此，接收方只需要丢弃分组n+1即可。这种方法的优点是接收方缓存简单，即接收方不需要缓存任何失序分组。对于发送方来说，他只需要维护窗口的下边界和和nextseqnum在窗口中的位置。对于接收方来说，只需要维护下一个按序接收的分组的序号。 代码附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/************************发送方************************/public class Client &#123; //定义流量窗格长度，起始和终止数据包号，计时器 public static int windowSize; public static int start=0, end, num; public static long timerTime = 0; public static void main(String[] args) throws Exception &#123; //建立连接 InetAddress serverAddress = InetAddress.getByName("192.168.1.106"); DatagramSocket clientSocket = new DatagramSocket(9999); byte[] sendData; Timer timer = new Timer(); timer.schedule(new DelayActionListener(clientSocket), 0L, 500L); //通过输入初始化参数 Scanner scanner = new Scanner(System.in); System.out.println("Please enter number of packets: "); num = scanner.nextInt(); System.out.println("Please enter slide window size: "); windowSize = scanner.nextInt(); System.out.println(); end = start + windowSize; //启动计时 Timer[] timers = new Timer[num]; long startTime = System.currentTimeMillis(); //首先发送第一个流量窗内的数据包 System.out.println("&lt;--Client send packets " + start + " - " + (start+windowSize-1)); for (int i=start;i&lt;end;i++)&#123; sendData = (i + "seq").getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, 8888); clientSocket.send(sendPacket); &#125; //循环发送剩余的数据包 while (true)&#123; byte[] recvData = new byte[100]; DatagramPacket recvPacket = new DatagramPacket(recvData, recvData.length); clientSocket.receive(recvPacket); String in = new String(recvPacket.getData()).trim(); int ack_seq = Integer.parseInt(in.substring(3, in.length())); System.out.println("--&gt;Client received ACK: " + (ack_seq-1)); //正常情况 if (ack_seq &gt;= start &amp;&amp; ack_seq &lt; end)&#123; int oldEnd = end; start = ack_seq; end = ack_seq + windowSize; if (end &gt; num) end = num; //发送数据包 for (int i = oldEnd; i &lt; end; i++) &#123; sendData = (i + "seq").getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, 8888); clientSocket.send(sendPacket); System.out.println("&lt;--Client sent packet "+i); &#125; timerTime = System.currentTimeMillis(); &#125; //传到流量窗的右界限 if (ack_seq == end) timerTime = 0; //传输结束 if (ack_seq == num)&#123; timer.cancel(); System.out.println("Success sent all packets"); System.out.println("Time to send " + num + " packets successfully was " + (System.currentTimeMillis() - startTime) + "ms"); return; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/************************接收方************************/public class Server &#123; public static void main(String[] args) throws Exception &#123; //创建套接字，初始化参数 DatagramSocket serverSocket = new DatagramSocket(8888); int endReceive = 0; int missedCtr = 0; System.out.println("\n\n\nServer started.\n"); while (true)&#123; byte[] data = new byte[100]; //接收数据包 DatagramPacket receivePacket = new DatagramPacket(data, data.length); serverSocket.receive(receivePacket); //截取seq String in = new String(receivePacket.getData()).trim(); int seq = Integer.parseInt(in.substring(0, in.length() - 3)); System.out.println("Received packet " + seq+"&lt;--"); //在一定丢包率的范围内操作 if (seq == 0 || Math.random()&lt;=0.9)&#123; //接收数据包并发送ACK if (seq == endReceive)&#123; endReceive++; byte[] ackData = new String("ack"+endReceive).getBytes(); InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); DatagramPacket sendPacket = new DatagramPacket(ackData, ackData.length, clientAddress, clientPort); serverSocket.send(sendPacket); System.out.println("Server sent ACK: " + seq+"--&gt;"); &#125; //有数据包超前到达 else if (endReceive != 0)&#123; if (seq == endReceive + 1) &#123; System.out.println("Packet lost or disordered on way to server: " + endReceive); missedCtr++; System.out.println("Missed: " + missedCtr); &#125; byte[] ackData = new String("ack"+(endReceive)).getBytes(); InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); DatagramPacket sendPacket = new DatagramPacket(ackData, ackData.length, clientAddress, clientPort); serverSocket.send(sendPacket); System.out.println("Server sent ACK: " + (endReceive-1)+"--&gt;"); &#125; &#125; //有数据包丢失 else &#123; System.out.println("Drop packet " + seq); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——用smtp实现Email客户端]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%94%A8smtp%E5%AE%9E%E7%8E%B0Email%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 smtp 协议的 Email 客户端软件。 实验环境 系统：Mac OS X 10.13.1语言：Java连接协议：smtp邮箱主机：smtp.qq.com（qq邮箱）外部jar文件：javax.mail.jar 实验过程代码部分为了完成本次试验的要求，我编写了一个Java代码文件，具体的算法流程如下： 邮箱端配置为了方便起见，我在这里使用qq邮箱作为我的测试邮箱，但是qq邮箱默认是关闭smtp服务的，所以我们需要先开启smtp协议。 首先在qq邮箱的个人账户部分找到如下服务的对应位置（此图为开启之后所截，故显示已经开启）： 配合手机操作操作之后，我们可以得到如下的开通反馈，其中返回的授权码极为重要，其关系到代码中transport.connect（）方法的执行成功与否： 代码测试由查阅可得，qq邮箱的服务器如下，且使用端口为465或587：将服务器（smtp.qq.com）、端口(465)、收件人(835381071@qq.com)发件人邮箱(835381071@qq.com)和标题内容设置好之后，通过授权码执行连接，可以debug测试输出如下： 执行结果最后为了验证我们的执行结果，打开qq邮箱的收件箱，可以看到如下信息： 代码附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package smpt;import java.util.Properties;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;public class SendmailUtil &#123; public static void main(String[] args) throws AddressException, MessagingException &#123; Properties properties = new Properties(); // 使用smtp协议 properties.put("mail.transport.protocol", "smtp"); //qq邮箱的主机名 properties.put("mail.smtp.host", "smtp.qq.com"); //qq邮箱使用465端口 properties.put("mail.smtp.port", 465); // 端口号 //login验证 properties.put("mail.smtp.auth", "true"); //使用ssl安全连接 properties.put("mail.smtp.ssl.enable", "true"); // 设置是否显示debug信息 true 会在控制台显示相关信息 properties.put("mail.debug", "true"); // Session用于收集JavaMail运行过程中的环境信息 Session session = Session.getInstance(properties); // 获取邮件对象 Message message = new MimeMessage(session); // 设置发件人邮箱地址 message.setFrom(new InternetAddress("835381071@qq.com")); // 设置收件人地址 message.setRecipients( RecipientType.TO, new InternetAddress[] &#123; new InternetAddress("835381071@qq.com") &#125;); // 设置邮件标题 message.setSubject("smtp测试邮件"); // 设置邮件内容 message.setText("内容：smtp发送邮件成功！"); // 得到邮差对象 Transport transport = session.getTransport(); // 连接自己的邮箱账户 transport.connect("835381071@qq.com", "sgxclkuvvirtbdfe"); // 发送邮件 transport.sendMessage(message, message.getAllRecipients()); &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——JAVA实现web服务器]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94JAVA%E5%AE%9E%E7%8E%B0web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[趁着这几天刚开学，时间还比较宽裕，决定来整理一下自己的实验报告，先从计网开始。 实验目的 处理一个 http 请求 接收并解析 http 请求 从服务器文件系统中获得被请求的文件 创建一个包括被请求的文件的 http 响应信息 直接发送该信息到客户端 实验环境 系统：Mac OS X 10.13.1 语言：JAVA 浏览器：Google Chrome 实验步骤前期准备为了完成本次试验的要求，我编写了两个java代码文件，分别命名为：“HttpRequest.java”和“WebServer.java”。除此之外，我还编写了两个带跳转的测试网页“index.html”和“next.html”以及其各自包含的图片“first.jpg”和“next.jpg” HttpRequest.java的主要功能为：获取http请求中的套接字的输入流和输出流，即完成“对从服务器端发回的数据流”和“将要发送到服务器端的数据流”的处理和输出。 WebServer.java的主要功能为：创建线程，连续创建套接字以及处理http请求。 文件清单如下： 测试阶段我们使用jdk的javac指令对java代码进行编译，然后启动服务器的默认端口8080（代码中预设），然后在Google Chrome浏览器中对各种情况进行测试和检测输出，具体步骤如下。 首先我们启动终端，进入Java代码所在的文件夹下，然后利用javac命令编译main方法所在的Java文件“WebServer.java”，启动服务器，具体如下： 由于代码中设置的启动端口为8080，如下：所以我们在浏览器中需要输入网址“localhost:8080/index.html”以达到访问该网页的目的，具体如下： 在成功访问该网页之后，我们来观察一下终端的输出情况，发现其请求网页index.html请求成功如下：其请求网页包含的图片first.jpg请求成功如下： 然后点击跳转链接，跳转至next.html，访问下一个网页，同样的，网页跳转成功如下： 在成功打开网页之后，我们来观察一下终端的输出情况。同样的，请求网页“next.html”和“next.jpg”成功，输出如下结果： 当然，除了能成功访问的网页外，我们还需要测试一下错误路径的文件访问结果，于是在浏览器中输入一个错误的网址如“localhost:8080/404.html”，结果如下，提示文件不存在：终端反馈输出对404.html这个不存在的文件的访问结果： 代码附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/***********HttpRequest***************/import java.io.* ;import java.net.* ;import java.util.* ;final class HttpRequest implements Runnable &#123; final static String CRLF = "\r\n"; Socket socket; //构造请求类 public HttpRequest(Socket socket) throws Exception &#123; this.socket = socket; &#125; //启动线程 public void run() &#123; try &#123; processRequest(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; private void processRequest() throws Exception &#123; //获取套接字的输入流，即从服务器端发回的数据流 InputStream is = socket.getInputStream(); //获取套接字的输出流，返回的输出流就是将要发送到服务器端的数据流 DataOutputStream os = new DataOutputStream(socket.getOutputStream()); //缓冲字符输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); // 获取http的request信息 String requestLine = br.readLine(); // 从请求行中提取文件信息 StringTokenizer tokens = new StringTokenizer(requestLine); // 由于token将请求行分解为了单词，我们在这里跳过第一个单词，即“GET” tokens.nextToken(); // GET之后即为文件名 String fileName = tokens.nextToken(); // 为了将文件转化到当前目录下，我们在其之前加一个“.” fileName = "." + fileName ; // 打开文件 FileInputStream fis = null ; boolean fileExists = true ; //判断文件是否查询到 try &#123; fis = new FileInputStream(fileName); &#125; catch (FileNotFoundException e) &#123; fileExists = false ; &#125; //测试输出 System.out.println("\n*************Request**************\n"); System.out.println(requestLine); String headerLine = null; while ((headerLine = br.readLine()).length() != 0) &#123; System.out.println(headerLine); &#125; // 构造response信息 String statusLine = null; String contentTypeLine = null; String entityBody = null; if (fileExists) &#123; //执行成功的话返回“200 OK” statusLine = "HTTP/1.0 200 OK" + CRLF; contentTypeLine = "Content-Type: "+contentType(fileName) + CRLF; &#125; else &#123; //执行失败，文件未找到的时候返回“404 File Not Found” statusLine = "HTTP/1.0 404 File Not Found" + CRLF; contentTypeLine = "Content-Type: text/html" + CRLF; entityBody = "&lt;HTML&gt;" + "&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;" + "&lt;P&gt;File name:&lt;/P&gt;"+fileName+ "&lt;BODY&gt;Not Found&lt;/BODY&gt;&lt;/HTML&gt;"; &#125; // 将上述返回值依次输出 os.writeBytes(statusLine); os.writeBytes(contentTypeLine); os.writeBytes(CRLF); System.out.println("\n*************Response**************\n"); System.out.println(statusLine); //调用文件类型输出方法 if (fileExists) &#123; sendBytes(fis, os); fis.close(); &#125; else &#123; os.writeBytes(entityBody) ; &#125; // 结束关闭 os.close(); br.close(); socket.close(); &#125; private static void sendBytes(FileInputStream fis, OutputStream os) throws Exception &#123; //构造一个1K缓冲区，承接套接字的内容 byte[] buffer = new byte[1024]; int bytes = 0; //将请求的文件复制到套接字的输出流中。 while ((bytes = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, bytes); &#125; &#125; private static String contentType(String fileName) &#123; if(fileName.endsWith(".htm") || fileName.endsWith(".html")) &#123; return "text/html"; &#125; else return "other Content-type" ; &#125;&#125; 12345678910111213141516171819202122232425/***********WebServer***************/import java.io.* ;import java.net.* ;import java.util.* ;public final class WebServer &#123; public static void main(String argv[]) throws Exception &#123; int port=8080; // 建立一个套接字 ServerSocket socket = new ServerSocket(port); while (true) &#123; // 监听一个tcp连接的request. Socket connection = socket.accept(); // 处理HTTP请求消息。 HttpRequest request = new HttpRequest(connection); // 建立一个线程处理请求 Thread thread = new Thread(request); thread.start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次聚会]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%81%9A%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天正月十五，也不能说是闲来无事，毕竟还有那么多前路未卜的事情在等着自己，但是总归还是想写一些清闲的东西。 离开学还有五天，还在家能待三天。 今天去马骁家里聚会了，难得小聚一次，吃够了羊肉也喝够了粗，打够了麻将也赢够了钱。 大家都在为自己的前途开始迷茫了，没有明确的路子可走的人大概就是我们这一批大三的学生吧。 学生生涯还剩一年半，留给自己预备的选择也是众说纷纭。 考研怎么考能考得上哪，保研怎么找老师怎么不亏，出国又该怎么闹。 没有人知道该怎么办，就像有人说zgs的cpp课好一样，每个人都只有自己的路，你没有义务去让所有人都跟着自己的路走。 我也没有能力去辨别谁才是自己的模版。 毕竟这世界上，只有一个独一无二的贾浩男。 大家都好久没踢球了，曾经的前锋马骁也吃撑了一百九的中后卫，曾经的后卫现在也早就离开了操场。 被繁杂的课程，学业和人生压的不知所措。 但是有趣的是，我们每个人仿佛还走在自己自认为正确的道路上，自我感觉良好。 我总是难以定夺自己到底应该，或是值得去做什么。 我喜欢观望，观望才能给我很好的选择正确的机会。 但是观望，观望谁呢，谁有值得观望呢？ 无从所知。 我喜欢在街头看着各种各样的人的走走停停，去看他们的生活。 就像我最喜欢的实用文摘的板块，是社会百态。 在一个社会里，每个人都有着自己独一无二的生活。 品味这些生活，也真是一个有趣的过程。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——评论篇]]></title>
    <url>%2F2019%2F02%2F16%2FHexo%E2%80%94%E2%80%94%E8%AF%84%E8%AE%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天给琳琳看了下内测博客的初版，大体上还比较不错。 为了满足琳琳的需求，方便交流，我决定今天给博客添加评论功能。 网上的博客有很多，还是比较乱七八糟的，所以配好之后自己再总结一下，方便后人乘凉。 来必力在跟帖的插件中我选择了来必力：https://www.livere.com 有这几个原因： 界面UI美观 评论管理方便 支持多个社交账号 不过也有一点不方便，来必力隶属于韩国，在注册使用的时候需要科学上网，在网页加载的时候速度较慢。 下面来讲一下具体布置 注册登陆注册需要科学上网，不然是打不开注册登陆界面的，或者打开很慢？这里不做赘述。 安装选择city版安装就能满足我们的需求，直接安装即可。 安装完之后会以代码形式给出，或者也可以手动进入个人管理界面的 代码管理 查看。 对于NexT主题而言，这里我们主要关注 data-uid 的值。 配置得到用于安装插件的data-uid之后，下一步进入NexT的配置文件 _config.yml 设置data-uid的值。 在_config.yml中找到 livere_uid 的属性字样。 将livere_uid设置为刚刚得到的data-uid的值即可。 部署在上述过程完成之后，部署到博客即可。12$ hexo g$ hexo d 演示完成后的效果如下，支持点赞和折叠评论，支持QQ、微信、微博等多种社交账号： 分析上面的配置过程还是比较容易的，但是如果细看一下我还是有一个疑问的，为什么没有用到来必力提供的安装代码呢，为什么只靠一个data-uid就完成了评论功能？ 在查看了NexT下的相关文件后，我得出了结论。 在 themes/next/layout/_partials 文件夹下，有一个 comments.swig 文件。 在里面可以看到支持多个评论插件的安装脚本，比如Facebook，多说等。 NexT用来加载来必力的安装脚本可以在第45～48行看到，加载脚本为：1234&#123;% elseif theme.livere_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; 这段脚本可以用来必力提供的安装代码替换,作用相同：123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="******"&gt;&lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script');&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 在来必力端可以看到具体的评论情况，包括数据分析和评论管理，功能还是非常强大的。 好了，今天的评论的配置就写这么多。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——bug篇]]></title>
    <url>%2F2019%2F02%2F15%2FHexo%E2%80%94%E2%80%94bug%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天写博客的时候，一套hexo操作行云流水，奈何一个hexo g报错报了几百行，在终端里的错误让人害怕的发抖，先上图为敬。 显然这些带有具体文件路径和出错位置的error很难直接百度到解决方法，在百度了很久之后，我找到一个貌似跟我的bug相关的关键词： YAMLException 这是一个在yaml文件中的报错。 于是怀着一个科班出身的计算机人的心态，我决定自己读报错改bug。 首先找到加载出错的原因： ERROR Theme config load failed. 这大概是主题配置文件加载失败了？？？ 其次是出错的文件： ERROR Process failed: _config.yml 果然是主题配置文件出错了！ 继续找一下出错原因： 12345678910111213141516171819202122232425YAMLException: bad indentation of a mapping entry at line 823, column 3: counter: true ^ at generateError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:165:10) at throwError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:171:9) at readBlockMapping (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1080:7) at composeNode (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1332:12) at readDocument (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1492:3) at loadDocuments (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1548:5) at Object.load (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1569:19) at Hexo.yamlHelper (/Users/jiahaonan/blog/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15) at Hexo.tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Hexo.&lt;anonymous&gt; (/Users/jiahaonan/blog/node_modules/bluebird/js/release/method.js:15:34) at Promise.then.text (/Users/jiahaonan/blog/node_modules/hexo/lib/hexo/render.js:61:21) at tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:694:18) at _drainQueueStep (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:138:12) at _drainQueue (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) 妈耶，一开始看到这些bug我已经准备放弃了，因为这些bug并没有影响我提交博客的相关操作。 但是每次 hexo g 后总跟着几百行报错我看起来很难受啊。 还是继续冷静的分析一下吧。 找到YAMLException的提示位置，第823行。 所以，原来是我多打了一个空格！ 好了，冷静地把空格删掉。 重来一遍hexo g，完美运行～ 这个案例告诉我们，修改文件的时候不要把空格不当回事儿，不然都是bug劝退。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——公式篇]]></title>
    <url>%2F2019%2F02%2F14%2FMarkdown%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[写完语法和配置之后，当然还得补充一项最常用的 公式 的写法了。 在写word的时候一直是无脑公式编辑器，看见琳琳用的 latex 的时候总是一脸崇拜，时至今日也得学习一下latex的公式表达，它也是markdown所支持的公式写法。 由于公式的书写要求和规范太多了，我这里就不做生产者了，老老实实做个搬运工。 贴两篇比较好的博客，方便学习～ https://www.jianshu.com/p/a0aa94ef8ab2https://www.cnblogs.com/q735613050/p/7253073.html]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——配置篇]]></title>
    <url>%2F2019%2F02%2F13%2FMarkdown%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[上一篇讲了Markdown的语法，接下来说一下Markdown的插件。 Markdown的编辑器有很多，知乎一下就可以看到不少开源友好的编辑器，为了更好的整合我电脑上现有的软件（为了省内存），我决定在sublime text上写Markdown。 我电脑的配置如下： Mac OS X 10.13.1Sublime Text Version 3.1.1 虽然sublime text3自身携带许多语言的高亮，但是还没有达到我想要的Markdown的编写环境，自带的Markdown不好看也不好用，所以需要拿一些插件来满足一下需求。 需要安装的插件： Package Control:插件安装管理MarkdownEditing:显示Markdown的语法和高亮 可选的插件： OmniMarkupPreviewer:浏览器/html快捷预览和导出MarkdownLivePreview:sublime text界面实时预览 Package ControlPackage Control是Sublime Text不可或缺的一个插件，许多插件的安装和管理都要用到它。两个月之前我在配置NASM的语法和高亮插件时安装配置了Package Control，才第一次接触到Sublime Text的除了写字板之外的功能，所以这里要强烈安利Package Control这一插件，让我有了对不止于Sublime Text写字板的用户体验。 安装插件 打开Sublime Text的控制台 快捷键：control + ` 手动：View -&gt; Show Console 在控制台输入下面的第一行python代码回车即可。不过里面的 http://packagecontrol.io/ 应该是被墙了，这个年头程序员没个VPN还怪麻烦的。我在一些博客里找到了镜像网站，如果第一段代码无法安装，可以尝试一下第二种方法（未测） 1import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 1import urllib.request,os,hashlib; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://dn-52cik.qbox.me/' + pf.replace(' ', '%20')).read(); open(os.path.join( ipp, pf), 'wb' ).write(by) 使用安装成功之后，可以在 Sublime Text -&gt; Preference 里看到 Package Control 这一选项，也可以通过组合键 command + shift + p 在搜索框里搜索 Package Control 。 在package control里，最主要使用的是 install package 功能，在install package界面，可以根据个人需求安装所需要的插件。 需要注意的是，最近不使用vpn是无法使用install package功能的，会出现如下提示： 在科学上网之后，可以来到install package的界面。注意已经安装过的插件在搜索里不会在出现，所以这里我的搜索里看不到MarkdownEditing的。 MarkdownEditing这一插件是在sublime text上写markdown的必须的插件，其包含了markdown的语法补全和高亮，效果如下： 除此之外，MarkdownEditing还提供了两个快捷代码段分别用于插入图片和链接： mdl + tab键：插入链接 [](link) mdi + tab键：插入图片 ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 下面来谈两款可选的插件 OmniMarkupPreviewer如果说MarkdownEditing满足了编辑markdown的需求，那么接下来就该谈一下预览需求了。OmniMarkupPreviewer 提供了html端的预览，其具有如下的快捷功能： command + option + o ：浏览器预览 command + option + x ：导出html control + option + c ：复制html代码 其浏览器端预览效果如下,我个人比较喜欢这种预览方式： MarkdownLivePreview当然，如果不喜欢在浏览器和编辑界面频繁切换，sublime text中也有一款在软件端满足实时预览功能的插件： MarkdownLivePreview同样是通过install package来下载安装，效果如下：不过比较可惜的是，由于是在sublime text端进行实时更新，在编辑文字时会有明显的卡顿，所以不是很推荐这一款插件的预览功能。 到此，在sublime text端编写和预览markdown的插件和环境就基本搞定了！ 部分参考自：https://www.jianshu.com/p/335b7d1be39e]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——语法篇]]></title>
    <url>%2F2019%2F02%2F11%2FMarkdown%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近一时兴起，想搭一个自己的blog玩一玩。 在子泰学长的引领下，我也选择了hexo这一开发框架，至于hexo在Mac上的配置的这些过程在此先省略不谈，我们来谈谈hexo上支持的文件 markdown 格式的语法总结。 一、标题Markdown的标题语法需要与 # 配合使用，在标题文字之前添加一到六个#即可生成一级标题到六级标题。 使用：123456#一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 演示：一级标题二级标题三级标题四级标题五级标题六级标题二、字体Markdown的可以对字体设置：粗体，斜体，斜体加粗和删除线四种。 使用：1234**粗体** (使用中 * 与 _ 的效果相同) *斜体* ***斜体加粗*** ~~删除线~~（注意这里的波浪线为半角符号） 演示：粗体斜体斜体加粗删除线 三、引用Markdown在使用引用时需要与 &gt; 配合操作，在需要应用的文字之前添加 &gt; 即可。 使用：123&gt;一级引用 &gt;&gt;二级引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;多级引用 演示： 一级引用 二级引用 多级引用 四、分割线Markdown中分割线可以用连续三个或三个以上的 - 或 * 来实现，一级标题和二级标题会自带下划线。我在sublime text3中用livepreviewer实时预览时发现，使用超过三个时预览端会出现乱码，但是在用html预览时一切正常。 使用：123---*** ------- 演示： 五、图片图片是一个比较麻烦的东西，但是sublime text3中的MarkdownEditing提供了生成图片格式的快捷键，通过使用快捷键或代码段可以直接生成。 使用：12快捷键：command+shift+k 代码段：mdi+tab键 演示：![]()![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 语法：1234567891011![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容,title可加可不加。如果要修改图片位置，可以用如下写法：&lt;div align=center/left/right&gt;![Alt text](/path/to/img.jpg &quot;Optional title&quot;)同样的，还可以用img标签来调整图片的大小，写法如下：&lt;img src=&quot;http:...&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt;这些写法与html的写法一致。 六、超链接MarkdownEditing也提供了生成超链接的快捷代码段，同样简化了实际操作。 使用：mdl+tab键 演示：[](link) 语法：12[超链接名](超链接地址 &quot;超链接title&quot;) 其中的title同样可加可不加 示例：12[百度](https://baidu.com) [微博](https://weibo.com) 演示：百度微博 七、列表Markdown中的列表分为无序列表和有序列表两种，MarkdownEditing中提供回车自动补全，列表之间可以相互嵌套。 无序列表语法：1234+、-或* + 空格 + 内容 + 无序列表 - 无序列表 * 无序列表 演示： 无序列表 无序列表 无序列表 有序列表语法：1234数字 + . + 空格 + 内容 1. 有序列表 2. 有序列表 3. 有序列表 演示： 有序列表 有序列表 有序列表 列表嵌套语法：123&apos;+&apos; + 一级标题tab + &apos;+&apos; + 二级标题tab + tab + &apos;+&apos; + 三级标题 演示： 一级列表 二级列表 三级列表 二级列表 八、表格表格的语法稍微复杂一点，不过可以把他理解为一个格式匹配的过程，也有一点在画图的意思。 语法：12345表头1 | 表头2 | 表头3 - | :-: | -: 靠左 | 居中 | 靠右 第二行用来格式匹配，默认为左对齐，:-:可以实现居中效果，-:实现右对齐 演示： 表头1 表头2 表头3 靠左 居中 靠右 九、代码Markdown中的代码可以放置在一对反引号 `` 中，注意反引号是键盘上数字 1 左边的键，并不是引号。 语法：`单行代码` ``` 多行代码 多行代码 ``` 参考自：https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
