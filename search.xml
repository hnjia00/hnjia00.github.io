<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络——实现路由算法]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 Dijkstra 算法的路由软件。 实验环境 系统：Mac OS X 10.13.1语言：Python 3.6.5平台：pycharm外部库：networkx，matplotlib 实验过程代码设计现Dijkstra算法的方法有很多种，为了在最短的代码内实现最好的效果，我选择了python来实现，借助networkx的有向图类DiGrapg接口实现了图的存储，通过自己实现的Dijkstra算法完成了搜索。 图的构造我们这里借助networkx库里的DiGraph类来构造有向图。DiGraph存储有向图的边的形式为形如(s，d，w)的三元组形式，其中： s: 边的起点；d: 边的终点；w: 边的代价. 考虑到操作的便捷性，我们使用一个path.txt文件来实现图的各个边的三元组的存储，path.txt的格式如下： 定义好边的数据结构之后，我们利用networkx中的函数add_edge()来实现边的输入和图的构建 12345for line in open("path.txt","r"): #按行读取文件 data.append(line.strip('\n')) for row in data: row=row.split(',') #分割三元组 G.add_edge(eval(row[0]), eval(row[1]), weight=eval(row[2]) Dijkstra算法算法实现的流程图如下： 演示部分networkx库同样集成了图的绘制函数，我们通过与matplotlib库的协同操作来完成图的搜索演示。通过以下代码来实现图的分屏：123plt.figure(figsize=(14, 6)) plt.subplot(121)plt.subplot(122) 通过以下代码来实现初始图的绘制：12pos = nx.spring_layout(G)nx.draw_networkx(G, pos,node_size=300,node_color='#FFB5C5') 通过以下代码来实现图上搜索路径的绘制：123456# 绘制非路径上的边 edges_not_in_path = list(set(G.edges()) - set(edges))edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges_not_in_path]nx.draw_networkx_edges(G, pos, edgelist=edges_not_in_path, edge_color='b',width=edgewidth) # 绘制路径上的边 edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges]nx.draw_networkx_edges(G,pos,edgelist=edges,edge_color='r',width=edgewidth) 执行结果我们这里把网络类比为一个有向图，事实上路由的传输方向可以是双向的。其中，图‘Test Graph’即为初始图；对于图‘The shortest path from 0 to 6’： 红色边：通过Dijkstra算法搜索到的最小代价路径；蓝色边：未采纳的边；边的粗细程度：边的权值，越细代表权值越小. 为了验证我们得到的路径是否是正确的答案，我们使用networkx库中标准的函数进行检验，代码如下：answer=nx.dijkstra_path(G,source=start_node,target=end_node)可以得到输出的answer路径如下，与我们的代码所得出的答案相同： 代码附录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import networkx as nx import matplotlib.pyplot as plt #路由算法实现 def Dijkstra(G,start,end): RG = G.reverse() dist = &#123;&#125; previous = &#123;&#125; for v in RG.nodes(): dist[v] = float('inf') previous[v] = 'none' dist[end] = 0 u = end while u!=start: u = min(dist, key=dist.get) distu = dist[u] del dist[u] for u,v in RG.edges(u): if v in dist: alt = distu + RG[u][v]['weight'] if alt &lt; dist[v]: dist[v] = alt previous[v] = u path=(start,) last= start while last != end: nxt = previous[last] path += (nxt,) last = nxt return path #初始化图函数 def init(G): data = [] for line in open("path.txt","r"): #按行读取文件 data.append(line.strip('\n')) for row in data: #分割三元组 row=row.split(',') G.add_edge(eval(row[0]), eval(row[1]), weight=eval(row[2])) return G if __name__=="__main__": #路由算法实现 G=nx.DiGraph() G=init(G) start_node = 0 end_node = 6 path=Dijkstra(G,start_node,end_node) #标准库函数检测 answer=nx.dijkstra_path(G,source=start_node,target=end_node) print("nx.dijkstra_path's path:") for i in range(len(answer)-1): print(str(answer[i])+'-&gt;',end="") print(answer[i+1]) # 构造最小权值边路径 edges=[] for i in range(len(path)-1): edges.append((path[i],path[i+1])) #绘制初始图 plt.figure(figsize=(14, 6)) plt.subplot(121) plt.title("Test Graph") pos = nx.spring_layout(G) nx.draw_networkx(G, pos,node_size=300,node_color='#FFB5C5') #绘制最小路径结果 plt.subplot(122) plt.title("The shortest path from %d to %d" % (start_node, end_node)) nx.draw_networkx_nodes(G, pos=pos, node_size=300,node_color='#FFB5C5') # 绘制非路径上的边 edges_not_in_path = list(set(G.edges()) - set(edges)) edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges_not_in_path] nx.draw_networkx_edges(G, pos, edgelist=edges_not_in_path, edge_color='b',width=edgewidth) # 绘制路径上的边 edgewidth = [G.get_edge_data(edge[0], edge[1])['weight']/30 for edge in edges] nx.draw_networkx_edges(G, pos, edgelist=edges, edge_color='r',width=edgewidth) #显示 plt.show()]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——实现Go-Back-N]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0Go-Back-N%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 Go-Back-N 的可靠数据传输软件。 实验环境 系统：Mac OS X 10.13.1语言：Java开发平台：eclipse内部库：java.net，java.util 实验过程代码设计为了完成本次试验的要求，我编写了两个Java代码文件，分别实现server端功能和client端功能： server端代码流程主要算法流程如下所示，server端实现在一定丢包率范围内接收数据包并且回传ACK： client端代码流程主要的算法流程如下，client端主要实现数据包的传送以及延迟处理： 主机ip获取在启用Go-Back-N之前，我们首先需要获得个人电脑的IP。在Mac OS X系统，使用终端命令ifconfig即可直接查看主机IP，具体如下： 丢包率为0下的测试为了验证代码的正确性，我首先先把丢包率设置为0查看了具体的传输流程，代码执行结果如下： 窗口长度 windowSize = 4；数据包总数 num = 10；超时限制 Timer = 1000ms 执行结果如下： 丢包率为10%下的测试为了继续验证代码的正确性，而后我把丢包率设置为10%查看了具体的传输流程，代码执行结果如下： 小结本次实验中，我们完成了java的网络编程，模拟了GBN算法的运行，对GBN协议有了进一步的了解。在GBN协议中，接收方会丢弃所有失序的分组，尽管丢弃一个正确接收但是失序的分组有点浪费。但是根据GBN的原理。假定当前期望的编号是n，但是n+1提前达到。因为数据必须是有序交付，接收方可能缓存分组n+1，然后在他收到并交付分组n后，再将该分组交付到上层。但是如果n丢失，则n和n+1的分组都会被重发，因此，接收方只需要丢弃分组n+1即可。这种方法的优点是接收方缓存简单，即接收方不需要缓存任何失序分组。对于发送方来说，他只需要维护窗口的下边界和和nextseqnum在窗口中的位置。对于接收方来说，只需要维护下一个按序接收的分组的序号。 代码附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/************************发送方************************/public class Client &#123; //定义流量窗格长度，起始和终止数据包号，计时器 public static int windowSize; public static int start=0, end, num; public static long timerTime = 0; public static void main(String[] args) throws Exception &#123; //建立连接 InetAddress serverAddress = InetAddress.getByName("192.168.1.106"); DatagramSocket clientSocket = new DatagramSocket(9999); byte[] sendData; Timer timer = new Timer(); timer.schedule(new DelayActionListener(clientSocket), 0L, 500L); //通过输入初始化参数 Scanner scanner = new Scanner(System.in); System.out.println("Please enter number of packets: "); num = scanner.nextInt(); System.out.println("Please enter slide window size: "); windowSize = scanner.nextInt(); System.out.println(); end = start + windowSize; //启动计时 Timer[] timers = new Timer[num]; long startTime = System.currentTimeMillis(); //首先发送第一个流量窗内的数据包 System.out.println("&lt;--Client send packets " + start + " - " + (start+windowSize-1)); for (int i=start;i&lt;end;i++)&#123; sendData = (i + "seq").getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, 8888); clientSocket.send(sendPacket); &#125; //循环发送剩余的数据包 while (true)&#123; byte[] recvData = new byte[100]; DatagramPacket recvPacket = new DatagramPacket(recvData, recvData.length); clientSocket.receive(recvPacket); String in = new String(recvPacket.getData()).trim(); int ack_seq = Integer.parseInt(in.substring(3, in.length())); System.out.println("--&gt;Client received ACK: " + (ack_seq-1)); //正常情况 if (ack_seq &gt;= start &amp;&amp; ack_seq &lt; end)&#123; int oldEnd = end; start = ack_seq; end = ack_seq + windowSize; if (end &gt; num) end = num; //发送数据包 for (int i = oldEnd; i &lt; end; i++) &#123; sendData = (i + "seq").getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, 8888); clientSocket.send(sendPacket); System.out.println("&lt;--Client sent packet "+i); &#125; timerTime = System.currentTimeMillis(); &#125; //传到流量窗的右界限 if (ack_seq == end) timerTime = 0; //传输结束 if (ack_seq == num)&#123; timer.cancel(); System.out.println("Success sent all packets"); System.out.println("Time to send " + num + " packets successfully was " + (System.currentTimeMillis() - startTime) + "ms"); return; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/************************接收方************************/public class Server &#123; public static void main(String[] args) throws Exception &#123; //创建套接字，初始化参数 DatagramSocket serverSocket = new DatagramSocket(8888); int endReceive = 0; int missedCtr = 0; System.out.println("\n\n\nServer started.\n"); while (true)&#123; byte[] data = new byte[100]; //接收数据包 DatagramPacket receivePacket = new DatagramPacket(data, data.length); serverSocket.receive(receivePacket); //截取seq String in = new String(receivePacket.getData()).trim(); int seq = Integer.parseInt(in.substring(0, in.length() - 3)); System.out.println("Received packet " + seq+"&lt;--"); //在一定丢包率的范围内操作 if (seq == 0 || Math.random()&lt;=0.9)&#123; //接收数据包并发送ACK if (seq == endReceive)&#123; endReceive++; byte[] ackData = new String("ack"+endReceive).getBytes(); InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); DatagramPacket sendPacket = new DatagramPacket(ackData, ackData.length, clientAddress, clientPort); serverSocket.send(sendPacket); System.out.println("Server sent ACK: " + seq+"--&gt;"); &#125; //有数据包超前到达 else if (endReceive != 0)&#123; if (seq == endReceive + 1) &#123; System.out.println("Packet lost or disordered on way to server: " + endReceive); missedCtr++; System.out.println("Missed: " + missedCtr); &#125; byte[] ackData = new String("ack"+(endReceive)).getBytes(); InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); DatagramPacket sendPacket = new DatagramPacket(ackData, ackData.length, clientAddress, clientPort); serverSocket.send(sendPacket); System.out.println("Server sent ACK: " + (endReceive-1)+"--&gt;"); &#125; &#125; //有数据包丢失 else &#123; System.out.println("Drop packet " + seq); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——用smtp实现Email客户端]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%94%A8smtp%E5%AE%9E%E7%8E%B0Email%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[实验目的运用各种编程语言实现基于 smtp 协议的 Email 客户端软件。 实验环境 系统：Mac OS X 10.13.1语言：Java连接协议：smtp邮箱主机：smtp.qq.com（qq邮箱）外部jar文件：javax.mail.jar 实验过程代码部分为了完成本次试验的要求，我编写了一个Java代码文件，具体的算法流程如下： 邮箱端配置为了方便起见，我在这里使用qq邮箱作为我的测试邮箱，但是qq邮箱默认是关闭smtp服务的，所以我们需要先开启smtp协议。 首先在qq邮箱的个人账户部分找到如下服务的对应位置（此图为开启之后所截，故显示已经开启）： 配合手机操作操作之后，我们可以得到如下的开通反馈，其中返回的授权码极为重要，其关系到代码中transport.connect（）方法的执行成功与否： 代码测试由查阅可得，qq邮箱的服务器如下，且使用端口为465或587：将服务器（smtp.qq.com）、端口(465)、收件人(835381071@qq.com)发件人邮箱(835381071@qq.com)和标题内容设置好之后，通过授权码执行连接，可以debug测试输出如下： 执行结果最后为了验证我们的执行结果，打开qq邮箱的收件箱，可以看到如下信息： 代码附录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package smpt;import java.util.Properties;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;public class SendmailUtil &#123; public static void main(String[] args) throws AddressException, MessagingException &#123; Properties properties = new Properties(); // 使用smtp协议 properties.put("mail.transport.protocol", "smtp"); //qq邮箱的主机名 properties.put("mail.smtp.host", "smtp.qq.com"); //qq邮箱使用465端口 properties.put("mail.smtp.port", 465); // 端口号 //login验证 properties.put("mail.smtp.auth", "true"); //使用ssl安全连接 properties.put("mail.smtp.ssl.enable", "true"); // 设置是否显示debug信息 true 会在控制台显示相关信息 properties.put("mail.debug", "true"); // Session用于收集JavaMail运行过程中的环境信息 Session session = Session.getInstance(properties); // 获取邮件对象 Message message = new MimeMessage(session); // 设置发件人邮箱地址 message.setFrom(new InternetAddress("835381071@qq.com")); // 设置收件人地址 message.setRecipients( RecipientType.TO, new InternetAddress[] &#123; new InternetAddress("835381071@qq.com") &#125;); // 设置邮件标题 message.setSubject("smtp测试邮件"); // 设置邮件内容 message.setText("内容：smtp发送邮件成功！"); // 得到邮差对象 Transport transport = session.getTransport(); // 连接自己的邮箱账户 transport.connect("835381071@qq.com", "sgxclkuvvirtbdfe"); // 发送邮件 transport.sendMessage(message, message.getAllRecipients()); &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——JAVA实现web服务器]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94JAVA%E5%AE%9E%E7%8E%B0web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[趁着这几天刚开学，时间还比较宽裕，决定来整理一下自己的实验报告，先从计网开始。 实验目的 处理一个 http 请求 接收并解析 http 请求 从服务器文件系统中获得被请求的文件 创建一个包括被请求的文件的 http 响应信息 直接发送该信息到客户端 实验环境 系统：Mac OS X 10.13.1 语言：JAVA 浏览器：Google Chrome 实验步骤前期准备为了完成本次试验的要求，我编写了两个java代码文件，分别命名为：“HttpRequest.java”和“WebServer.java”。除此之外，我还编写了两个带跳转的测试网页“index.html”和“next.html”以及其各自包含的图片“first.jpg”和“next.jpg” HttpRequest.java的主要功能为：获取http请求中的套接字的输入流和输出流，即完成“对从服务器端发回的数据流”和“将要发送到服务器端的数据流”的处理和输出。 WebServer.java的主要功能为：创建线程，连续创建套接字以及处理http请求。 文件清单如下： 测试阶段我们使用jdk的javac指令对java代码进行编译，然后启动服务器的默认端口8080（代码中预设），然后在Google Chrome浏览器中对各种情况进行测试和检测输出，具体步骤如下。 首先我们启动终端，进入Java代码所在的文件夹下，然后利用javac命令编译main方法所在的Java文件“WebServer.java”，启动服务器，具体如下： 由于代码中设置的启动端口为8080，如下：所以我们在浏览器中需要输入网址“localhost:8080/index.html”以达到访问该网页的目的，具体如下： 在成功访问该网页之后，我们来观察一下终端的输出情况，发现其请求网页index.html请求成功如下：其请求网页包含的图片first.jpg请求成功如下： 然后点击跳转链接，跳转至next.html，访问下一个网页，同样的，网页跳转成功如下： 在成功打开网页之后，我们来观察一下终端的输出情况。同样的，请求网页“next.html”和“next.jpg”成功，输出如下结果： 当然，除了能成功访问的网页外，我们还需要测试一下错误路径的文件访问结果，于是在浏览器中输入一个错误的网址如“localhost:8080/404.html”，结果如下，提示文件不存在：终端反馈输出对404.html这个不存在的文件的访问结果： 代码附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/***********HttpRequest***************/import java.io.* ;import java.net.* ;import java.util.* ;final class HttpRequest implements Runnable &#123; final static String CRLF = "\r\n"; Socket socket; //构造请求类 public HttpRequest(Socket socket) throws Exception &#123; this.socket = socket; &#125; //启动线程 public void run() &#123; try &#123; processRequest(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; private void processRequest() throws Exception &#123; //获取套接字的输入流，即从服务器端发回的数据流 InputStream is = socket.getInputStream(); //获取套接字的输出流，返回的输出流就是将要发送到服务器端的数据流 DataOutputStream os = new DataOutputStream(socket.getOutputStream()); //缓冲字符输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); // 获取http的request信息 String requestLine = br.readLine(); // 从请求行中提取文件信息 StringTokenizer tokens = new StringTokenizer(requestLine); // 由于token将请求行分解为了单词，我们在这里跳过第一个单词，即“GET” tokens.nextToken(); // GET之后即为文件名 String fileName = tokens.nextToken(); // 为了将文件转化到当前目录下，我们在其之前加一个“.” fileName = "." + fileName ; // 打开文件 FileInputStream fis = null ; boolean fileExists = true ; //判断文件是否查询到 try &#123; fis = new FileInputStream(fileName); &#125; catch (FileNotFoundException e) &#123; fileExists = false ; &#125; //测试输出 System.out.println("\n*************Request**************\n"); System.out.println(requestLine); String headerLine = null; while ((headerLine = br.readLine()).length() != 0) &#123; System.out.println(headerLine); &#125; // 构造response信息 String statusLine = null; String contentTypeLine = null; String entityBody = null; if (fileExists) &#123; //执行成功的话返回“200 OK” statusLine = "HTTP/1.0 200 OK" + CRLF; contentTypeLine = "Content-Type: "+contentType(fileName) + CRLF; &#125; else &#123; //执行失败，文件未找到的时候返回“404 File Not Found” statusLine = "HTTP/1.0 404 File Not Found" + CRLF; contentTypeLine = "Content-Type: text/html" + CRLF; entityBody = "&lt;HTML&gt;" + "&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;" + "&lt;P&gt;File name:&lt;/P&gt;"+fileName+ "&lt;BODY&gt;Not Found&lt;/BODY&gt;&lt;/HTML&gt;"; &#125; // 将上述返回值依次输出 os.writeBytes(statusLine); os.writeBytes(contentTypeLine); os.writeBytes(CRLF); System.out.println("\n*************Response**************\n"); System.out.println(statusLine); //调用文件类型输出方法 if (fileExists) &#123; sendBytes(fis, os); fis.close(); &#125; else &#123; os.writeBytes(entityBody) ; &#125; // 结束关闭 os.close(); br.close(); socket.close(); &#125; private static void sendBytes(FileInputStream fis, OutputStream os) throws Exception &#123; //构造一个1K缓冲区，承接套接字的内容 byte[] buffer = new byte[1024]; int bytes = 0; //将请求的文件复制到套接字的输出流中。 while ((bytes = fis.read(buffer)) != -1) &#123; os.write(buffer, 0, bytes); &#125; &#125; private static String contentType(String fileName) &#123; if(fileName.endsWith(".htm") || fileName.endsWith(".html")) &#123; return "text/html"; &#125; else return "other Content-type" ; &#125;&#125; 12345678910111213141516171819202122232425/***********WebServer***************/import java.io.* ;import java.net.* ;import java.util.* ;public final class WebServer &#123; public static void main(String argv[]) throws Exception &#123; int port=8080; // 建立一个套接字 ServerSocket socket = new ServerSocket(port); while (true) &#123; // 监听一个tcp连接的request. Socket connection = socket.accept(); // 处理HTTP请求消息。 HttpRequest request = new HttpRequest(connection); // 建立一个线程处理请求 Thread thread = new Thread(request); thread.start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次聚会]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%81%9A%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天正月十五，也不能说是闲来无事，毕竟还有那么多前路未卜的事情在等着自己，但是总归还是想写一些清闲的东西。 离开学还有五天，还在家能待三天。 今天去马骁家里聚会了，难得小聚一次，吃够了羊肉也喝够了粗，打够了麻将也赢够了钱。 大家都在为自己的前途开始迷茫了，没有明确的路子可走的人大概就是我们这一批大三的学生吧。 学生生涯还剩一年半，留给自己预备的选择也是众说纷纭。 考研怎么考能考得上哪，保研怎么找老师怎么不亏，出国又该怎么闹。 没有人知道该怎么办，就像有人说zgs的cpp课好一样，每个人都只有自己的路，你没有义务去让所有人都跟着自己的路走。 我也没有能力去辨别谁才是自己的模版。 毕竟这世界上，只有一个独一无二的贾浩男。 大家都好久没踢球了，曾经的前锋马骁也吃撑了一百九的中后卫，曾经的后卫现在也早就离开了操场。 被繁杂的课程，学业和人生压的不知所措。 但是有趣的是，我们每个人仿佛还走在自己自认为正确的道路上，自我感觉良好。 我总是难以定夺自己到底应该，或是值得去做什么。 我喜欢观望，观望才能给我很好的选择正确的机会。 但是观望，观望谁呢，谁有值得观望呢？ 无从所知。 我喜欢在街头看着各种各样的人的走走停停，去看他们的生活。 就像我最喜欢的实用文摘的板块，是社会百态。 在一个社会里，每个人都有着自己独一无二的生活。 品味这些生活，也真是一个有趣的过程。]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——评论篇]]></title>
    <url>%2F2019%2F02%2F16%2FHexo%E2%80%94%E2%80%94%E8%AF%84%E8%AE%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天给琳琳看了下内测博客的初版，大体上还比较不错。 为了满足琳琳的需求，方便交流，我决定今天给博客添加评论功能。 网上的博客有很多，还是比较乱七八糟的，所以配好之后自己再总结一下，方便后人乘凉。 来必力在跟帖的插件中我选择了来必力：https://www.livere.com 有这几个原因： 界面UI美观 评论管理方便 支持多个社交账号 不过也有一点不方便，来必力隶属于韩国，在注册使用的时候需要科学上网，在网页加载的时候速度较慢。 下面来讲一下具体布置 注册登陆注册需要科学上网，不然是打不开注册登陆界面的，或者打开很慢？这里不做赘述。 安装选择city版安装就能满足我们的需求，直接安装即可。 安装完之后会以代码形式给出，或者也可以手动进入个人管理界面的 代码管理 查看。 对于NexT主题而言，这里我们主要关注 data-uid 的值。 配置得到用于安装插件的data-uid之后，下一步进入NexT的配置文件 _config.yml 设置data-uid的值。 在_config.yml中找到 livere_uid 的属性字样。 将livere_uid设置为刚刚得到的data-uid的值即可。 部署在上述过程完成之后，部署到博客即可。12$ hexo g$ hexo d 演示完成后的效果如下，支持点赞和折叠评论，支持QQ、微信、微博等多种社交账号： 分析上面的配置过程还是比较容易的，但是如果细看一下我还是有一个疑问的，为什么没有用到来必力提供的安装代码呢，为什么只靠一个data-uid就完成了评论功能？ 在查看了NexT下的相关文件后，我得出了结论。 在 themes/next/layout/_partials 文件夹下，有一个 comments.swig 文件。 在里面可以看到支持多个评论插件的安装脚本，比如Facebook，多说等。 NexT用来加载来必力的安装脚本可以在第45～48行看到，加载脚本为：1234&#123;% elseif theme.livere_uid %&#125; &lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt; &lt;/div&gt; 这段脚本可以用来必力提供的安装代码替换,作用相同：123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="******"&gt;&lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script');&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 在来必力端可以看到具体的评论情况，包括数据分析和评论管理，功能还是非常强大的。 好了，今天的评论的配置就写这么多。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo——bug篇]]></title>
    <url>%2F2019%2F02%2F15%2FHexo%E2%80%94%E2%80%94bug%E7%AF%87%2F</url>
    <content type="text"><![CDATA[昨天写博客的时候，一套hexo操作行云流水，奈何一个hexo g报错报了几百行，在终端里的错误让人害怕的发抖，先上图为敬。 显然这些带有具体文件路径和出错位置的error很难直接百度到解决方法，在百度了很久之后，我找到一个貌似跟我的bug相关的关键词： YAMLException 这是一个在yaml文件中的报错。 于是怀着一个科班出身的计算机人的心态，我决定自己读报错改bug。 首先找到加载出错的原因： ERROR Theme config load failed. 这大概是主题配置文件加载失败了？？？ 其次是出错的文件： ERROR Process failed: _config.yml 果然是主题配置文件出错了！ 继续找一下出错原因： 12345678910111213141516171819202122232425YAMLException: bad indentation of a mapping entry at line 823, column 3: counter: true ^ at generateError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:165:10) at throwError (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:171:9) at readBlockMapping (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1080:7) at composeNode (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1332:12) at readDocument (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1492:3) at loadDocuments (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1548:5) at Object.load (/Users/jiahaonan/blog/node_modules/js-yaml/lib/js-yaml/loader.js:1569:19) at Hexo.yamlHelper (/Users/jiahaonan/blog/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15) at Hexo.tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Hexo.&lt;anonymous&gt; (/Users/jiahaonan/blog/node_modules/bluebird/js/release/method.js:15:34) at Promise.then.text (/Users/jiahaonan/blog/node_modules/hexo/lib/hexo/render.js:61:21) at tryCatcher (/Users/jiahaonan/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/jiahaonan/blog/node_modules/bluebird/js/release/promise.js:694:18) at _drainQueueStep (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:138:12) at _drainQueue (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/Users/jiahaonan/blog/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) 妈耶，一开始看到这些bug我已经准备放弃了，因为这些bug并没有影响我提交博客的相关操作。 但是每次 hexo g 后总跟着几百行报错我看起来很难受啊。 还是继续冷静的分析一下吧。 找到YAMLException的提示位置，第823行。 所以，原来是我多打了一个空格！ 好了，冷静地把空格删掉。 重来一遍hexo g，完美运行～ 这个案例告诉我们，修改文件的时候不要把空格不当回事儿，不然都是bug劝退。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——公式篇]]></title>
    <url>%2F2019%2F02%2F14%2FMarkdown%E2%80%94%E2%80%94%E5%85%AC%E5%BC%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[写完语法和配置之后，当然还得补充一项最常用的 公式 的写法了。 在写word的时候一直是无脑公式编辑器，看见琳琳用的 latex 的时候总是一脸崇拜，时至今日也得学习一下latex的公式表达，它也是markdown所支持的公式写法。 由于公式的书写要求和规范太多了，我这里就不做生产者了，老老实实做个搬运工。 贴两篇比较好的博客，方便学习～ https://www.jianshu.com/p/a0aa94ef8ab2https://www.cnblogs.com/q735613050/p/7253073.html]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——配置篇]]></title>
    <url>%2F2019%2F02%2F13%2FMarkdown%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[上一篇讲了Markdown的语法，接下来说一下Markdown的插件。 Markdown的编辑器有很多，知乎一下就可以看到不少开源友好的编辑器，为了更好的整合我电脑上现有的软件（为了省内存），我决定在sublime text上写Markdown。 我电脑的配置如下： Mac OS X 10.13.1Sublime Text Version 3.1.1 虽然sublime text3自身携带许多语言的高亮，但是还没有达到我想要的Markdown的编写环境，自带的Markdown不好看也不好用，所以需要拿一些插件来满足一下需求。 需要安装的插件： Package Control:插件安装管理MarkdownEditing:显示Markdown的语法和高亮 可选的插件： OmniMarkupPreviewer:浏览器/html快捷预览和导出MarkdownLivePreview:sublime text界面实时预览 Package ControlPackage Control是Sublime Text不可或缺的一个插件，许多插件的安装和管理都要用到它。两个月之前我在配置NASM的语法和高亮插件时安装配置了Package Control，才第一次接触到Sublime Text的除了写字板之外的功能，所以这里要强烈安利Package Control这一插件，让我有了对不止于Sublime Text写字板的用户体验。 安装插件 打开Sublime Text的控制台 快捷键：control + ` 手动：View -&gt; Show Console 在控制台输入下面的第一行python代码回车即可。不过里面的 http://packagecontrol.io/ 应该是被墙了，这个年头程序员没个VPN还怪麻烦的。我在一些博客里找到了镜像网站，如果第一段代码无法安装，可以尝试一下第二种方法（未测） 1import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 1import urllib.request,os,hashlib; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://dn-52cik.qbox.me/' + pf.replace(' ', '%20')).read(); open(os.path.join( ipp, pf), 'wb' ).write(by) 使用安装成功之后，可以在 Sublime Text -&gt; Preference 里看到 Package Control 这一选项，也可以通过组合键 command + shift + p 在搜索框里搜索 Package Control 。 在package control里，最主要使用的是 install package 功能，在install package界面，可以根据个人需求安装所需要的插件。 需要注意的是，最近不使用vpn是无法使用install package功能的，会出现如下提示： 在科学上网之后，可以来到install package的界面。注意已经安装过的插件在搜索里不会在出现，所以这里我的搜索里看不到MarkdownEditing的。 MarkdownEditing这一插件是在sublime text上写markdown的必须的插件，其包含了markdown的语法补全和高亮，效果如下： 除此之外，MarkdownEditing还提供了两个快捷代码段分别用于插入图片和链接： mdl + tab键：插入链接 [](link) mdi + tab键：插入图片 ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 下面来谈两款可选的插件 OmniMarkupPreviewer如果说MarkdownEditing满足了编辑markdown的需求，那么接下来就该谈一下预览需求了。OmniMarkupPreviewer 提供了html端的预览，其具有如下的快捷功能： command + option + o ：浏览器预览 command + option + x ：导出html control + option + c ：复制html代码 其浏览器端预览效果如下,我个人比较喜欢这种预览方式： MarkdownLivePreview当然，如果不喜欢在浏览器和编辑界面频繁切换，sublime text中也有一款在软件端满足实时预览功能的插件： MarkdownLivePreview同样是通过install package来下载安装，效果如下：不过比较可惜的是，由于是在sublime text端进行实时更新，在编辑文字时会有明显的卡顿，所以不是很推荐这一款插件的预览功能。 到此，在sublime text端编写和预览markdown的插件和环境就基本搞定了！ 部分参考自：https://www.jianshu.com/p/335b7d1be39e]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown——语法篇]]></title>
    <url>%2F2019%2F02%2F11%2FMarkdown%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最近一时兴起，想搭一个自己的blog玩一玩。 在子泰学长的引领下，我也选择了hexo这一开发框架，至于hexo在Mac上的配置的这些过程在此先省略不谈，我们来谈谈hexo上支持的文件 markdown 格式的语法总结。 一、标题Markdown的标题语法需要与 # 配合使用，在标题文字之前添加一到六个#即可生成一级标题到六级标题。 使用：123456#一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 演示：一级标题二级标题三级标题四级标题五级标题六级标题二、字体Markdown的可以对字体设置：粗体，斜体，斜体加粗和删除线四种。 使用：1234**粗体** (使用中 * 与 _ 的效果相同) *斜体* ***斜体加粗*** ~~删除线~~（注意这里的波浪线为半角符号） 演示：粗体斜体斜体加粗删除线 三、引用Markdown在使用引用时需要与 &gt; 配合操作，在需要应用的文字之前添加 &gt; 即可。 使用：123&gt;一级引用 &gt;&gt;二级引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;多级引用 演示： 一级引用 二级引用 多级引用 四、分割线Markdown中分割线可以用连续三个或三个以上的 - 或 * 来实现，一级标题和二级标题会自带下划线。我在sublime text3中用livepreviewer实时预览时发现，使用超过三个时预览端会出现乱码，但是在用html预览时一切正常。 使用：123---*** ------- 演示： 五、图片图片是一个比较麻烦的东西，但是sublime text3中的MarkdownEditing提供了生成图片格式的快捷键，通过使用快捷键或代码段可以直接生成。 使用：12快捷键：command+shift+k 代码段：mdi+tab键 演示：![]()![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 语法：1234567891011![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容,title可加可不加。如果要修改图片位置，可以用如下写法：&lt;div align=center/left/right&gt;![Alt text](/path/to/img.jpg &quot;Optional title&quot;)同样的，还可以用img标签来调整图片的大小，写法如下：&lt;img src=&quot;http:...&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt;这些写法与html的写法一致。 六、超链接MarkdownEditing也提供了生成超链接的快捷代码段，同样简化了实际操作。 使用：mdl+tab键 演示：[](link) 语法：12[超链接名](超链接地址 &quot;超链接title&quot;) 其中的title同样可加可不加 示例：12[百度](https://baidu.com) [微博](https://weibo.com) 演示：百度微博 七、列表Markdown中的列表分为无序列表和有序列表两种，MarkdownEditing中提供回车自动补全，列表之间可以相互嵌套。 无序列表语法：1234+、-或* + 空格 + 内容 + 无序列表 - 无序列表 * 无序列表 演示： 无序列表 无序列表 无序列表 有序列表语法：1234数字 + . + 空格 + 内容 1. 有序列表 2. 有序列表 3. 有序列表 演示： 有序列表 有序列表 有序列表 列表嵌套语法：123&apos;+&apos; + 一级标题tab + &apos;+&apos; + 二级标题tab + tab + &apos;+&apos; + 三级标题 演示： 一级列表 二级列表 三级列表 二级列表 八、表格表格的语法稍微复杂一点，不过可以把他理解为一个格式匹配的过程，也有一点在画图的意思。 语法：12345表头1 | 表头2 | 表头3 - | :-: | -: 靠左 | 居中 | 靠右 第二行用来格式匹配，默认为左对齐，:-:可以实现居中效果，-:实现右对齐 演示： 表头1 表头2 表头3 靠左 居中 靠右 九、代码Markdown中的代码可以放置在一对反引号 `` 中，注意反引号是键盘上数字 1 左边的键，并不是引号。 语法：`单行代码` ``` 多行代码 多行代码 ``` 参考自：https://www.jianshu.com/p/191d1e21f7ed]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
